using System;
using System.Collections.Generic;
using System.Text;
using Ara3D.Utils;
using Plato.Compiler.Analysis;
using Plato.Compiler.Symbols;
using Plato.Compiler.Types;

namespace Plato.CSharpWriter
{
    public class CSharpWriter : CodeBuilder<CSharpWriter>
    {
        public CSharpWriter(Compiler.Compilation compilation, DirectoryPath outputFolder)
        {
            Analyzer = new PlatoAnalyzer(compilation);
            OutputFolder = outputFolder;
        }

        public string FloatType;
        public string Namespace;


#if CHANGE_PRECISION
        public string OtherPrecisionFloatType;
        public string OtherPrecisionNamespace;
#endif

        public Compiler.Compilation Compilation => Analyzer.Compilation;
        public PlatoAnalyzer Analyzer { get; }
        public Dictionary<string, StringBuilder> Files { get; } = new Dictionary<string, StringBuilder>();

        public DirectoryPath OutputFolder { get; }

        public static HashSet<string> IgnoredTypes = new HashSet<string>()
        {
            "Dynamic",
            "Array",
            "Array2D",
            "Array3D",
            "Function0",
            "Function1",
            "Function2",
            "Function3",
        };

        public static HashSet<string> IgnoredFunctions = new HashSet<string>()
        {
            "FieldNames",
            "FieldValues",
            "TypeName",
            "Components",
            "CreateFromComponents",
            "NumComponents",
            "Equals",
            "NotEquals",
            "GetHashCode",
            "ToString",
            "GetType",
        };

        public static Dictionary<string, string> PrimitiveTypes = new Dictionary<string, string>()
        {
            { "Number", "float" },
            { "Boolean", "bool" },
            { "Integer", "int" },
            { "Character", "char" },
            { "String", "string" },
            { "Dynamic", "object" },
            { "Type", "System.Type" },
            { "Function0", "Func" },
            { "Function1", "Func" },
            { "Function2", "Func" },
            { "Function3", "Func" },
            { "Function4", "Func" },
            { "Function5", "Func" },
            { "Function6", "Func" },
            { "Function7", "Func" },
            { "Function8", "Func" },
            { "Function9", "Func" },
        };

        public static HashSet<string> IntrinsicTypes = new()
        {
            "Angle", 
            "Matrix3x2", 
            "Matrix4x4", 
            "Quaternion", 
            "Plane", 
            "Vector2", 
            "Vector3", 
            "Vector4", 
            "Vector8"
        };

        public CSharpWriter WriteFile(FilePath fileName, Func<CSharpWriter> f)
        {
            StartNewFile(fileName);
            WriteLine($"// Autogenerated file: DO NOT EDIT");
            WriteLine($"// Created on {DateTime.Now}");
            WriteLine();
            WriteLine("using System.Runtime.CompilerServices;");
            WriteLine("using System.Runtime.Serialization;");
            WriteLine("using System.Runtime.InteropServices;");
            WriteLine("using static System.Runtime.CompilerServices.MethodImplOptions;");
            WriteLine("");
            WriteLine($"namespace {Namespace}");
            WriteStartBlock();
            f();
            WriteEndBlock();
            return this;
        }

        public CSharpWriter WriteAll(string floatType)
        {
            FloatType = floatType;
            Namespace = floatType == "float"
                ? "Plato"
                : floatType == "double"
                    ? "Plato.DoublePrecision"
                    : throw new NotImplementedException("Only 'float' and 'double' are supported");
#if CHANGE_PRECISION
            OtherPrecisionFloatType = floatType == "float" ? "double" : "float";
            OtherPrecisionNamespace = floatType == "float" ? "Plato.DoublePrecision" : "Plato";
#endif 

            WriteFile("Interfaces.g.cs", WriteConceptInterfaces);
            WriteFile("Constants.g.cs", WriteConstantLibraryMethods);
            WriteFile("Extensions.g.cs", WriteInterfaceLibraryMethods);

            foreach (var c in Compilation.ConcreteTypes)
            {
                var name = c.TypeDef.Name;
                if (!IgnoredTypes.Contains(name))
                    WriteFile($"_{name}.g.cs", () => WriteTypeImplementation(c));
            }

            return this;
        }

        public void StartNewFile(string fileName)
        {
            sb = new StringBuilder();
            Files.Add(fileName, sb);
        }

        public CSharpTypeWriter NewDefaultTypeWriter() 
            => new CSharpTypeWriter(this, null);

        public CSharpWriter WriteConstantFunction(FunctionDef f)
        {
            var tmp = NewDefaultTypeWriter();
            var fi = tmp.ToFunctionInfo(f, null, FunctionInstanceKind.Constant);
            tmp.WriteStaticFunction(fi);
            return Write(tmp.ToString());
        }

        public CSharpWriter WriteExtensionFunction(FunctionDef f)
        {
            var tmp = NewDefaultTypeWriter();
            var fi = tmp.ToFunctionInfo(f, null, FunctionInstanceKind.InterfaceExtension);
            tmp.WriteExtensionFunction(fi);
            return Write(tmp.ToString());
        }

        public CSharpWriter WriteConstantLibraryMethods()
        {
            WriteLine($"public static class Constants");
            WriteStartBlock();
            foreach (var f in Compilation.Libraries.AllConstants())
                WriteConstantFunction(f);
            WriteEndBlock();
            return this;
        }

        public CSharpWriter WriteInterfaceLibraryMethods()
        {
            WriteLine($"public static class Extensions");
            WriteStartBlock();
            foreach (var f in Compilation.Libraries.AllFunctions())
            {
                if (f.NumParameters > 0)
                {
                    var pt = f.Parameters[0].Type;
                    if (!pt.Def.IsInterface())
                        continue;

                    // TODO: this is a HACK! we are temporarily only enabling this for IArray. 
                    // Ultimately it needs to be done with Self-constrained versions of the interfaces. 
                    // Writing those function signatures will be a lot of work. 
                    // Even then, there could be some problems (like 
                    if (!pt.Def.Name.StartsWith("IArray")) 
                        continue; 

                    WriteExtensionFunction(f);
                }
            }
            WriteEndBlock();
            return this;
        }

        public CSharpWriter WriteConceptInterface(TypeDef type)
        {
            var tmp = new CSharpTypeWriter(this, type);
            tmp.WriteConceptInterface();
            return Write(tmp.ToString());
        }

        public CSharpWriter WriteConceptInterfaces()
        {
            foreach (var c in Compilation.AllTypeAndLibraryDefinitions)
                if (c.IsInterface())
                    WriteConceptInterface(c);
            return this;
        }

        public CSharpWriter WriteTypeImplementation(ConcreteType concreteType)
        {
            var tmp = new CSharpTypeWriter(this, concreteType.TypeDef);
            tmp.WriteConcreteType(concreteType);
            return Write(tmp.ToString());
        }
    }
}