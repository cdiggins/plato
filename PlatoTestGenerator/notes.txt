To-do:

* Get the list of implemented interfaces 
* Definition (and requirement) of "INumeric" is that every field is INumeric
	* Need to validate that.
* Definition (and requirement) of "IVector" is that it is also an INumeric, and that the elements are "INumeric"
* NOTE: a collection of some INumeric type, should automatically have some operations. 
* Todo: there needs to be a bunch of math functions: Math.Sqrt, Math.Abs, etc. 
	* These need to be extension methods (float/double/int/etc.)
	* Then they have to work on all of the INumeric types themselves as extension methods 
* There are then math functions that make sense on an "IVector" or more specifically, any "IArray<Z>". 
	* Maybe for things like Sum() they could work on an IEnumerable. 
	* What would I get ... "Average", "Sum", "Variance", "StandardDeviation". 
	* PrefixSums, PostfixSums, PartialDifference 
	* Maybe a bit more excel type stuff: Binormal distrubition function, Chisquare, 
	* Frequency/histogram
	* Mode/median 
	* Skew/Kurtosis 
	* Student-T distribution 
	* COrrelation 
	* DotProduct 
* To-do: add the interface chain!!! 
* Given a TypeReference ... how do I figure out the declaration?

//==

How should Unity work with Plato code and vice versa.

I want an animation controller:
* Animation controller allows you to assign arbitrary animation to different fields? 
	* I'll say start the animation now, 
	* Animate(50.Seconds(), 1f, 3f);
	* But how do I track it? 
	* I can't "animate" 
	* I have to run the values through the animation controller, which will provide me with values? 
	* var pos = (Circle(t) * Radius).Animate(50.Seconds(), 1f, 3f);

* That last bit is kind of obvious ... I suppose? But the problem is where is time coming from? 
* There are some systems that come directly from the computer, and I can't really do much about that. 

* FileSystem / Keyboard / Mouse / OS / Network / Debugger / Peripherals / Clock 

* So let's say that the animation only starts when a certain condition is set ...
* And let's say the values of that animation are determined elsewhere. 

	* var t = ??;
	* t *= Controller.AddAnimation(50.Seconds(), 0f, 1f);
	* var pos = (Circle(t) * Radius);

* Now the question is, 

	* var t = ??;
	* curve = Controller.AddAnimation(50.Seconds(), 0f, 1f);
	* var pos = (Circle(t * curve) * Radius);

* This is the easy thing. 

* Not even imperative. 
* the challenge is when I want to do something like create a ripple everytime someone clicks.
* The ripple is a thing. I need to collect the ripple curves. 
* That is a list. The list is mutable.
* Each thing in the list is a kind of influence
* The list is the only affine type I need 
//==

* Maybe I could put the VIM structs in a new namespace, and then just generate everything in another namespace. 
Could that work? 

* The problem is that the usage in functions would be mostly illegal. 
* Maybe I 

//==

To-do: 
- With templates all functions have to be defined as extensions.
- The template doesn't allow for much. 
- Well ... technically it does. 
- But the problem is that any function using something else, will fail. This is because in the "template" namespace, things are different. 


- I need to:
	- Infer the "static". Well it is always static, so that is easy.
	- Infer the interfaces. 
	- Does it implement an interface? If so, great then get the interface.
	- Does it implement an 
	- Infer operations
	- Infer composite actions 
	- Infer implicit casts (e.g., ) when only one value, we know that it can to/from that thing.
	- Interface 
	- Functions are made static. 
	- Static function are placed inside the class. 
	- Can a class have a static and non-static with the same name? 


    class AnimatedValue<T>
    {
        Time Time;
        T Value => Function(Time);
        Func<Time, T> Function;
    }

    class Animation<T>
    {
        Func<Time, T> Function;
        T GetValue(Time time) => Function(time);
    }

    public class Mesh
    {
        public IArray<Triangle> Triangles { get; }
        public IArray<Double2> UVs { get; }
        public IArray<Double3> Points { get; }
        public IArray<Int3> Indices { get; }
    }

// 

It's always going to be the same problem. 

I need to compile to have working code.
So ... 

There is part 1: 
* Get the structs and make them valid.
* Part two write the algorithms
* IF I write them as static functions, it is fine ... it just works.  
* If I want to use fluent API in the algorithms, I have to wait for the 
	extension methods to be created. 
* The problem is that those fluent methods are where? 
	I mean if I just write some algorithms, is it going to make a copy of those 
	functions? 
* It's a bit funny, but some of this is just a question of writing it out. 
* The last problem is wrestling with the darn intellisense. 
* Intellisense wants everything to be public / static / compile, etc. 

//==

So what about the interfaces? 
In order to add fun interfaces to the classes, I will have to look for extension methods.
	
//==

Can I do the math operations automatically? 

Does Plato have to be valid C#? Or can I just make it generate. 

After compilation, it will probably all just work. 

The question though is how do I deal with type constraints on numerics. 

I could use a placeholder. 

I don't have to be strict. This is mostly a code generation issue. 
 
I could have a value called "Number" that acts as an implicit place holder. 
Same with Value. 

I could enumerate it Value1, Value2. This implies that they are both values
but different. 

The thing is that operations on generics that are different.

An operation that mixes two different types of numbers is not possible.

Treating an interface like a template argument. 

Some interfaces aren't really interfaces. They are actually 

//==

* I invented concepts.
* It isn't really that useful.
* So the thing is that I need to have interfaces and implementations.
* IArray<T>
* I want to write a Sum() function, so how do I do that?
* So ... I wanto to write some of the algorithms, that are going to be used. 
* IVector ... 

//==

Vector / Number 

* What am I doing? 
* I am defining classes that can be used as a "templates". 
* Do they need to be valid C#? 
	* Maybe. 
* I have decided that Plato is going to be much simpler than C#. 
	* The syntax is tight and small. 
* The thing is that the idea of just predefining all of these extra things is a bit burdensome.
	* HOWEVER ... I don't have time to fix everything. 
	* What I need is for the class templates to just work. 
	* So generate all of the necessary code. 
	* By the way, instead of types, they could just be functions. 
	* That would be interesting. 
* The problem is that I'm getting way too fancy off the bat. 
	* Keep it simple.
	* Look at the structs, generate the core stuff. 
	* Using Roslyn. 
	* The whole thing was a paper tiger.

* I need a "PlatoInput" project.
	* It will have a source file. 
	* I need to restructure all of this stuff. 
	* I need to take it seriously.
	* RIght now I'm confused, and half the stuff isn't used. 
	* People are going to be using this next weekend. 
	* So better get cracking. 

* To do that I will need to:
	* Port the math routines over. 
	* Most should work. 

* So once I have the types, what about the algorithsm. 
	* Where do they live? 
	* I can't just keep adding things to the generator can I? 
	* I need a place to write stuff. 

* The example is:
	* Capsule. 
	* Capsule

* What I find amazing, is that this looks exactly like the visual language I wanted. 

* So we do the structs first. 
* Then we do a pass on the algorithms.

* AlmostEquals
* Epsilon
* Comparison = Gt  :t  
* Measures can be added together 
* CompareTo 
* Measures can be compared
* Clamp 
* Lerp

* Magnitude
* Dot
* MagnitudeSquared
* Sum
* Product


* Compare
* Min
* Max
