// NOTE: Autogenerated file created on 2023-03-01 1:55:48 PM. DO NOT EDIT!
using System;
using System.Linq;

namespace PlatoParser
{
    // Original Rule: (((Digits+(FractionalPart)?)+(ExponentPart)?)+(FloatSuffix)?)
    // Only Nodes: 
    public class FloatLiteral : AstNode
    {
        public FloatLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FloatLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("0x"|"0X")+(HexDigit+(HexDigit)*))+(IntegerSuffix)?)
    // Only Nodes: 
    public class HexLiteral : AstNode
    {
        public HexLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new HexLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("0b"|(("0B"+(BinDigit+(BinDigit)*))+(IntegerSuffix)?))
    // Only Nodes: 
    public class BinaryLiteral : AstNode
    {
        public BinaryLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BinaryLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((Digits+!([.fFdDmM]))+(IntegerSuffix)?)
    // Only Nodes: 
    public class IntegerLiteral : AstNode
    {
        public IntegerLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new IntegerLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((op_Implicit+(StringLiteralChar)*)+op_Implicit)
    // Only Nodes: 
    public class StringLiteral : AstNode
    {
        public StringLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new StringLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((op_Implicit+CharLiteralChar)+op_Implicit)
    // Only Nodes: 
    public class CharLiteral : AstNode
    {
        public CharLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new CharLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("true"+!(IdentifierChar))+WS)|(("false"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class BooleanLiteral : AstNode
    {
        public BooleanLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BooleanLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("null"+!(IdentifierChar))+WS)
    // Only Nodes: 
    public class NullLiteral : AstNode
    {
        public NullLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new NullLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("value"+!(IdentifierChar))+WS)
    // Only Nodes: 
    public class ValueLiteral : AstNode
    {
        public ValueLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ValueLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((((((((HexLiteral|BinaryLiteral)|FloatLiteral)|IntegerLiteral)|StringLiteral)|CharLiteral)|BooleanLiteral)|NullLiteral)|ValueLiteral)
    // Only Nodes: (HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral|ValueLiteral)
    public class Literal : AstChoice
    {
        public Literal(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Literal(Children.Select(f).ToArray());
        public HexLiteral HexLiteral => Children[0] as HexLiteral;
        public BinaryLiteral BinaryLiteral => Children[0] as BinaryLiteral;
        public FloatLiteral FloatLiteral => Children[0] as FloatLiteral;
        public IntegerLiteral IntegerLiteral => Children[0] as IntegerLiteral;
        public StringLiteral StringLiteral => Children[0] as StringLiteral;
        public CharLiteral CharLiteral => Children[0] as CharLiteral;
        public BooleanLiteral BooleanLiteral => Children[0] as BooleanLiteral;
        public NullLiteral NullLiteral => Children[0] as NullLiteral;
        public ValueLiteral ValueLiteral => Children[0] as ValueLiteral;
    }

    // Original Rule: ((">>>="+WS)|(">>>"+WS)|(">>="+WS)|("<<="+WS)|("&&="+WS)|("||="+WS)|(">>"+WS)|("<<"+WS)|("&&"+WS)|("||"+WS)|("+="+WS)|("-="+WS)|("*="+WS)|("/="+WS)|("%="+WS)|("&="+WS)|("|="+WS)|("^="+WS)|("<="+WS)|("=>"+WS)|("=="+WS)|("!="+WS)|("??"+WS)|("?="+WS)|("+"+WS)|("-"+WS)|("*"+WS)|("/"+WS)|("%"+WS)|("&"+WS)|("|"+WS)|("^"+WS)|("="+WS)|("<"+WS)|(">"+WS))
    // Only Nodes: 
    public class BinaryOperator : AstNode
    {
        public BinaryOperator(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BinaryOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("++"+WS)|("--"+WS)|("!"+WS)|("-"+WS)|("+"+WS)|("~"+WS))
    // Only Nodes: 
    public class UnaryOperator : AstNode
    {
        public UnaryOperator(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new UnaryOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("["+WS)+Expression)+("]"+WS))
    // Only Nodes: Expression
    public class Indexer : AstNode
    {
        public Indexer(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Indexer(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ((">>>"+WS)|("++"+WS)|("--"+WS)|("<<"+WS)|(">>"+WS)|("=="+WS)|("!="+WS)|("<="+WS)|(">="+WS)|("+"+WS)|("-"+WS)|("!"+WS)|("~"+WS)|("*"+WS)|("/"+WS)|("%"+WS)|("&"+WS)|("|"+WS)|("^"+WS)|("<"+WS)|(">"+WS))
    // Only Nodes: 
    public class OverloadableOperator : AstNode
    {
        public OverloadableOperator(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new OverloadableOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (((((((((("++"+WS)|("--"+WS)|("!"+WS)|("?"+WS))|MemberAccess)|ConditionalMemberAccess)|FunctionArgs)|Indexer)|TernaryOperation)|BinaryOperation)|IsOperation)|AsOperation)
    // Only Nodes: (MemberAccess|ConditionalMemberAccess|FunctionArgs|Indexer|TernaryOperation|BinaryOperation|IsOperation|AsOperation)
    public class PostfixOperator : AstChoice
    {
        public PostfixOperator(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new PostfixOperator(Children.Select(f).ToArray());
        public MemberAccess MemberAccess => Children[0] as MemberAccess;
        public ConditionalMemberAccess ConditionalMemberAccess => Children[0] as ConditionalMemberAccess;
        public FunctionArgs FunctionArgs => Children[0] as FunctionArgs;
        public Indexer Indexer => Children[0] as Indexer;
        public TernaryOperation TernaryOperation => Children[0] as TernaryOperation;
        public BinaryOperation BinaryOperation => Children[0] as BinaryOperation;
        public IsOperation IsOperation => Children[0] as IsOperation;
        public AsOperation AsOperation => Children[0] as AsOperation;
    }

    // Original Rule: (IdentifierFirstChar+(IdentifierChar)*)
    // Only Nodes: 
    public class Identifier : AstNode
    {
        public Identifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Identifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (BinaryOperator+Expression)
    // Only Nodes: (BinaryOperator+Expression)
    public class BinaryOperation : AstSequence
    {
        public BinaryOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BinaryOperation(Children.Select(f).ToArray());
        public BinaryOperator BinaryOperator => Children[0] as BinaryOperator;
        public Expression Expression => Children[1] as Expression;
    }

    // Original Rule: (((("?"+WS)+Expression)+(":"+WS))+Expression)
    // Only Nodes: (Expression+Expression)
    public class TernaryOperation : AstSequence
    {
        public TernaryOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TernaryOperation(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
        public Expression Expression_1 => Children[1] as Expression;
    }

    // Original Rule: ((("("+WS)+(((Expression+WS)+(((Comma+Expression)+WS))*))?)+(")"+WS))
    // Only Nodes: (Expression)*
    public class ParenthesizedExpression : AstNode
    {
        public ParenthesizedExpression(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ParenthesizedExpression(Children.Select(f).ToArray());
        public AstZeroOrMore<Expression> ZeroOrMoreExpression => Children[0] as AstZeroOrMore<Expression>;
    }

    // Original Rule: ((("throw"+!(IdentifierChar))+WS)+Expression)
    // Only Nodes: Expression
    public class ThrowExpression : AstNode
    {
        public ThrowExpression(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ThrowExpression(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ((TypeExpr+Identifier)|Identifier)
    // Only Nodes: ((TypeExpr)?+Identifier)
    public class LambdaParameter : AstSequence
    {
        public LambdaParameter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LambdaParameter(Children.Select(f).ToArray());
        public AstOptional<TypeExpr> TypeExpr => Children[0] as AstOptional<TypeExpr>;
        public Identifier Identifier => Children[1] as Identifier;
    }

    // Original Rule: (LambdaParameter|((("("+WS)+(((LambdaParameter+WS)+(((Comma+LambdaParameter)+WS))*))?)+(")"+WS)))
    // Only Nodes: (LambdaParameter)*
    public class LambdaParameters : AstNode
    {
        public LambdaParameters(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LambdaParameters(Children.Select(f).ToArray());
        public AstZeroOrMore<LambdaParameter> ZeroOrMoreLambdaParameter => Children[0] as AstZeroOrMore<LambdaParameter>;
    }

    // Original Rule: (CompoundStatement|Expression)
    // Only Nodes: (CompoundStatement|Expression)
    public class LambdaBody : AstChoice
    {
        public LambdaBody(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LambdaBody(Children.Select(f).ToArray());
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ((LambdaParameters+("=>"+WS))+LambdaBody)
    // Only Nodes: (LambdaParameters+LambdaBody)
    public class LambdaExpr : AstSequence
    {
        public LambdaExpr(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LambdaExpr(Children.Select(f).ToArray());
        public LambdaParameters LambdaParameters => Children[0] as LambdaParameters;
        public LambdaBody LambdaBody => Children[1] as LambdaBody;
    }

    // Original Rule: (("."+WS)+Identifier)
    // Only Nodes: Identifier
    public class MemberAccess : AstNode
    {
        public MemberAccess(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new MemberAccess(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
    }

    // Original Rule: (("?."+WS)+Identifier)
    // Only Nodes: Identifier
    public class ConditionalMemberAccess : AstNode
    {
        public ConditionalMemberAccess(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConditionalMemberAccess(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
    }

    // Original Rule: ((("typeof"+!(IdentifierChar))+WS)+((("("+WS)+TypeExpr)+(")"+WS)))
    // Only Nodes: TypeExpr
    public class TypeOf : AstNode
    {
        public TypeOf(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeOf(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
    }

    // Original Rule: ((("nameof"+!(IdentifierChar))+WS)+((("("+WS)+Expression)+(")"+WS)))
    // Only Nodes: Expression
    public class NameOf : AstNode
    {
        public NameOf(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new NameOf(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ((("default"+!(IdentifierChar))+WS)+(((("("+WS)+TypeExpr)+(")"+WS)))?)
    // Only Nodes: (TypeExpr)?
    public class Default : AstNode
    {
        public Default(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Default(Children.Select(f).ToArray());
        public AstOptional<TypeExpr> TypeExpr => Children[0] as AstOptional<TypeExpr>;
    }

    // Original Rule: (((Identifier+("="+WS))+Expression)|Expression)
    // Only Nodes: ((Identifier)?+Expression)
    public class InitializerClause : AstSequence
    {
        public InitializerClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new InitializerClause(Children.Select(f).ToArray());
        public AstOptional<Identifier> Identifier => Children[0] as AstOptional<Identifier>;
        public Expression Expression => Children[1] as Expression;
    }

    // Original Rule: ((("{"+WS)+(((InitializerClause+WS)+(((Comma+InitializerClause)+WS))*))?)+("}"+WS))
    // Only Nodes: (InitializerClause)*
    public class Initializer : AstNode
    {
        public Initializer(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Initializer(Children.Select(f).ToArray());
        public AstZeroOrMore<InitializerClause> ZeroOrMoreInitializerClause => Children[0] as AstZeroOrMore<InitializerClause>;
    }

    // Original Rule: ((("["+WS)+Expression)+("]"+WS))
    // Only Nodes: Expression
    public class ArraySizeSpecifier : AstNode
    {
        public ArraySizeSpecifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ArraySizeSpecifier(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: (((((("new"+!(IdentifierChar))+WS)+TypeExpr)+(FunctionArgs)?)+(ArraySizeSpecifier)?)+(Initializer)?)
    // Only Nodes: (TypeExpr+(FunctionArgs)?+(ArraySizeSpecifier)?+(Initializer)?)
    public class NewOperation : AstSequence
    {
        public NewOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new NewOperation(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public AstOptional<FunctionArgs> FunctionArgs => Children[1] as AstOptional<FunctionArgs>;
        public AstOptional<ArraySizeSpecifier> ArraySizeSpecifier => Children[2] as AstOptional<ArraySizeSpecifier>;
        public AstOptional<Initializer> Initializer => Children[3] as AstOptional<Initializer>;
    }

    // Original Rule: (((("is"+!(IdentifierChar))+WS)+TypeExpr)+(Identifier)?)
    // Only Nodes: (TypeExpr+(Identifier)?)
    public class IsOperation : AstSequence
    {
        public IsOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new IsOperation(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public AstOptional<Identifier> Identifier => Children[1] as AstOptional<Identifier>;
    }

    // Original Rule: (((("as"+!(IdentifierChar))+WS)+TypeExpr)+(Identifier)?)
    // Only Nodes: (TypeExpr+(Identifier)?)
    public class AsOperation : AstSequence
    {
        public AsOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new AsOperation(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public AstOptional<Identifier> Identifier => Children[1] as AstOptional<Identifier>;
    }

    // Original Rule: (((("{"+WS)+Expression)+("}"+WS))|StringLiteralChar)
    // Only Nodes: Expression
    public class StringInterpolationContent : AstNode
    {
        public StringInterpolationContent(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new StringInterpolationContent(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: (("$""+(StringInterpolationContent)*)+""")
    // Only Nodes: (StringInterpolationContent)*
    public class StringInterpolation : AstNode
    {
        public StringInterpolation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new StringInterpolation(Children.Select(f).ToArray());
        public AstZeroOrMore<StringInterpolationContent> ZeroOrMoreStringInterpolationContent => Children[0] as AstZeroOrMore<StringInterpolationContent>;
    }

    // Original Rule: ((("params"+!(IdentifierChar))+WS)|(("ref"+!(IdentifierChar))+WS)|(("out"+!(IdentifierChar))+WS)|(("in"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class FunctionArgKeyword : AstNode
    {
        public FunctionArgKeyword(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionArgKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((FunctionArgKeyword)*+Expression)
    // Only Nodes: ((FunctionArgKeyword)*+Expression)
    public class FunctionArg : AstSequence
    {
        public FunctionArg(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionArg(Children.Select(f).ToArray());
        public AstZeroOrMore<FunctionArgKeyword> ZeroOrMoreFunctionArgKeyword => Children[0] as AstZeroOrMore<FunctionArgKeyword>;
        public Expression Expression => Children[1] as Expression;
    }

    // Original Rule: ((("("+WS)+(((FunctionArg+WS)+(((Comma+FunctionArg)+WS))*))?)+(")"+WS))
    // Only Nodes: (FunctionArg)*
    public class FunctionArgs : AstNode
    {
        public FunctionArgs(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionArgs(Children.Select(f).ToArray());
        public AstZeroOrMore<FunctionArg> ZeroOrMoreFunctionArg => Children[0] as AstZeroOrMore<FunctionArg>;
    }

    // Original Rule: (((((((((LambdaExpr|ParenthesizedExpression)|ThrowExpression)|Literal)|TypeOf)|NameOf)|Default)|NewOperation)|StringInterpolation)|Identifier)
    // Only Nodes: (LambdaExpr|ParenthesizedExpression|ThrowExpression|Literal|TypeOf|NameOf|Default|NewOperation|StringInterpolation|Identifier)
    public class LeafExpression : AstChoice
    {
        public LeafExpression(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LeafExpression(Children.Select(f).ToArray());
        public LambdaExpr LambdaExpr => Children[0] as LambdaExpr;
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
        public ThrowExpression ThrowExpression => Children[0] as ThrowExpression;
        public Literal Literal => Children[0] as Literal;
        public TypeOf TypeOf => Children[0] as TypeOf;
        public NameOf NameOf => Children[0] as NameOf;
        public Default Default => Children[0] as Default;
        public NewOperation NewOperation => Children[0] as NewOperation;
        public StringInterpolation StringInterpolation => Children[0] as StringInterpolation;
        public Identifier Identifier => Children[0] as Identifier;
    }

    // Original Rule: (((UnaryOperator)*+LeafExpression)+(PostfixOperator)*)
    // Only Nodes: ((UnaryOperator)*+LeafExpression+(PostfixOperator)*)
    public class Expression : AstSequence
    {
        public Expression(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Expression(Children.Select(f).ToArray());
        public AstZeroOrMore<UnaryOperator> ZeroOrMoreUnaryOperator => Children[0] as AstZeroOrMore<UnaryOperator>;
        public LeafExpression LeafExpression => Children[1] as LeafExpression;
        public AstZeroOrMore<PostfixOperator> ZeroOrMorePostfixOperator => Children[2] as AstZeroOrMore<PostfixOperator>;
    }

    // Original Rule: (Expression+EOS)
    // Only Nodes: Expression
    public class ExpressionStatement : AstNode
    {
        public ExpressionStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ExpressionStatement(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ((("else"+!(IdentifierChar))+WS)+Statement)
    // Only Nodes: Statement
    public class ElseClause : AstNode
    {
        public ElseClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ElseClause(Children.Select(f).ToArray());
        public Statement Statement => Children[0] as Statement;
    }

    // Original Rule: ((((("if"+!(IdentifierChar))+WS)+ParenthesizedExpression)+Statement)+(ElseClause)?)
    // Only Nodes: (ParenthesizedExpression+Statement+(ElseClause)?)
    public class IfStatement : AstSequence
    {
        public IfStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new IfStatement(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
        public Statement Statement => Children[1] as Statement;
        public AstOptional<ElseClause> ElseClause => Children[2] as AstOptional<ElseClause>;
    }

    // Original Rule: (((("while"+!(IdentifierChar))+WS)+ParenthesizedExpression)+Statement)
    // Only Nodes: (ParenthesizedExpression+Statement)
    public class WhileStatement : AstSequence
    {
        public WhileStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new WhileStatement(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
        public Statement Statement => Children[1] as Statement;
    }

    // Original Rule: (((((("do"+!(IdentifierChar))+WS)+Statement)+(("while"+!(IdentifierChar))+WS))+ParenthesizedExpression)+EOS)
    // Only Nodes: (Statement+ParenthesizedExpression)
    public class DoWhileStatement : AstSequence
    {
        public DoWhileStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new DoWhileStatement(Children.Select(f).ToArray());
        public Statement Statement => Children[0] as Statement;
        public ParenthesizedExpression ParenthesizedExpression => Children[1] as ParenthesizedExpression;
    }

    // Original Rule: (((("return"+!(IdentifierChar))+WS)+(Expression)?)+EOS)
    // Only Nodes: (Expression)?
    public class ReturnStatement : AstNode
    {
        public ReturnStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ReturnStatement(Children.Select(f).ToArray());
        public AstOptional<Expression> Expression => Children[0] as AstOptional<Expression>;
    }

    // Original Rule: ((("break"+!(IdentifierChar))+WS)+EOS)
    // Only Nodes: 
    public class BreakStatement : AstNode
    {
        public BreakStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BreakStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((((("yield"+!(IdentifierChar))+WS)+(("return"+!(IdentifierChar))+WS))+Expression)+EOS)
    // Only Nodes: Expression
    public class YieldStatement : AstNode
    {
        public YieldStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new YieldStatement(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: (((("yield"+!(IdentifierChar))+WS)+(("break"+!(IdentifierChar))+WS))+EOS)
    // Only Nodes: 
    public class YieldBreakStatement : AstNode
    {
        public YieldBreakStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new YieldBreakStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("continue"+!(IdentifierChar))+WS)+EOS)
    // Only Nodes: 
    public class ContinueStatement : AstNode
    {
        public ContinueStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ContinueStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("{"+WS)+(Statement)*)+("}"+WS))
    // Only Nodes: (Statement)*
    public class CompoundStatement : AstNode
    {
        public CompoundStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new CompoundStatement(Children.Select(f).ToArray());
        public AstZeroOrMore<Statement> ZeroOrMoreStatement => Children[0] as AstZeroOrMore<Statement>;
    }

    // Original Rule: (((("catch"+!(IdentifierChar))+WS)+((("("+WS)+VarDecl)+(")"+WS)))+CompoundStatement)
    // Only Nodes: (VarDecl+CompoundStatement)
    public class CatchClause : AstSequence
    {
        public CatchClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new CatchClause(Children.Select(f).ToArray());
        public VarDecl VarDecl => Children[0] as VarDecl;
        public CompoundStatement CompoundStatement => Children[1] as CompoundStatement;
    }

    // Original Rule: ((("finally"+!(IdentifierChar))+WS)+CompoundStatement)
    // Only Nodes: CompoundStatement
    public class FinallyClause : AstNode
    {
        public FinallyClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FinallyClause(Children.Select(f).ToArray());
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
    }

    // Original Rule: (((("default"+!(IdentifierChar))+WS)|((("case"+!(IdentifierChar))+WS)+Expression))+Statement)
    // Only Nodes: (Expression+Statement)
    public class CaseClause : AstSequence
    {
        public CaseClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new CaseClause(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
        public Statement Statement => Children[1] as Statement;
    }

    // Original Rule: ((("switch"+!(IdentifierChar))+WS)+((("{"+WS)+(CaseClause)*)+("}"+WS)))
    // Only Nodes: (CaseClause)*
    public class SwitchStatement : AstNode
    {
        public SwitchStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new SwitchStatement(Children.Select(f).ToArray());
        public AstZeroOrMore<CaseClause> ZeroOrMoreCaseClause => Children[0] as AstZeroOrMore<CaseClause>;
    }

    // Original Rule: ((((("try"+!(IdentifierChar))+WS)+CompoundStatement)+(CatchClause)?)+(FinallyClause)?)
    // Only Nodes: (CompoundStatement+(CatchClause)?+(FinallyClause)?)
    public class TryStatement : AstSequence
    {
        public TryStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TryStatement(Children.Select(f).ToArray());
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
        public AstOptional<CatchClause> CatchClause => Children[1] as AstOptional<CatchClause>;
        public AstOptional<FinallyClause> FinallyClause => Children[2] as AstOptional<FinallyClause>;
    }

    // Original Rule: (((((((("foreach"+!(IdentifierChar))+WS)+("("+WS))+VarDecl)+(("in"+!(IdentifierChar))+WS))+Expression)+(")"+WS))+Statement)
    // Only Nodes: (VarDecl+Expression+Statement)
    public class ForEachStatement : AstSequence
    {
        public ForEachStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ForEachStatement(Children.Select(f).ToArray());
        public VarDecl VarDecl => Children[0] as VarDecl;
        public Expression Expression => Children[1] as Expression;
        public Statement Statement => Children[2] as Statement;
    }

    // Original Rule: ((VarDecl+Initialization))?
    // Only Nodes: ((VarDecl+Initialization))?
    public class InitializationClause : AstNode
    {
        public InitializationClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new InitializationClause(Children.Select(f).ToArray());
        public AstOptional<AstNode> Sequence => Children[0] as AstOptional<AstNode>;
    }

    // Original Rule: (Expression)?
    // Only Nodes: (Expression)?
    public class InvariantClause : AstNode
    {
        public InvariantClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new InvariantClause(Children.Select(f).ToArray());
        public AstOptional<Expression> Expression => Children[0] as AstOptional<Expression>;
    }

    // Original Rule: (Expression)?
    // Only Nodes: (Expression)?
    public class VariantClause : AstNode
    {
        public VariantClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new VariantClause(Children.Select(f).ToArray());
        public AstOptional<Expression> Expression => Children[0] as AstOptional<Expression>;
    }

    // Original Rule: (((((((((("for"+!(IdentifierChar))+WS)+("("+WS))+InitializationClause)+EOS)+InvariantClause)+EOS)+VariantClause)+(")"+WS))+Statement)
    // Only Nodes: (InitializationClause+InvariantClause+VariantClause+Statement)
    public class ForStatement : AstSequence
    {
        public ForStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ForStatement(Children.Select(f).ToArray());
        public InitializationClause InitializationClause => Children[0] as InitializationClause;
        public InvariantClause InvariantClause => Children[1] as InvariantClause;
        public VariantClause VariantClause => Children[2] as VariantClause;
        public Statement Statement => Children[3] as Statement;
    }

    // Original Rule: ((("="+WS)+Expression))?
    // Only Nodes: (Expression)?
    public class Initialization : AstNode
    {
        public Initialization(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Initialization(Children.Select(f).ToArray());
        public AstOptional<Expression> Expression => Children[0] as AstOptional<Expression>;
    }

    // Original Rule: (TypeExpr+Identifier)
    // Only Nodes: (TypeExpr+Identifier)
    public class VarDecl : AstSequence
    {
        public VarDecl(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new VarDecl(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
    }

    // Original Rule: ((VarDecl+Initialization)+EOS)
    // Only Nodes: (VarDecl+Initialization)
    public class VarDeclStatement : AstSequence
    {
        public VarDeclStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new VarDeclStatement(Children.Select(f).ToArray());
        public VarDecl VarDecl => Children[0] as VarDecl;
        public Initialization Initialization => Children[1] as Initialization;
    }

    // Original Rule: ((((("throw"+!(IdentifierChar))+WS)+CompoundStatement)+(CatchClause)?)+(FinallyClause)?)
    // Only Nodes: (CompoundStatement+(CatchClause)?+(FinallyClause)?)
    public class ThrowStatement : AstSequence
    {
        public ThrowStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ThrowStatement(Children.Select(f).ToArray());
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
        public AstOptional<CatchClause> CatchClause => Children[1] as AstOptional<CatchClause>;
        public AstOptional<FinallyClause> FinallyClause => Children[2] as AstOptional<FinallyClause>;
    }

    // Original Rule: (((((((((((((EOS|CompoundStatement)|IfStatement)|WhileStatement)|DoWhileStatement)|ReturnStatement)|BreakStatement)|ContinueStatement)|ForStatement)|ForEachStatement)|ThrowStatement)|VarDeclStatement)|TryStatement)|ExpressionStatement)
    // Only Nodes: (CompoundStatement|IfStatement|WhileStatement|DoWhileStatement|ReturnStatement|BreakStatement|ContinueStatement|ForStatement|ForEachStatement|ThrowStatement|VarDeclStatement|TryStatement|ExpressionStatement)
    public class Statement : AstChoice
    {
        public Statement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Statement(Children.Select(f).ToArray());
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
        public IfStatement IfStatement => Children[0] as IfStatement;
        public WhileStatement WhileStatement => Children[0] as WhileStatement;
        public DoWhileStatement DoWhileStatement => Children[0] as DoWhileStatement;
        public ReturnStatement ReturnStatement => Children[0] as ReturnStatement;
        public BreakStatement BreakStatement => Children[0] as BreakStatement;
        public ContinueStatement ContinueStatement => Children[0] as ContinueStatement;
        public ForStatement ForStatement => Children[0] as ForStatement;
        public ForEachStatement ForEachStatement => Children[0] as ForEachStatement;
        public ThrowStatement ThrowStatement => Children[0] as ThrowStatement;
        public VarDeclStatement VarDeclStatement => Children[0] as VarDeclStatement;
        public TryStatement TryStatement => Children[0] as TryStatement;
        public ExpressionStatement ExpressionStatement => Children[0] as ExpressionStatement;
    }

    // Original Rule: (((Identifier+WS)+(((("."+WS)+Identifier)+WS))*))?
    // Only Nodes: (Identifier)*
    public class QualifiedIdentifier : AstNode
    {
        public QualifiedIdentifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new QualifiedIdentifier(Children.Select(f).ToArray());
        public AstZeroOrMore<Identifier> ZeroOrMoreIdentifier => Children[0] as AstZeroOrMore<Identifier>;
    }

    // Original Rule: ((("static"+!(IdentifierChar))+WS))?
    // Only Nodes: 
    public class Static : AstNode
    {
        public Static(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Static(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((((("using"+!(IdentifierChar))+WS)+Static)+QualifiedIdentifier)+EOS)
    // Only Nodes: (Static+QualifiedIdentifier)
    public class UsingDirective : AstSequence
    {
        public UsingDirective(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new UsingDirective(Children.Select(f).ToArray());
        public Static Static => Children[0] as Static;
        public QualifiedIdentifier QualifiedIdentifier => Children[1] as QualifiedIdentifier;
    }

    // Original Rule: ((("readonly"+!(IdentifierChar))+WS)|(("abstract"+!(IdentifierChar))+WS)|(("partial"+!(IdentifierChar))+WS)|(("virtual"+!(IdentifierChar))+WS)|(("static"+!(IdentifierChar))+WS)|(("sealed"+!(IdentifierChar))+WS)|(("const"+!(IdentifierChar))+WS)|(("ref"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class Modifier : AstNode
    {
        public Modifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Modifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("protected"+!(IdentifierChar))+WS)|(("internal"+!(IdentifierChar))+WS)|(("private"+!(IdentifierChar))+WS)|(("public"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class AccessSpecifier : AstNode
    {
        public AccessSpecifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new AccessSpecifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("["+WS)+((((Identifier+(FunctionArgs)?)+WS)+(((Comma+(Identifier+(FunctionArgs)?))+WS))*))?)+("]"+WS))
    // Only Nodes: ((Identifier+(FunctionArgs)?+((Identifier+(FunctionArgs)?))*))?
    public class Attribute : AstNode
    {
        public Attribute(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Attribute(Children.Select(f).ToArray());
        public AstOptional<AstNode> Sequence => Children[0] as AstOptional<AstNode>;
    }

    // Original Rule: (Attribute)*
    // Only Nodes: (Attribute)*
    public class AttributeList : AstNode
    {
        public AttributeList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new AttributeList(Children.Select(f).ToArray());
        public AstZeroOrMore<Attribute> ZeroOrMoreAttribute => Children[0] as AstZeroOrMore<Attribute>;
    }

    // Original Rule: (AttributeList+((Modifier|AccessSpecifier))*)
    // Only Nodes: (AttributeList+((Modifier|AccessSpecifier))*)
    public class DeclarationPreamble : AstSequence
    {
        public DeclarationPreamble(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new DeclarationPreamble(Children.Select(f).ToArray());
        public AttributeList AttributeList => Children[0] as AttributeList;
        public AstZeroOrMore<AstNode> ZeroOrMoreChoice => Children[1] as AstZeroOrMore<AstNode>;
    }

    // Original Rule: (((("out"+!(IdentifierChar))+WS)|(("in"+!(IdentifierChar))+WS)))?
    // Only Nodes: 
    public class TypeVariance : AstNode
    {
        public TypeVariance(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeVariance(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (TypeVariance+Identifier)
    // Only Nodes: (TypeVariance+Identifier)
    public class TypeParameter : AstSequence
    {
        public TypeParameter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeParameter(Children.Select(f).ToArray());
        public TypeVariance TypeVariance => Children[0] as TypeVariance;
        public Identifier Identifier => Children[1] as Identifier;
    }

    // Original Rule: (((("<"+WS)+(((TypeParameter+WS)+(((Comma+TypeParameter)+WS))*))?)+(">"+WS)))?
    // Only Nodes: (TypeParameter)*
    public class TypeParameterList : AstNode
    {
        public TypeParameterList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeParameterList(Children.Select(f).ToArray());
        public AstZeroOrMore<TypeParameter> ZeroOrMoreTypeParameter => Children[0] as AstZeroOrMore<TypeParameter>;
    }

    // Original Rule: (((":"+WS)+(((TypeExpr+WS)+(((Comma+TypeExpr)+WS))*))?))?
    // Only Nodes: (TypeExpr)*
    public class BaseClassList : AstNode
    {
        public BaseClassList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BaseClassList(Children.Select(f).ToArray());
        public AstZeroOrMore<TypeExpr> ZeroOrMoreTypeExpr => Children[0] as AstZeroOrMore<TypeExpr>;
    }

    // Original Rule: (((("class"+!(IdentifierChar))+WS)|(("struct"+!(IdentifierChar))+WS))|TypeExpr)
    // Only Nodes: TypeExpr
    public class Constraint : AstNode
    {
        public Constraint(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Constraint(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
    }

    // Original Rule: ((((("where"+!(IdentifierChar))+WS)+Identifier)+(":"+WS))+TypeExpr)
    // Only Nodes: (Identifier+TypeExpr)
    public class ConstraintClause : AstSequence
    {
        public ConstraintClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConstraintClause(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
        public TypeExpr TypeExpr => Children[1] as TypeExpr;
    }

    // Original Rule: (ConstraintClause)*
    // Only Nodes: (ConstraintClause)*
    public class ConstraintList : AstNode
    {
        public ConstraintList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConstraintList(Children.Select(f).ToArray());
        public AstZeroOrMore<ConstraintClause> ZeroOrMoreConstraintClause => Children[0] as AstZeroOrMore<ConstraintClause>;
    }

    // Original Rule: ((("interface"+!(IdentifierChar))+WS)|(("struct"+!(IdentifierChar))+WS)|(("class"+!(IdentifierChar))+WS)|(("enum"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class Kind : AstNode
    {
        public Kind(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Kind(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (((((Kind+Identifier)+TypeParameterList)+BaseClassList)+ConstraintList)+((("{"+WS)+(MemberDeclaration)*)+("}"+WS)))
    // Only Nodes: (Kind+Identifier+TypeParameterList+BaseClassList+ConstraintList+(MemberDeclaration)*)
    public class TypeDeclaration : AstSequence
    {
        public TypeDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeDeclaration(Children.Select(f).ToArray());
        public Kind Kind => Children[0] as Kind;
        public Identifier Identifier => Children[1] as Identifier;
        public TypeParameterList TypeParameterList => Children[2] as TypeParameterList;
        public BaseClassList BaseClassList => Children[3] as BaseClassList;
        public ConstraintList ConstraintList => Children[4] as ConstraintList;
        public AstZeroOrMore<MemberDeclaration> ZeroOrMoreMemberDeclaration => Children[5] as AstZeroOrMore<MemberDeclaration>;
    }

    // Original Rule: (DeclarationPreamble+TypeDeclaration)
    // Only Nodes: (DeclarationPreamble+TypeDeclaration)
    public class TypeDeclarationWithPreamble : AstSequence
    {
        public TypeDeclarationWithPreamble(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeDeclarationWithPreamble(Children.Select(f).ToArray());
        public DeclarationPreamble DeclarationPreamble => Children[0] as DeclarationPreamble;
        public TypeDeclaration TypeDeclaration => Children[1] as TypeDeclaration;
    }

    // Original Rule: (((("params"+!(IdentifierChar))+WS)|(("ref"+!(IdentifierChar))+WS)|(("out"+!(IdentifierChar))+WS)|(("in"+!(IdentifierChar))+WS)))?
    // Only Nodes: 
    public class FunctionParameterKeywords : AstNode
    {
        public FunctionParameterKeywords(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionParameterKeywords(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("="+WS)+Expression))?
    // Only Nodes: (Expression)?
    public class DefaultValue : AstNode
    {
        public DefaultValue(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new DefaultValue(Children.Select(f).ToArray());
        public AstOptional<Expression> Expression => Children[0] as AstOptional<Expression>;
    }

    // Original Rule: ((((AttributeList+FunctionParameterKeywords)+TypeExpr)+Identifier)+DefaultValue)
    // Only Nodes: (AttributeList+FunctionParameterKeywords+TypeExpr+Identifier+DefaultValue)
    public class FunctionParameter : AstSequence
    {
        public FunctionParameter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionParameter(Children.Select(f).ToArray());
        public AttributeList AttributeList => Children[0] as AttributeList;
        public FunctionParameterKeywords FunctionParameterKeywords => Children[1] as FunctionParameterKeywords;
        public TypeExpr TypeExpr => Children[2] as TypeExpr;
        public Identifier Identifier => Children[3] as Identifier;
        public DefaultValue DefaultValue => Children[4] as DefaultValue;
    }

    // Original Rule: ((("("+WS)+(((FunctionParameter+WS)+(((Comma+FunctionParameter)+WS))*))?)+(")"+WS))
    // Only Nodes: (FunctionParameter)*
    public class FunctionParameterList : AstNode
    {
        public FunctionParameterList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionParameterList(Children.Select(f).ToArray());
        public AstZeroOrMore<FunctionParameter> ZeroOrMoreFunctionParameter => Children[0] as AstZeroOrMore<FunctionParameter>;
    }

    // Original Rule: (("=>"+WS)+Expression)
    // Only Nodes: Expression
    public class ExpressionBody : AstNode
    {
        public ExpressionBody(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ExpressionBody(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: (ExpressionBody|CompoundStatement)
    // Only Nodes: (ExpressionBody|CompoundStatement)
    public class FunctionBody : AstChoice
    {
        public FunctionBody(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionBody(Children.Select(f).ToArray());
        public ExpressionBody ExpressionBody => Children[0] as ExpressionBody;
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
    }

    // Original Rule: ((("base"+!(IdentifierChar))+WS)+ParenthesizedExpression)
    // Only Nodes: ParenthesizedExpression
    public class BaseCall : AstNode
    {
        public BaseCall(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BaseCall(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
    }

    // Original Rule: ((("this"+!(IdentifierChar))+WS)+ParenthesizedExpression)
    // Only Nodes: ParenthesizedExpression
    public class ThisCall : AstNode
    {
        public ThisCall(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ThisCall(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
    }

    // Original Rule: (((":"+WS)+(BaseCall|ThisCall)))?
    // Only Nodes: ((BaseCall|ThisCall))?
    public class BaseOrThisCall : AstNode
    {
        public BaseOrThisCall(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BaseOrThisCall(Children.Select(f).ToArray());
        public AstOptional<AstNode> Choice => Children[0] as AstOptional<AstNode>;
    }

    // Original Rule: (((Identifier+FunctionParameterList)+BaseOrThisCall)+FunctionBody)
    // Only Nodes: (Identifier+FunctionParameterList+BaseOrThisCall+FunctionBody)
    public class ConstructorDeclaration : AstSequence
    {
        public ConstructorDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConstructorDeclaration(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
        public FunctionParameterList FunctionParameterList => Children[1] as FunctionParameterList;
        public BaseOrThisCall BaseOrThisCall => Children[2] as BaseOrThisCall;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: (((TypeExpr+Identifier)+FunctionParameterList)+FunctionBody)
    // Only Nodes: (TypeExpr+Identifier+FunctionParameterList+FunctionBody)
    public class MethodDeclaration : AstSequence
    {
        public MethodDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new MethodDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
        public FunctionParameterList FunctionParameterList => Children[2] as FunctionParameterList;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: ((TypeExpr+Identifier)+Initialization)
    // Only Nodes: (TypeExpr+Identifier+Initialization)
    public class FieldDeclaration : AstSequence
    {
        public FieldDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FieldDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
        public Initialization Initialization => Children[2] as Initialization;
    }

    // Original Rule: ((("get"+!(IdentifierChar))+WS)+FunctionBody)
    // Only Nodes: FunctionBody
    public class Getter : AstNode
    {
        public Getter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Getter(Children.Select(f).ToArray());
        public FunctionBody FunctionBody => Children[0] as FunctionBody;
    }

    // Original Rule: ((("set"+!(IdentifierChar))+WS)+FunctionBody)
    // Only Nodes: FunctionBody
    public class Setter : AstNode
    {
        public Setter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Setter(Children.Select(f).ToArray());
        public FunctionBody FunctionBody => Children[0] as FunctionBody;
    }

    // Original Rule: ((("init"+!(IdentifierChar))+WS)+FunctionBody)
    // Only Nodes: FunctionBody
    public class Initter : AstNode
    {
        public Initter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Initter(Children.Select(f).ToArray());
        public FunctionBody FunctionBody => Children[0] as FunctionBody;
    }

    // Original Rule: (((Getter|Setter)|Initter))*
    // Only Nodes: ((Getter|Setter|Initter))*
    public class PropertyClauses : AstNode
    {
        public PropertyClauses(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new PropertyClauses(Children.Select(f).ToArray());
        public AstZeroOrMore<AstNode> ZeroOrMoreChoice => Children[0] as AstZeroOrMore<AstNode>;
    }

    // Original Rule: (ExpressionBody|((("{"+WS)+PropertyClauses)+("}"+WS)))
    // Only Nodes: (ExpressionBody|PropertyClauses)
    public class PropertyBody : AstChoice
    {
        public PropertyBody(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new PropertyBody(Children.Select(f).ToArray());
        public ExpressionBody ExpressionBody => Children[0] as ExpressionBody;
        public PropertyClauses PropertyClauses => Children[0] as PropertyClauses;
    }

    // Original Rule: ((TypeExpr+Identifier)+PropertyBody)
    // Only Nodes: (TypeExpr+Identifier+PropertyBody)
    public class PropertyDeclaration : AstSequence
    {
        public PropertyDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new PropertyDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
        public PropertyBody PropertyBody => Children[2] as PropertyBody;
    }

    // Original Rule: (((TypeExpr+(("this"+!(IdentifierChar))+WS))+((("["+WS)+FunctionParameter)+("]"+WS)))+PropertyBody)
    // Only Nodes: (TypeExpr+FunctionParameter+PropertyBody)
    public class IndexerDeclaration : AstSequence
    {
        public IndexerDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new IndexerDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public FunctionParameter FunctionParameter => Children[1] as FunctionParameter;
        public PropertyBody PropertyBody => Children[2] as PropertyBody;
    }

    // Original Rule: ((((TypeExpr+(("operator"+!(IdentifierChar))+WS))+OverloadableOperator)+FunctionParameterList)+FunctionBody)
    // Only Nodes: (TypeExpr+OverloadableOperator+FunctionParameterList+FunctionBody)
    public class OperatorDeclaration : AstSequence
    {
        public OperatorDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new OperatorDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public OverloadableOperator OverloadableOperator => Children[1] as OverloadableOperator;
        public FunctionParameterList FunctionParameterList => Children[2] as FunctionParameterList;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: ((("implicit"+!(IdentifierChar))+WS)|(("explicit"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class ImplicitOrExplicit : AstNode
    {
        public ImplicitOrExplicit(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ImplicitOrExplicit(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((((TypeExpr+ImplicitOrExplicit)+(("operator"+!(IdentifierChar))+WS))+TypeExpr)+FunctionBody)
    // Only Nodes: (TypeExpr+ImplicitOrExplicit+TypeExpr+FunctionBody)
    public class ConverterDeclaration : AstSequence
    {
        public ConverterDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConverterDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public ImplicitOrExplicit ImplicitOrExplicit => Children[1] as ImplicitOrExplicit;
        public TypeExpr TypeExpr_1 => Children[2] as TypeExpr;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: ((((((((DeclarationPreamble+ConstructorDeclaration)|MethodDeclaration)|FieldDeclaration)|OperatorDeclaration)|ConverterDeclaration)|TypeDeclaration)|IndexerDeclaration)|PropertyDeclaration)
    // Only Nodes: ((DeclarationPreamble+ConstructorDeclaration)|MethodDeclaration|FieldDeclaration|OperatorDeclaration|ConverterDeclaration|TypeDeclaration|IndexerDeclaration|PropertyDeclaration)
    public class MemberDeclaration : AstChoice
    {
        public MemberDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new MemberDeclaration(Children.Select(f).ToArray());
        public AstSequence Sequence => Children[0] as AstSequence;
        public MethodDeclaration MethodDeclaration => Children[0] as MethodDeclaration;
        public FieldDeclaration FieldDeclaration => Children[0] as FieldDeclaration;
        public OperatorDeclaration OperatorDeclaration => Children[0] as OperatorDeclaration;
        public ConverterDeclaration ConverterDeclaration => Children[0] as ConverterDeclaration;
        public TypeDeclaration TypeDeclaration => Children[0] as TypeDeclaration;
        public IndexerDeclaration IndexerDeclaration => Children[0] as IndexerDeclaration;
        public PropertyDeclaration PropertyDeclaration => Children[0] as PropertyDeclaration;
    }

    // Original Rule: (((("namespace"+!(IdentifierChar))+WS)+QualifiedIdentifier)+((("{"+WS)+(TopDeclaration)*)+("}"+WS)))
    // Only Nodes: (QualifiedIdentifier+(TopDeclaration)*)
    public class NamespaceDeclaration : AstSequence
    {
        public NamespaceDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new NamespaceDeclaration(Children.Select(f).ToArray());
        public QualifiedIdentifier QualifiedIdentifier => Children[0] as QualifiedIdentifier;
        public AstZeroOrMore<TopDeclaration> ZeroOrMoreTopDeclaration => Children[1] as AstZeroOrMore<TopDeclaration>;
    }

    // Original Rule: (((("namespace"+!(IdentifierChar))+WS)+QualifiedIdentifier)+EOS)
    // Only Nodes: QualifiedIdentifier
    public class FileScopedNamespace : AstNode
    {
        public FileScopedNamespace(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FileScopedNamespace(Children.Select(f).ToArray());
        public QualifiedIdentifier QualifiedIdentifier => Children[0] as QualifiedIdentifier;
    }

    // Original Rule: (NamespaceDeclaration|TypeDeclarationWithPreamble)
    // Only Nodes: (NamespaceDeclaration|TypeDeclarationWithPreamble)
    public class TopDeclaration : AstChoice
    {
        public TopDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TopDeclaration(Children.Select(f).ToArray());
        public NamespaceDeclaration NamespaceDeclaration => Children[0] as NamespaceDeclaration;
        public TypeDeclarationWithPreamble TypeDeclarationWithPreamble => Children[0] as TypeDeclarationWithPreamble;
    }

    // Original Rule: (((UsingDirective)*+(FileScopedNamespace)?)+(TopDeclaration)*)
    // Only Nodes: ((UsingDirective)*+(FileScopedNamespace)?+(TopDeclaration)*)
    public class File : AstSequence
    {
        public File(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new File(Children.Select(f).ToArray());
        public AstZeroOrMore<UsingDirective> ZeroOrMoreUsingDirective => Children[0] as AstZeroOrMore<UsingDirective>;
        public AstOptional<FileScopedNamespace> FileScopedNamespace => Children[1] as AstOptional<FileScopedNamespace>;
        public AstZeroOrMore<TopDeclaration> ZeroOrMoreTopDeclaration => Children[2] as AstZeroOrMore<TopDeclaration>;
    }

    // Original Rule: ((("["+WS)+(Comma)*)+("]"+WS))
    // Only Nodes: 
    public class ArrayRankSpecifier : AstNode
    {
        public ArrayRankSpecifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ArrayRankSpecifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (ArrayRankSpecifier)*
    // Only Nodes: (ArrayRankSpecifier)*
    public class ArrayRankSpecifiers : AstNode
    {
        public ArrayRankSpecifiers(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ArrayRankSpecifiers(Children.Select(f).ToArray());
        public AstZeroOrMore<ArrayRankSpecifier> ZeroOrMoreArrayRankSpecifier => Children[0] as AstZeroOrMore<ArrayRankSpecifier>;
    }

    // Original Rule: ((("<"+WS)+(((TypeExpr+WS)+(((Comma+TypeExpr)+WS))*))?)+(">"+WS))
    // Only Nodes: (TypeExpr)*
    public class TypeArgList : AstNode
    {
        public TypeArgList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeArgList(Children.Select(f).ToArray());
        public AstZeroOrMore<TypeExpr> ZeroOrMoreTypeExpr => Children[0] as AstZeroOrMore<TypeExpr>;
    }

    // Original Rule: (("?"+WS))?
    // Only Nodes: 
    public class Nullable : AstNode
    {
        public Nullable(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Nullable(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((QualifiedIdentifier+(TypeArgList)?)+ArrayRankSpecifiers)
    // Only Nodes: (QualifiedIdentifier+(TypeArgList)?+ArrayRankSpecifiers)
    public class TypeExpr : AstSequence
    {
        public TypeExpr(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeExpr(Children.Select(f).ToArray());
        public QualifiedIdentifier QualifiedIdentifier => Children[0] as QualifiedIdentifier;
        public AstOptional<TypeArgList> TypeArgList => Children[1] as AstOptional<TypeArgList>;
        public ArrayRankSpecifiers ArrayRankSpecifiers => Children[2] as ArrayRankSpecifiers;
    }

    // Original Rule: (([;,.]|TypeKeyword)|StatementKeyword)
    // Only Nodes: (TypeKeyword|StatementKeyword)
    public class Separator : AstChoice
    {
        public Separator(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Separator(Children.Select(f).ToArray());
        public TypeKeyword TypeKeyword => Children[0] as TypeKeyword;
        public StatementKeyword StatementKeyword => Children[0] as StatementKeyword;
    }

    // Original Rule: ("class"|"struct"|"interface"|"enum"|"namespace")
    // Only Nodes: 
    public class TypeKeyword : AstNode
    {
        public TypeKeyword(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("for"|"if"|"return"|"break"|"continue"|"do"|"foreach"|"throw"|"switch"|"try"|"catch"|"finally"|"using"|"case"|"default")
    // Only Nodes: 
    public class StatementKeyword : AstNode
    {
        public StatementKeyword(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new StatementKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (((((Comment|Spaces)|AnyChar)|([!%^&|*?+-=/><]+([!%^&|*?+-=/><])*))|Identifier)|Literal)
    // Only Nodes: (Identifier|Literal)
    public class Token : AstChoice
    {
        public Token(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Token(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
        public Literal Literal => Children[0] as Literal;
    }

    // Original Rule: (((!(([[]{}()]|Separator))+Token)+((!(([[]{}()]|Separator))+Token))*)+(Separator)?)
    // Only Nodes: (Token+(Token)*+(Separator)?)
    public class TokenGroup : AstSequence
    {
        public TokenGroup(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TokenGroup(Children.Select(f).ToArray());
        public Token Token => Children[0] as Token;
        public AstZeroOrMore<Token> ZeroOrMoreToken => Children[1] as AstZeroOrMore<Token>;
        public AstOptional<Separator> Separator => Children[2] as AstOptional<Separator>;
    }

    // Original Rule: ((TypeKeyword+TokenGroup)+BracedStructure)
    // Only Nodes: (TypeKeyword+TokenGroup+BracedStructure)
    public class TypeStructure : AstSequence
    {
        public TypeStructure(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeStructure(Children.Select(f).ToArray());
        public TypeKeyword TypeKeyword => Children[0] as TypeKeyword;
        public TokenGroup TokenGroup => Children[1] as TokenGroup;
        public BracedStructure BracedStructure => Children[2] as BracedStructure;
    }

    // Original Rule: ((StatementKeyword+TokenGroup)+(BracedStructure)?)
    // Only Nodes: (StatementKeyword+TokenGroup+(BracedStructure)?)
    public class StatementStructure : AstSequence
    {
        public StatementStructure(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new StatementStructure(Children.Select(f).ToArray());
        public StatementKeyword StatementKeyword => Children[0] as StatementKeyword;
        public TokenGroup TokenGroup => Children[1] as TokenGroup;
        public AstOptional<BracedStructure> BracedStructure => Children[2] as AstOptional<BracedStructure>;
    }

    // Original Rule: (Structure|TokenGroup)
    // Only Nodes: (Structure|TokenGroup)
    public class Element : AstChoice
    {
        public Element(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Element(Children.Select(f).ToArray());
        public Structure Structure => Children[0] as Structure;
        public TokenGroup TokenGroup => Children[0] as TokenGroup;
    }

    // Original Rule: (("{"+(Element)*)+"}")
    // Only Nodes: (Element)*
    public class BracedStructure : AstNode
    {
        public BracedStructure(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BracedStructure(Children.Select(f).ToArray());
        public AstZeroOrMore<Element> ZeroOrMoreElement => Children[0] as AstZeroOrMore<Element>;
    }

    // Original Rule: (("["+(Element)*)+"]")
    // Only Nodes: (Element)*
    public class BracketedStructure : AstNode
    {
        public BracketedStructure(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BracketedStructure(Children.Select(f).ToArray());
        public AstZeroOrMore<Element> ZeroOrMoreElement => Children[0] as AstZeroOrMore<Element>;
    }

    // Original Rule: (("("+(Element)*)+")")
    // Only Nodes: (Element)*
    public class ParenthesizedStructure : AstNode
    {
        public ParenthesizedStructure(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ParenthesizedStructure(Children.Select(f).ToArray());
        public AstZeroOrMore<Element> ZeroOrMoreElement => Children[0] as AstZeroOrMore<Element>;
    }

    // Original Rule: ((BracketedStructure|ParenthesizedStructure)|BracedStructure)
    // Only Nodes: (BracketedStructure|ParenthesizedStructure|BracedStructure)
    public class Structure : AstChoice
    {
        public Structure(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Structure(Children.Select(f).ToArray());
        public BracketedStructure BracketedStructure => Children[0] as BracketedStructure;
        public ParenthesizedStructure ParenthesizedStructure => Children[0] as ParenthesizedStructure;
        public BracedStructure BracedStructure => Children[0] as BracedStructure;
    }

    // Original Rule: (Element)*
    // Only Nodes: (Element)*
    public class FileStructure : AstNode
    {
        public FileStructure(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FileStructure(Children.Select(f).ToArray());
        public AstZeroOrMore<Element> ZeroOrMoreElement => Children[0] as AstZeroOrMore<Element>;
    }

    public static class AstNodeHelpers
    {
        public static AstNode ToNode(this ParseTree node)
        {
            switch (node.Type)
            {
                case "FloatLiteral": return new FloatLiteral(node.Contents);
                case "HexLiteral": return new HexLiteral(node.Contents);
                case "BinaryLiteral": return new BinaryLiteral(node.Contents);
                case "IntegerLiteral": return new IntegerLiteral(node.Contents);
                case "StringLiteral": return new StringLiteral(node.Contents);
                case "CharLiteral": return new CharLiteral(node.Contents);
                case "BooleanLiteral": return new BooleanLiteral(node.Contents);
                case "NullLiteral": return new NullLiteral(node.Contents);
                case "ValueLiteral": return new ValueLiteral(node.Contents);
                case "Literal": return new Literal(node.Children.Select(ToNode).ToArray());
                case "BinaryOperator": return new BinaryOperator(node.Contents);
                case "UnaryOperator": return new UnaryOperator(node.Contents);
                case "Indexer": return new Indexer(node.Children.Select(ToNode).ToArray());
                case "OverloadableOperator": return new OverloadableOperator(node.Contents);
                case "PostfixOperator": return new PostfixOperator(node.Children.Select(ToNode).ToArray());
                case "Identifier": return new Identifier(node.Contents);
                case "BinaryOperation": return new BinaryOperation(node.Children.Select(ToNode).ToArray());
                case "TernaryOperation": return new TernaryOperation(node.Children.Select(ToNode).ToArray());
                case "ParenthesizedExpression": return new ParenthesizedExpression(node.Children.Select(ToNode).ToArray());
                case "ThrowExpression": return new ThrowExpression(node.Children.Select(ToNode).ToArray());
                case "LambdaParameter": return new LambdaParameter(node.Children.Select(ToNode).ToArray());
                case "LambdaParameters": return new LambdaParameters(node.Children.Select(ToNode).ToArray());
                case "LambdaBody": return new LambdaBody(node.Children.Select(ToNode).ToArray());
                case "LambdaExpr": return new LambdaExpr(node.Children.Select(ToNode).ToArray());
                case "MemberAccess": return new MemberAccess(node.Children.Select(ToNode).ToArray());
                case "ConditionalMemberAccess": return new ConditionalMemberAccess(node.Children.Select(ToNode).ToArray());
                case "TypeOf": return new TypeOf(node.Children.Select(ToNode).ToArray());
                case "NameOf": return new NameOf(node.Children.Select(ToNode).ToArray());
                case "Default": return new Default(node.Children.Select(ToNode).ToArray());
                case "InitializerClause": return new InitializerClause(node.Children.Select(ToNode).ToArray());
                case "Initializer": return new Initializer(node.Children.Select(ToNode).ToArray());
                case "ArraySizeSpecifier": return new ArraySizeSpecifier(node.Children.Select(ToNode).ToArray());
                case "NewOperation": return new NewOperation(node.Children.Select(ToNode).ToArray());
                case "IsOperation": return new IsOperation(node.Children.Select(ToNode).ToArray());
                case "AsOperation": return new AsOperation(node.Children.Select(ToNode).ToArray());
                case "StringInterpolationContent": return new StringInterpolationContent(node.Children.Select(ToNode).ToArray());
                case "StringInterpolation": return new StringInterpolation(node.Children.Select(ToNode).ToArray());
                case "FunctionArgKeyword": return new FunctionArgKeyword(node.Contents);
                case "FunctionArg": return new FunctionArg(node.Children.Select(ToNode).ToArray());
                case "FunctionArgs": return new FunctionArgs(node.Children.Select(ToNode).ToArray());
                case "LeafExpression": return new LeafExpression(node.Children.Select(ToNode).ToArray());
                case "Expression": return new Expression(node.Children.Select(ToNode).ToArray());
                case "ExpressionStatement": return new ExpressionStatement(node.Children.Select(ToNode).ToArray());
                case "ElseClause": return new ElseClause(node.Children.Select(ToNode).ToArray());
                case "IfStatement": return new IfStatement(node.Children.Select(ToNode).ToArray());
                case "WhileStatement": return new WhileStatement(node.Children.Select(ToNode).ToArray());
                case "DoWhileStatement": return new DoWhileStatement(node.Children.Select(ToNode).ToArray());
                case "ReturnStatement": return new ReturnStatement(node.Children.Select(ToNode).ToArray());
                case "BreakStatement": return new BreakStatement(node.Contents);
                case "YieldStatement": return new YieldStatement(node.Children.Select(ToNode).ToArray());
                case "YieldBreakStatement": return new YieldBreakStatement(node.Contents);
                case "ContinueStatement": return new ContinueStatement(node.Contents);
                case "CompoundStatement": return new CompoundStatement(node.Children.Select(ToNode).ToArray());
                case "CatchClause": return new CatchClause(node.Children.Select(ToNode).ToArray());
                case "FinallyClause": return new FinallyClause(node.Children.Select(ToNode).ToArray());
                case "CaseClause": return new CaseClause(node.Children.Select(ToNode).ToArray());
                case "SwitchStatement": return new SwitchStatement(node.Children.Select(ToNode).ToArray());
                case "TryStatement": return new TryStatement(node.Children.Select(ToNode).ToArray());
                case "ForEachStatement": return new ForEachStatement(node.Children.Select(ToNode).ToArray());
                case "InitializationClause": return new InitializationClause(node.Children.Select(ToNode).ToArray());
                case "InvariantClause": return new InvariantClause(node.Children.Select(ToNode).ToArray());
                case "VariantClause": return new VariantClause(node.Children.Select(ToNode).ToArray());
                case "ForStatement": return new ForStatement(node.Children.Select(ToNode).ToArray());
                case "Initialization": return new Initialization(node.Children.Select(ToNode).ToArray());
                case "VarDecl": return new VarDecl(node.Children.Select(ToNode).ToArray());
                case "VarDeclStatement": return new VarDeclStatement(node.Children.Select(ToNode).ToArray());
                case "ThrowStatement": return new ThrowStatement(node.Children.Select(ToNode).ToArray());
                case "Statement": return new Statement(node.Children.Select(ToNode).ToArray());
                case "QualifiedIdentifier": return new QualifiedIdentifier(node.Children.Select(ToNode).ToArray());
                case "Static": return new Static(node.Contents);
                case "UsingDirective": return new UsingDirective(node.Children.Select(ToNode).ToArray());
                case "Modifier": return new Modifier(node.Contents);
                case "AccessSpecifier": return new AccessSpecifier(node.Contents);
                case "Attribute": return new Attribute(node.Children.Select(ToNode).ToArray());
                case "AttributeList": return new AttributeList(node.Children.Select(ToNode).ToArray());
                case "DeclarationPreamble": return new DeclarationPreamble(node.Children.Select(ToNode).ToArray());
                case "TypeVariance": return new TypeVariance(node.Contents);
                case "TypeParameter": return new TypeParameter(node.Children.Select(ToNode).ToArray());
                case "TypeParameterList": return new TypeParameterList(node.Children.Select(ToNode).ToArray());
                case "BaseClassList": return new BaseClassList(node.Children.Select(ToNode).ToArray());
                case "Constraint": return new Constraint(node.Children.Select(ToNode).ToArray());
                case "ConstraintClause": return new ConstraintClause(node.Children.Select(ToNode).ToArray());
                case "ConstraintList": return new ConstraintList(node.Children.Select(ToNode).ToArray());
                case "Kind": return new Kind(node.Contents);
                case "TypeDeclaration": return new TypeDeclaration(node.Children.Select(ToNode).ToArray());
                case "TypeDeclarationWithPreamble": return new TypeDeclarationWithPreamble(node.Children.Select(ToNode).ToArray());
                case "FunctionParameterKeywords": return new FunctionParameterKeywords(node.Contents);
                case "DefaultValue": return new DefaultValue(node.Children.Select(ToNode).ToArray());
                case "FunctionParameter": return new FunctionParameter(node.Children.Select(ToNode).ToArray());
                case "FunctionParameterList": return new FunctionParameterList(node.Children.Select(ToNode).ToArray());
                case "ExpressionBody": return new ExpressionBody(node.Children.Select(ToNode).ToArray());
                case "FunctionBody": return new FunctionBody(node.Children.Select(ToNode).ToArray());
                case "BaseCall": return new BaseCall(node.Children.Select(ToNode).ToArray());
                case "ThisCall": return new ThisCall(node.Children.Select(ToNode).ToArray());
                case "BaseOrThisCall": return new BaseOrThisCall(node.Children.Select(ToNode).ToArray());
                case "ConstructorDeclaration": return new ConstructorDeclaration(node.Children.Select(ToNode).ToArray());
                case "MethodDeclaration": return new MethodDeclaration(node.Children.Select(ToNode).ToArray());
                case "FieldDeclaration": return new FieldDeclaration(node.Children.Select(ToNode).ToArray());
                case "Getter": return new Getter(node.Children.Select(ToNode).ToArray());
                case "Setter": return new Setter(node.Children.Select(ToNode).ToArray());
                case "Initter": return new Initter(node.Children.Select(ToNode).ToArray());
                case "PropertyClauses": return new PropertyClauses(node.Children.Select(ToNode).ToArray());
                case "PropertyBody": return new PropertyBody(node.Children.Select(ToNode).ToArray());
                case "PropertyDeclaration": return new PropertyDeclaration(node.Children.Select(ToNode).ToArray());
                case "IndexerDeclaration": return new IndexerDeclaration(node.Children.Select(ToNode).ToArray());
                case "OperatorDeclaration": return new OperatorDeclaration(node.Children.Select(ToNode).ToArray());
                case "ImplicitOrExplicit": return new ImplicitOrExplicit(node.Contents);
                case "ConverterDeclaration": return new ConverterDeclaration(node.Children.Select(ToNode).ToArray());
                case "MemberDeclaration": return new MemberDeclaration(node.Children.Select(ToNode).ToArray());
                case "NamespaceDeclaration": return new NamespaceDeclaration(node.Children.Select(ToNode).ToArray());
                case "FileScopedNamespace": return new FileScopedNamespace(node.Children.Select(ToNode).ToArray());
                case "TopDeclaration": return new TopDeclaration(node.Children.Select(ToNode).ToArray());
                case "File": return new File(node.Children.Select(ToNode).ToArray());
                case "ArrayRankSpecifier": return new ArrayRankSpecifier(node.Contents);
                case "ArrayRankSpecifiers": return new ArrayRankSpecifiers(node.Children.Select(ToNode).ToArray());
                case "TypeArgList": return new TypeArgList(node.Children.Select(ToNode).ToArray());
                case "Nullable": return new Nullable(node.Contents);
                case "TypeExpr": return new TypeExpr(node.Children.Select(ToNode).ToArray());
                case "Separator": return new Separator(node.Children.Select(ToNode).ToArray());
                case "TypeKeyword": return new TypeKeyword(node.Contents);
                case "StatementKeyword": return new StatementKeyword(node.Contents);
                case "Token": return new Token(node.Children.Select(ToNode).ToArray());
                case "TokenGroup": return new TokenGroup(node.Children.Select(ToNode).ToArray());
                case "TypeStructure": return new TypeStructure(node.Children.Select(ToNode).ToArray());
                case "StatementStructure": return new StatementStructure(node.Children.Select(ToNode).ToArray());
                case "Element": return new Element(node.Children.Select(ToNode).ToArray());
                case "BracedStructure": return new BracedStructure(node.Children.Select(ToNode).ToArray());
                case "BracketedStructure": return new BracketedStructure(node.Children.Select(ToNode).ToArray());
                case "ParenthesizedStructure": return new ParenthesizedStructure(node.Children.Select(ToNode).ToArray());
                case "Structure": return new Structure(node.Children.Select(ToNode).ToArray());
                case "FileStructure": return new FileStructure(node.Children.Select(ToNode).ToArray());
                default: throw new Exception($"Unrecognized parse node {node.Type}");
            }
        }
    }
}
