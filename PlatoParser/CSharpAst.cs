// NOTE: Autogenerated file created on 2023-02-26 1:54:54 AM. DO NOT EDIT!
using System;
using System.Linq;

namespace PlatoParser
{
    // Original Rule: (((Digits+(FractionalPart)?)+(ExponentPart)?)+(FloatSuffix)?)
    // Only Nodes: 
    public class FloatLiteral : AstNode
    {
        public FloatLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FloatLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("0x"|"0X")+(HexDigit+(HexDigit)*))+(IntegerSuffix)?)
    // Only Nodes: 
    public class HexLiteral : AstNode
    {
        public HexLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new HexLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("0b"|(("0B"+(BinDigit+(BinDigit)*))+(IntegerSuffix)?))
    // Only Nodes: 
    public class BinaryLiteral : AstNode
    {
        public BinaryLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BinaryLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((Digits+!([.fFdDmM]))+(IntegerSuffix)?)
    // Only Nodes: 
    public class IntegerLiteral : AstNode
    {
        public IntegerLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new IntegerLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((op_Implicit+(StringLiteralChar)*)+op_Implicit)
    // Only Nodes: 
    public class StringLiteral : AstNode
    {
        public StringLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new StringLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((op_Implicit+CharLiteralChar)+op_Implicit)
    // Only Nodes: 
    public class CharLiteral : AstNode
    {
        public CharLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new CharLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("true"+!(IdentifierChar))+WS)|(("false"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class BooleanLiteral : AstNode
    {
        public BooleanLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BooleanLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("null"+!(IdentifierChar))+WS)
    // Only Nodes: 
    public class NullLiteral : AstNode
    {
        public NullLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new NullLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("value"+!(IdentifierChar))+WS)
    // Only Nodes: 
    public class ValueLiteral : AstNode
    {
        public ValueLiteral(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ValueLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((((((((HexLiteral|BinaryLiteral)|FloatLiteral)|IntegerLiteral)|StringLiteral)|CharLiteral)|BooleanLiteral)|NullLiteral)|ValueLiteral)
    // Only Nodes: (HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral|ValueLiteral)
    public class Literal : AstNode
    {
        public Literal(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Literal(Children.Select(f).ToArray());
        public HexLiteral Node0 => Children[0] as HexLiteral;
        public BinaryLiteral Node1 => Children[0] as BinaryLiteral;
        public FloatLiteral Node2 => Children[0] as FloatLiteral;
        public IntegerLiteral Node3 => Children[0] as IntegerLiteral;
        public StringLiteral Node4 => Children[0] as StringLiteral;
        public CharLiteral Node5 => Children[0] as CharLiteral;
        public BooleanLiteral Node6 => Children[0] as BooleanLiteral;
        public NullLiteral Node7 => Children[0] as NullLiteral;
        public ValueLiteral Node8 => Children[0] as ValueLiteral;
    }

    // Original Rule: ((">>>="+WS)|(">>>"+WS)|(">>="+WS)|("<<="+WS)|("&&="+WS)|("||="+WS)|(">>"+WS)|("<<"+WS)|("&&"+WS)|("||"+WS)|("+="+WS)|("-="+WS)|("*="+WS)|("/="+WS)|("%="+WS)|("&="+WS)|("|="+WS)|("^="+WS)|("<="+WS)|("=>"+WS)|("=="+WS)|("!="+WS)|("??"+WS)|("?="+WS)|("+"+WS)|("-"+WS)|("*"+WS)|("/"+WS)|("%"+WS)|("&"+WS)|("|"+WS)|("^"+WS)|("="+WS)|("<"+WS)|(">"+WS))
    // Only Nodes: 
    public class BinaryOperator : AstNode
    {
        public BinaryOperator(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BinaryOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("++"+WS)|("--"+WS)|("!"+WS)|("-"+WS)|("+"+WS)|("~"+WS))
    // Only Nodes: 
    public class UnaryOperator : AstNode
    {
        public UnaryOperator(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new UnaryOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("["+WS)+Expression)+("]"+WS))
    // Only Nodes: Expression
    public class Indexer : AstNode
    {
        public Indexer(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Indexer(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: ((">>>"+WS)|("++"+WS)|("--"+WS)|("<<"+WS)|(">>"+WS)|("=="+WS)|("!="+WS)|("<="+WS)|(">="+WS)|("+"+WS)|("-"+WS)|("!"+WS)|("~"+WS)|("*"+WS)|("/"+WS)|("%"+WS)|("&"+WS)|("|"+WS)|("^"+WS)|("<"+WS)|(">"+WS))
    // Only Nodes: 
    public class OverloadableOperator : AstNode
    {
        public OverloadableOperator(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new OverloadableOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (((((((((("++"+WS)|("--"+WS)|("!"+WS)|("?"+WS))|MemberAccess)|ConditionalMemberAccess)|FunctionArgs)|Indexer)|TernaryOperation)|BinaryOperation)|IsOperation)|AsOperation)
    // Only Nodes: (MemberAccess|ConditionalMemberAccess|FunctionArgs|Indexer|TernaryOperation|BinaryOperation|IsOperation|AsOperation)
    public class PostfixOperator : AstNode
    {
        public PostfixOperator(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new PostfixOperator(Children.Select(f).ToArray());
        public MemberAccess Node0 => Children[0] as MemberAccess;
        public ConditionalMemberAccess Node1 => Children[0] as ConditionalMemberAccess;
        public FunctionArgs Node2 => Children[0] as FunctionArgs;
        public Indexer Node3 => Children[0] as Indexer;
        public TernaryOperation Node4 => Children[0] as TernaryOperation;
        public BinaryOperation Node5 => Children[0] as BinaryOperation;
        public IsOperation Node6 => Children[0] as IsOperation;
        public AsOperation Node7 => Children[0] as AsOperation;
    }

    // Original Rule: (IdentifierFirstChar+(IdentifierChar)*)
    // Only Nodes: 
    public class Identifier : AstNode
    {
        public Identifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Identifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (BinaryOperator+Expression)
    // Only Nodes: (BinaryOperator+Expression)
    public class BinaryOperation : AstNode
    {
        public BinaryOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BinaryOperation(Children.Select(f).ToArray());
        public BinaryOperator Node0 => Children[0] as BinaryOperator;
        public Expression Node1 => Children[1] as Expression;
    }

    // Original Rule: (((("?"+WS)+Expression)+(":"+WS))+Expression)
    // Only Nodes: (Expression+Expression)
    public class TernaryOperation : AstNode
    {
        public TernaryOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TernaryOperation(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
        public Expression Node1 => Children[1] as Expression;
    }

    // Original Rule: ((("("+WS)+(((Expression+WS)+(((Comma+Expression)+WS))*))?)+(")"+WS))
    // Only Nodes: ((Expression+(Expression)*))?
    public class ParenthesizedExpression : AstNode
    {
        public ParenthesizedExpression(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ParenthesizedExpression(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: ((("throw"+!(IdentifierChar))+WS)+Expression)
    // Only Nodes: Expression
    public class ThrowExpression : AstNode
    {
        public ThrowExpression(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ThrowExpression(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: ((TypeExpr+Identifier)|Identifier)
    // Only Nodes: ((TypeExpr+Identifier)|Identifier)
    public class LambdaParameter : AstNode
    {
        public LambdaParameter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LambdaParameter(Children.Select(f).ToArray());
        public AstSequence Node0 => Children[0] as AstSequence;
        public Identifier Node1 => Children[0] as Identifier;
    }

    // Original Rule: (LambdaParameter|((("("+WS)+(((LambdaParameter+WS)+(((Comma+LambdaParameter)+WS))*))?)+(")"+WS)))
    // Only Nodes: (LambdaParameter|((LambdaParameter+(LambdaParameter)*))?)
    public class LambdaParameters : AstNode
    {
        public LambdaParameters(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LambdaParameters(Children.Select(f).ToArray());
        public LambdaParameter Node0 => Children[0] as LambdaParameter;
        public AstNode Node1 => Children[0] as AstNode;
    }

    // Original Rule: (CompoundStatement|Expression)
    // Only Nodes: (CompoundStatement|Expression)
    public class LambdaBody : AstNode
    {
        public LambdaBody(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LambdaBody(Children.Select(f).ToArray());
        public CompoundStatement Node0 => Children[0] as CompoundStatement;
        public Expression Node1 => Children[0] as Expression;
    }

    // Original Rule: ((LambdaParameters+("=>"+WS))+LambdaBody)
    // Only Nodes: (LambdaParameters+LambdaBody)
    public class LambdaExpr : AstNode
    {
        public LambdaExpr(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LambdaExpr(Children.Select(f).ToArray());
        public LambdaParameters Node0 => Children[0] as LambdaParameters;
        public LambdaBody Node1 => Children[1] as LambdaBody;
    }

    // Original Rule: (("."+WS)+Identifier)
    // Only Nodes: Identifier
    public class MemberAccess : AstNode
    {
        public MemberAccess(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new MemberAccess(Children.Select(f).ToArray());
        public Identifier Node0 => Children[0] as Identifier;
    }

    // Original Rule: (("?."+WS)+Identifier)
    // Only Nodes: Identifier
    public class ConditionalMemberAccess : AstNode
    {
        public ConditionalMemberAccess(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConditionalMemberAccess(Children.Select(f).ToArray());
        public Identifier Node0 => Children[0] as Identifier;
    }

    // Original Rule: ((("typeof"+!(IdentifierChar))+WS)+((("("+WS)+TypeExpr)+(")"+WS)))
    // Only Nodes: TypeExpr
    public class TypeOf : AstNode
    {
        public TypeOf(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeOf(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
    }

    // Original Rule: ((("nameof"+!(IdentifierChar))+WS)+((("("+WS)+Expression)+(")"+WS)))
    // Only Nodes: Expression
    public class NameOf : AstNode
    {
        public NameOf(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new NameOf(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: ((("default"+!(IdentifierChar))+WS)+(((("("+WS)+TypeExpr)+(")"+WS)))?)
    // Only Nodes: (TypeExpr)?
    public class Default : AstNode
    {
        public Default(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Default(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
    }

    // Original Rule: (((Identifier+("="+WS))+Expression)|Expression)
    // Only Nodes: ((Identifier+Expression)|Expression)
    public class InitializerClause : AstNode
    {
        public InitializerClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new InitializerClause(Children.Select(f).ToArray());
        public AstSequence Node0 => Children[0] as AstSequence;
        public Expression Node1 => Children[0] as Expression;
    }

    // Original Rule: ((("["+WS)+Expression)+("]"+WS))
    // Only Nodes: Expression
    public class ArraySizeSpecifier : AstNode
    {
        public ArraySizeSpecifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ArraySizeSpecifier(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: (((((("new"+!(IdentifierChar))+WS)+TypeExpr)+(FunctionArgs)?)+(ArraySizeSpecifier)?)+(((("{"+WS)+(((InitializerClause+WS)+(((Comma+InitializerClause)+WS))*))?)+("}"+WS)))?)
    // Only Nodes: (TypeExpr+(FunctionArgs)?+(ArraySizeSpecifier)?+(((InitializerClause+(InitializerClause)*))?)?)
    public class NewOperation : AstNode
    {
        public NewOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new NewOperation(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public FunctionArgs Node1 => Children[1] as FunctionArgs;
        public ArraySizeSpecifier Node2 => Children[2] as ArraySizeSpecifier;
        public AstNode Node3 => Children[3] as AstNode;
    }

    // Original Rule: (((("is"+!(IdentifierChar))+WS)+TypeExpr)+(Identifier)?)
    // Only Nodes: (TypeExpr+(Identifier)?)
    public class IsOperation : AstNode
    {
        public IsOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new IsOperation(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public Identifier Node1 => Children[1] as Identifier;
    }

    // Original Rule: (((("as"+!(IdentifierChar))+WS)+TypeExpr)+(Identifier)?)
    // Only Nodes: (TypeExpr+(Identifier)?)
    public class AsOperation : AstNode
    {
        public AsOperation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new AsOperation(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public Identifier Node1 => Children[1] as Identifier;
    }

    // Original Rule: (("$""+((((("{"+WS)+Expression)+("}"+WS))|StringLiteralChar))*)+""")
    // Only Nodes: (Expression)*
    public class StringInterpolation : AstNode
    {
        public StringInterpolation(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new StringInterpolation(Children.Select(f).ToArray());
        public AstStar<Expression> Node0 => Children[0] as AstStar<Expression>;
    }

    // Original Rule: ((("params"+!(IdentifierChar))+WS)|(("ref"+!(IdentifierChar))+WS)|(("out"+!(IdentifierChar))+WS)|(("in"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class FunctionArgKeyword : AstNode
    {
        public FunctionArgKeyword(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionArgKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((FunctionArgKeyword)*+Expression)
    // Only Nodes: ((FunctionArgKeyword)*+Expression)
    public class FunctionArg : AstNode
    {
        public FunctionArg(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionArg(Children.Select(f).ToArray());
        public AstStar<FunctionArgKeyword> Node0 => Children[0] as AstStar<FunctionArgKeyword>;
        public Expression Node1 => Children[1] as Expression;
    }

    // Original Rule: ((("("+WS)+(((FunctionArg+WS)+(((Comma+FunctionArg)+WS))*))?)+(")"+WS))
    // Only Nodes: ((FunctionArg+(FunctionArg)*))?
    public class FunctionArgs : AstNode
    {
        public FunctionArgs(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionArgs(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: (((((((((LambdaExpr|ParenthesizedExpression)|ThrowExpression)|Literal)|TypeOf)|NameOf)|Default)|NewOperation)|StringInterpolation)|Identifier)
    // Only Nodes: (LambdaExpr|ParenthesizedExpression|ThrowExpression|Literal|TypeOf|NameOf|Default|NewOperation|StringInterpolation|Identifier)
    public class LeafExpression : AstNode
    {
        public LeafExpression(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new LeafExpression(Children.Select(f).ToArray());
        public LambdaExpr Node0 => Children[0] as LambdaExpr;
        public ParenthesizedExpression Node1 => Children[0] as ParenthesizedExpression;
        public ThrowExpression Node2 => Children[0] as ThrowExpression;
        public Literal Node3 => Children[0] as Literal;
        public TypeOf Node4 => Children[0] as TypeOf;
        public NameOf Node5 => Children[0] as NameOf;
        public Default Node6 => Children[0] as Default;
        public NewOperation Node7 => Children[0] as NewOperation;
        public StringInterpolation Node8 => Children[0] as StringInterpolation;
        public Identifier Node9 => Children[0] as Identifier;
    }

    // Original Rule: (((UnaryOperator)*+LeafExpression)+(PostfixOperator)*)
    // Only Nodes: ((UnaryOperator)*+LeafExpression+(PostfixOperator)*)
    public class Expression : AstNode
    {
        public Expression(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Expression(Children.Select(f).ToArray());
        public AstStar<UnaryOperator> Node0 => Children[0] as AstStar<UnaryOperator>;
        public LeafExpression Node1 => Children[1] as LeafExpression;
        public AstStar<PostfixOperator> Node2 => Children[2] as AstStar<PostfixOperator>;
    }

    // Original Rule: (Expression+EOS)
    // Only Nodes: Expression
    public class ExpressionStatement : AstNode
    {
        public ExpressionStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ExpressionStatement(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: ((("else"+!(IdentifierChar))+WS)+Statement)
    // Only Nodes: Statement
    public class ElseClause : AstNode
    {
        public ElseClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ElseClause(Children.Select(f).ToArray());
        public Statement Node0 => Children[0] as Statement;
    }

    // Original Rule: ((((("if"+!(IdentifierChar))+WS)+ParenthesizedExpression)+Statement)+(ElseClause)?)
    // Only Nodes: (ParenthesizedExpression+Statement+(ElseClause)?)
    public class IfStatement : AstNode
    {
        public IfStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new IfStatement(Children.Select(f).ToArray());
        public ParenthesizedExpression Node0 => Children[0] as ParenthesizedExpression;
        public Statement Node1 => Children[1] as Statement;
        public ElseClause Node2 => Children[2] as ElseClause;
    }

    // Original Rule: (((("while"+!(IdentifierChar))+WS)+ParenthesizedExpression)+Statement)
    // Only Nodes: (ParenthesizedExpression+Statement)
    public class WhileStatement : AstNode
    {
        public WhileStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new WhileStatement(Children.Select(f).ToArray());
        public ParenthesizedExpression Node0 => Children[0] as ParenthesizedExpression;
        public Statement Node1 => Children[1] as Statement;
    }

    // Original Rule: (((((("do"+!(IdentifierChar))+WS)+Statement)+(("while"+!(IdentifierChar))+WS))+ParenthesizedExpression)+EOS)
    // Only Nodes: (Statement+ParenthesizedExpression)
    public class DoWhileStatement : AstNode
    {
        public DoWhileStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new DoWhileStatement(Children.Select(f).ToArray());
        public Statement Node0 => Children[0] as Statement;
        public ParenthesizedExpression Node1 => Children[1] as ParenthesizedExpression;
    }

    // Original Rule: (((("return"+!(IdentifierChar))+WS)+(Expression)?)+EOS)
    // Only Nodes: (Expression)?
    public class ReturnStatement : AstNode
    {
        public ReturnStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ReturnStatement(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: ((("break"+!(IdentifierChar))+WS)+EOS)
    // Only Nodes: 
    public class BreakStatement : AstNode
    {
        public BreakStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BreakStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((((("yield"+!(IdentifierChar))+WS)+(("return"+!(IdentifierChar))+WS))+Expression)+EOS)
    // Only Nodes: Expression
    public class YieldStatement : AstNode
    {
        public YieldStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new YieldStatement(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: (((("yield"+!(IdentifierChar))+WS)+(("break"+!(IdentifierChar))+WS))+EOS)
    // Only Nodes: 
    public class YieldBreakStatement : AstNode
    {
        public YieldBreakStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new YieldBreakStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("break"+!(IdentifierChar))+WS)+EOS)
    // Only Nodes: 
    public class ContinueStatement : AstNode
    {
        public ContinueStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ContinueStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("{"+WS)+(Statement)*)+("}"+WS))
    // Only Nodes: (Statement)*
    public class CompoundStatement : AstNode
    {
        public CompoundStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new CompoundStatement(Children.Select(f).ToArray());
        public AstStar<Statement> Node0 => Children[0] as AstStar<Statement>;
    }

    // Original Rule: (((("catch"+!(IdentifierChar))+WS)+((("("+WS)+VarDecl)+(")"+WS)))+CompoundStatement)
    // Only Nodes: (VarDecl+CompoundStatement)
    public class CatchClause : AstNode
    {
        public CatchClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new CatchClause(Children.Select(f).ToArray());
        public VarDecl Node0 => Children[0] as VarDecl;
        public CompoundStatement Node1 => Children[1] as CompoundStatement;
    }

    // Original Rule: ((("finally"+!(IdentifierChar))+WS)+CompoundStatement)
    // Only Nodes: CompoundStatement
    public class FinallyClause : AstNode
    {
        public FinallyClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FinallyClause(Children.Select(f).ToArray());
        public CompoundStatement Node0 => Children[0] as CompoundStatement;
    }

    // Original Rule: (((("default"+!(IdentifierChar))+WS)|((("case"+!(IdentifierChar))+WS)+Expression))+Statement)
    // Only Nodes: (Expression+Statement)
    public class CaseClause : AstNode
    {
        public CaseClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new CaseClause(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
        public Statement Node1 => Children[1] as Statement;
    }

    // Original Rule: ((("switch"+!(IdentifierChar))+WS)+((("{"+WS)+(CaseClause)*)+("}"+WS)))
    // Only Nodes: (CaseClause)*
    public class SwitchStatement : AstNode
    {
        public SwitchStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new SwitchStatement(Children.Select(f).ToArray());
        public AstStar<CaseClause> Node0 => Children[0] as AstStar<CaseClause>;
    }

    // Original Rule: ((((("try"+!(IdentifierChar))+WS)+CompoundStatement)+(CatchClause)?)+(FinallyClause)?)
    // Only Nodes: (CompoundStatement+(CatchClause)?+(FinallyClause)?)
    public class TryStatement : AstNode
    {
        public TryStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TryStatement(Children.Select(f).ToArray());
        public CompoundStatement Node0 => Children[0] as CompoundStatement;
        public CatchClause Node1 => Children[1] as CatchClause;
        public FinallyClause Node2 => Children[2] as FinallyClause;
    }

    // Original Rule: (((((((("foreach"+!(IdentifierChar))+WS)+("("+WS))+VarDecl)+(("in"+!(IdentifierChar))+WS))+Expression)+(")"+WS))+Statement)
    // Only Nodes: (VarDecl+Expression+Statement)
    public class ForEachStatement : AstNode
    {
        public ForEachStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ForEachStatement(Children.Select(f).ToArray());
        public VarDecl Node0 => Children[0] as VarDecl;
        public Expression Node1 => Children[1] as Expression;
        public Statement Node2 => Children[2] as Statement;
    }

    // Original Rule: ((VarDecl+Initialization))?
    // Only Nodes: ((VarDecl+Initialization))?
    public class InitializationClause : AstNode
    {
        public InitializationClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new InitializationClause(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: (Expression)?
    // Only Nodes: (Expression)?
    public class InvariantClause : AstNode
    {
        public InvariantClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new InvariantClause(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: (Expression)?
    // Only Nodes: (Expression)?
    public class VariantClause : AstNode
    {
        public VariantClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new VariantClause(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: (((((((((("for"+!(IdentifierChar))+WS)+("("+WS))+InitializationClause)+EOS)+InvariantClause)+EOS)+VariantClause)+(")"+WS))+Statement)
    // Only Nodes: (InitializationClause+InvariantClause+VariantClause+Statement)
    public class ForStatement : AstNode
    {
        public ForStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ForStatement(Children.Select(f).ToArray());
        public InitializationClause Node0 => Children[0] as InitializationClause;
        public InvariantClause Node1 => Children[1] as InvariantClause;
        public VariantClause Node2 => Children[2] as VariantClause;
        public Statement Node3 => Children[3] as Statement;
    }

    // Original Rule: ((("="+WS)+Expression))?
    // Only Nodes: (Expression)?
    public class Initialization : AstNode
    {
        public Initialization(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Initialization(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: (TypeExpr+Identifier)
    // Only Nodes: (TypeExpr+Identifier)
    public class VarDecl : AstNode
    {
        public VarDecl(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new VarDecl(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public Identifier Node1 => Children[1] as Identifier;
    }

    // Original Rule: ((VarDecl+Initialization)+EOS)
    // Only Nodes: (VarDecl+Initialization)
    public class VarDeclStatement : AstNode
    {
        public VarDeclStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new VarDeclStatement(Children.Select(f).ToArray());
        public VarDecl Node0 => Children[0] as VarDecl;
        public Initialization Node1 => Children[1] as Initialization;
    }

    // Original Rule: ((((("throw"+!(IdentifierChar))+WS)+CompoundStatement)+(CatchClause)?)+(FinallyClause)?)
    // Only Nodes: (CompoundStatement+(CatchClause)?+(FinallyClause)?)
    public class ThrowStatement : AstNode
    {
        public ThrowStatement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ThrowStatement(Children.Select(f).ToArray());
        public CompoundStatement Node0 => Children[0] as CompoundStatement;
        public CatchClause Node1 => Children[1] as CatchClause;
        public FinallyClause Node2 => Children[2] as FinallyClause;
    }

    // Original Rule: (((((((((((((EOS|CompoundStatement)|IfStatement)|WhileStatement)|DoWhileStatement)|ReturnStatement)|BreakStatement)|ContinueStatement)|ForStatement)|ForEachStatement)|ThrowStatement)|VarDeclStatement)|TryStatement)|ExpressionStatement)
    // Only Nodes: (CompoundStatement|IfStatement|WhileStatement|DoWhileStatement|ReturnStatement|BreakStatement|ContinueStatement|ForStatement|ForEachStatement|ThrowStatement|VarDeclStatement|TryStatement|ExpressionStatement)
    public class Statement : AstNode
    {
        public Statement(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Statement(Children.Select(f).ToArray());
        public CompoundStatement Node0 => Children[0] as CompoundStatement;
        public IfStatement Node1 => Children[0] as IfStatement;
        public WhileStatement Node2 => Children[0] as WhileStatement;
        public DoWhileStatement Node3 => Children[0] as DoWhileStatement;
        public ReturnStatement Node4 => Children[0] as ReturnStatement;
        public BreakStatement Node5 => Children[0] as BreakStatement;
        public ContinueStatement Node6 => Children[0] as ContinueStatement;
        public ForStatement Node7 => Children[0] as ForStatement;
        public ForEachStatement Node8 => Children[0] as ForEachStatement;
        public ThrowStatement Node9 => Children[0] as ThrowStatement;
        public VarDeclStatement Node10 => Children[0] as VarDeclStatement;
        public TryStatement Node11 => Children[0] as TryStatement;
        public ExpressionStatement Node12 => Children[0] as ExpressionStatement;
    }

    // Original Rule: (((Identifier+WS)+(((("."+WS)+Identifier)+WS))*))?
    // Only Nodes: ((Identifier+(Identifier)*))?
    public class QualifiedIdentifier : AstNode
    {
        public QualifiedIdentifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new QualifiedIdentifier(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: ((("static"+!(IdentifierChar))+WS))?
    // Only Nodes: 
    public class Static : AstNode
    {
        public Static(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Static(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((((("using"+!(IdentifierChar))+WS)+Static)+QualifiedIdentifier)+EOS)
    // Only Nodes: (Static+QualifiedIdentifier)
    public class UsingDirective : AstNode
    {
        public UsingDirective(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new UsingDirective(Children.Select(f).ToArray());
        public Static Node0 => Children[0] as Static;
        public QualifiedIdentifier Node1 => Children[1] as QualifiedIdentifier;
    }

    // Original Rule: ((("readonly"+!(IdentifierChar))+WS)|(("abstract"+!(IdentifierChar))+WS)|(("partial"+!(IdentifierChar))+WS)|(("virtual"+!(IdentifierChar))+WS)|(("static"+!(IdentifierChar))+WS)|(("sealed"+!(IdentifierChar))+WS)|(("const"+!(IdentifierChar))+WS)|(("ref"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class Modifier : AstNode
    {
        public Modifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Modifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("protected"+!(IdentifierChar))+WS)|(("internal"+!(IdentifierChar))+WS)|(("private"+!(IdentifierChar))+WS)|(("public"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class AccessSpecifier : AstNode
    {
        public AccessSpecifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new AccessSpecifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("["+WS)+((((Identifier+(FunctionArgs)?)+WS)+(((Comma+(Identifier+(FunctionArgs)?))+WS))*))?)+("]"+WS))
    // Only Nodes: ((Identifier+(FunctionArgs)?+((Identifier+(FunctionArgs)?))*))?
    public class Attribute : AstNode
    {
        public Attribute(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Attribute(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: (Attribute)*
    // Only Nodes: (Attribute)*
    public class AttributeList : AstNode
    {
        public AttributeList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new AttributeList(Children.Select(f).ToArray());
        public AstStar<Attribute> Node0 => Children[0] as AstStar<Attribute>;
    }

    // Original Rule: (AttributeList+((Modifier|AccessSpecifier))*)
    // Only Nodes: (AttributeList+((Modifier|AccessSpecifier))*)
    public class DeclarationPreamble : AstNode
    {
        public DeclarationPreamble(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new DeclarationPreamble(Children.Select(f).ToArray());
        public AttributeList Node0 => Children[0] as AttributeList;
        public AstStar<AstNode> Node1 => Children[1] as AstStar<AstNode>;
    }

    // Original Rule: (((("out"+!(IdentifierChar))+WS)|(("in"+!(IdentifierChar))+WS)))?
    // Only Nodes: 
    public class TypeVariance : AstNode
    {
        public TypeVariance(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeVariance(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (TypeVariance+Identifier)
    // Only Nodes: (TypeVariance+Identifier)
    public class TypeParameter : AstNode
    {
        public TypeParameter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeParameter(Children.Select(f).ToArray());
        public TypeVariance Node0 => Children[0] as TypeVariance;
        public Identifier Node1 => Children[1] as Identifier;
    }

    // Original Rule: (((("<"+WS)+(((TypeParameter+WS)+(((Comma+TypeParameter)+WS))*))?)+(">"+WS)))?
    // Only Nodes: (((TypeParameter+(TypeParameter)*))?)?
    public class TypeParameterList : AstNode
    {
        public TypeParameterList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeParameterList(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: (((":"+WS)+(((TypeExpr+WS)+(((Comma+TypeExpr)+WS))*))?))?
    // Only Nodes: (((TypeExpr+(TypeExpr)*))?)?
    public class BaseClassList : AstNode
    {
        public BaseClassList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BaseClassList(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: (((("class"+!(IdentifierChar))+WS)|(("struct"+!(IdentifierChar))+WS))|TypeExpr)
    // Only Nodes: TypeExpr
    public class Constraint : AstNode
    {
        public Constraint(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Constraint(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
    }

    // Original Rule: ((((("where"+!(IdentifierChar))+WS)+Identifier)+(":"+WS))+TypeExpr)
    // Only Nodes: (Identifier+TypeExpr)
    public class ConstraintClause : AstNode
    {
        public ConstraintClause(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConstraintClause(Children.Select(f).ToArray());
        public Identifier Node0 => Children[0] as Identifier;
        public TypeExpr Node1 => Children[1] as TypeExpr;
    }

    // Original Rule: (ConstraintClause)*
    // Only Nodes: (ConstraintClause)*
    public class ConstraintList : AstNode
    {
        public ConstraintList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConstraintList(Children.Select(f).ToArray());
        public AstStar<ConstraintClause> Node0 => Children[0] as AstStar<ConstraintClause>;
    }

    // Original Rule: ((("interface"+!(IdentifierChar))+WS)|(("struct"+!(IdentifierChar))+WS)|(("class"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class Kind : AstNode
    {
        public Kind(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Kind(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (((((Kind+Identifier)+TypeParameterList)+BaseClassList)+ConstraintList)+((("{"+WS)+(MemberDeclaration)*)+("}"+WS)))
    // Only Nodes: (Kind+Identifier+TypeParameterList+BaseClassList+ConstraintList+(MemberDeclaration)*)
    public class TypeDeclaration : AstNode
    {
        public TypeDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeDeclaration(Children.Select(f).ToArray());
        public Kind Node0 => Children[0] as Kind;
        public Identifier Node1 => Children[1] as Identifier;
        public TypeParameterList Node2 => Children[2] as TypeParameterList;
        public BaseClassList Node3 => Children[3] as BaseClassList;
        public ConstraintList Node4 => Children[4] as ConstraintList;
        public AstStar<MemberDeclaration> Node5 => Children[5] as AstStar<MemberDeclaration>;
    }

    // Original Rule: (DeclarationPreamble+TypeDeclaration)
    // Only Nodes: (DeclarationPreamble+TypeDeclaration)
    public class TypeDeclarationWithPreamble : AstNode
    {
        public TypeDeclarationWithPreamble(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeDeclarationWithPreamble(Children.Select(f).ToArray());
        public DeclarationPreamble Node0 => Children[0] as DeclarationPreamble;
        public TypeDeclaration Node1 => Children[1] as TypeDeclaration;
    }

    // Original Rule: (((("params"+!(IdentifierChar))+WS)|(("ref"+!(IdentifierChar))+WS)|(("out"+!(IdentifierChar))+WS)|(("in"+!(IdentifierChar))+WS)))?
    // Only Nodes: 
    public class FunctionParameterKeywords : AstNode
    {
        public FunctionParameterKeywords(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionParameterKeywords(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("="+WS)+Expression))?
    // Only Nodes: (Expression)?
    public class DefaultValue : AstNode
    {
        public DefaultValue(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new DefaultValue(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: ((((AttributeList+FunctionParameterKeywords)+TypeExpr)+Identifier)+DefaultValue)
    // Only Nodes: (AttributeList+FunctionParameterKeywords+TypeExpr+Identifier+DefaultValue)
    public class FunctionParameter : AstNode
    {
        public FunctionParameter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionParameter(Children.Select(f).ToArray());
        public AttributeList Node0 => Children[0] as AttributeList;
        public FunctionParameterKeywords Node1 => Children[1] as FunctionParameterKeywords;
        public TypeExpr Node2 => Children[2] as TypeExpr;
        public Identifier Node3 => Children[3] as Identifier;
        public DefaultValue Node4 => Children[4] as DefaultValue;
    }

    // Original Rule: ((("("+WS)+(((FunctionParameter+WS)+(((Comma+FunctionParameter)+WS))*))?)+(")"+WS))
    // Only Nodes: ((FunctionParameter+(FunctionParameter)*))?
    public class FunctionParameterList : AstNode
    {
        public FunctionParameterList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionParameterList(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: (("=>"+WS)+Expression)
    // Only Nodes: Expression
    public class ExpressionBody : AstNode
    {
        public ExpressionBody(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ExpressionBody(Children.Select(f).ToArray());
        public Expression Node0 => Children[0] as Expression;
    }

    // Original Rule: (ExpressionBody|CompoundStatement)
    // Only Nodes: (ExpressionBody|CompoundStatement)
    public class FunctionBody : AstNode
    {
        public FunctionBody(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FunctionBody(Children.Select(f).ToArray());
        public ExpressionBody Node0 => Children[0] as ExpressionBody;
        public CompoundStatement Node1 => Children[0] as CompoundStatement;
    }

    // Original Rule: ((("base"+!(IdentifierChar))+WS)+ParenthesizedExpression)
    // Only Nodes: ParenthesizedExpression
    public class BaseCall : AstNode
    {
        public BaseCall(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BaseCall(Children.Select(f).ToArray());
        public ParenthesizedExpression Node0 => Children[0] as ParenthesizedExpression;
    }

    // Original Rule: ((("this"+!(IdentifierChar))+WS)+ParenthesizedExpression)
    // Only Nodes: ParenthesizedExpression
    public class ThisCall : AstNode
    {
        public ThisCall(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ThisCall(Children.Select(f).ToArray());
        public ParenthesizedExpression Node0 => Children[0] as ParenthesizedExpression;
    }

    // Original Rule: (((":"+WS)+(BaseCall|ThisCall)))?
    // Only Nodes: ((BaseCall|ThisCall))?
    public class BaseOrThisCall : AstNode
    {
        public BaseOrThisCall(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new BaseOrThisCall(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: (((Identifier+FunctionParameterList)+BaseOrThisCall)+FunctionBody)
    // Only Nodes: (Identifier+FunctionParameterList+BaseOrThisCall+FunctionBody)
    public class ConstructorDeclaration : AstNode
    {
        public ConstructorDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConstructorDeclaration(Children.Select(f).ToArray());
        public Identifier Node0 => Children[0] as Identifier;
        public FunctionParameterList Node1 => Children[1] as FunctionParameterList;
        public BaseOrThisCall Node2 => Children[2] as BaseOrThisCall;
        public FunctionBody Node3 => Children[3] as FunctionBody;
    }

    // Original Rule: (((TypeExpr+Identifier)+FunctionParameterList)+FunctionBody)
    // Only Nodes: (TypeExpr+Identifier+FunctionParameterList+FunctionBody)
    public class MethodDeclaration : AstNode
    {
        public MethodDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new MethodDeclaration(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public Identifier Node1 => Children[1] as Identifier;
        public FunctionParameterList Node2 => Children[2] as FunctionParameterList;
        public FunctionBody Node3 => Children[3] as FunctionBody;
    }

    // Original Rule: ((TypeExpr+Identifier)+Initialization)
    // Only Nodes: (TypeExpr+Identifier+Initialization)
    public class FieldDeclaration : AstNode
    {
        public FieldDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FieldDeclaration(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public Identifier Node1 => Children[1] as Identifier;
        public Initialization Node2 => Children[2] as Initialization;
    }

    // Original Rule: ((("get"+!(IdentifierChar))+WS)+FunctionBody)
    // Only Nodes: FunctionBody
    public class Getter : AstNode
    {
        public Getter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Getter(Children.Select(f).ToArray());
        public FunctionBody Node0 => Children[0] as FunctionBody;
    }

    // Original Rule: ((("set"+!(IdentifierChar))+WS)+FunctionBody)
    // Only Nodes: FunctionBody
    public class Setter : AstNode
    {
        public Setter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Setter(Children.Select(f).ToArray());
        public FunctionBody Node0 => Children[0] as FunctionBody;
    }

    // Original Rule: ((("init"+!(IdentifierChar))+WS)+FunctionBody)
    // Only Nodes: FunctionBody
    public class Initter : AstNode
    {
        public Initter(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Initter(Children.Select(f).ToArray());
        public FunctionBody Node0 => Children[0] as FunctionBody;
    }

    // Original Rule: (((Getter|Setter)|Initter))*
    // Only Nodes: ((Getter|Setter|Initter))*
    public class PropertyClauses : AstNode
    {
        public PropertyClauses(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new PropertyClauses(Children.Select(f).ToArray());
        public AstStar<AstNode> Node0 => Children[0] as AstStar<AstNode>;
    }

    // Original Rule: (ExpressionBody|((("{"+WS)+PropertyClauses)+("}"+WS)))
    // Only Nodes: (ExpressionBody|PropertyClauses)
    public class PropertyBody : AstNode
    {
        public PropertyBody(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new PropertyBody(Children.Select(f).ToArray());
        public ExpressionBody Node0 => Children[0] as ExpressionBody;
        public PropertyClauses Node1 => Children[0] as PropertyClauses;
    }

    // Original Rule: ((TypeExpr+Identifier)+PropertyBody)
    // Only Nodes: (TypeExpr+Identifier+PropertyBody)
    public class PropertyDeclaration : AstNode
    {
        public PropertyDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new PropertyDeclaration(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public Identifier Node1 => Children[1] as Identifier;
        public PropertyBody Node2 => Children[2] as PropertyBody;
    }

    // Original Rule: (((TypeExpr+(("this"+!(IdentifierChar))+WS))+((("["+WS)+FunctionParameter)+("]"+WS)))+PropertyBody)
    // Only Nodes: (TypeExpr+FunctionParameter+PropertyBody)
    public class IndexerDeclaration : AstNode
    {
        public IndexerDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new IndexerDeclaration(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public FunctionParameter Node1 => Children[1] as FunctionParameter;
        public PropertyBody Node2 => Children[2] as PropertyBody;
    }

    // Original Rule: ((((TypeExpr+(("operator"+!(IdentifierChar))+WS))+OverloadableOperator)+FunctionParameterList)+FunctionBody)
    // Only Nodes: (TypeExpr+OverloadableOperator+FunctionParameterList+FunctionBody)
    public class OperatorDeclaration : AstNode
    {
        public OperatorDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new OperatorDeclaration(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public OverloadableOperator Node1 => Children[1] as OverloadableOperator;
        public FunctionParameterList Node2 => Children[2] as FunctionParameterList;
        public FunctionBody Node3 => Children[3] as FunctionBody;
    }

    // Original Rule: ((("implicit"+!(IdentifierChar))+WS)|(("explicit"+!(IdentifierChar))+WS))
    // Only Nodes: 
    public class ImplicitOrExplicit : AstNode
    {
        public ImplicitOrExplicit(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ImplicitOrExplicit(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((((TypeExpr+ImplicitOrExplicit)+(("operator"+!(IdentifierChar))+WS))+TypeExpr)+FunctionBody)
    // Only Nodes: (TypeExpr+ImplicitOrExplicit+TypeExpr+FunctionBody)
    public class ConverterDeclaration : AstNode
    {
        public ConverterDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ConverterDeclaration(Children.Select(f).ToArray());
        public TypeExpr Node0 => Children[0] as TypeExpr;
        public ImplicitOrExplicit Node1 => Children[1] as ImplicitOrExplicit;
        public TypeExpr Node2 => Children[2] as TypeExpr;
        public FunctionBody Node3 => Children[3] as FunctionBody;
    }

    // Original Rule: ((((((((DeclarationPreamble+ConstructorDeclaration)|MethodDeclaration)|FieldDeclaration)|OperatorDeclaration)|ConverterDeclaration)|TypeDeclaration)|IndexerDeclaration)|PropertyDeclaration)
    // Only Nodes: ((DeclarationPreamble+ConstructorDeclaration)|MethodDeclaration|FieldDeclaration|OperatorDeclaration|ConverterDeclaration|TypeDeclaration|IndexerDeclaration|PropertyDeclaration)
    public class MemberDeclaration : AstNode
    {
        public MemberDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new MemberDeclaration(Children.Select(f).ToArray());
        public AstSequence Node0 => Children[0] as AstSequence;
        public MethodDeclaration Node1 => Children[0] as MethodDeclaration;
        public FieldDeclaration Node2 => Children[0] as FieldDeclaration;
        public OperatorDeclaration Node3 => Children[0] as OperatorDeclaration;
        public ConverterDeclaration Node4 => Children[0] as ConverterDeclaration;
        public TypeDeclaration Node5 => Children[0] as TypeDeclaration;
        public IndexerDeclaration Node6 => Children[0] as IndexerDeclaration;
        public PropertyDeclaration Node7 => Children[0] as PropertyDeclaration;
    }

    // Original Rule: (((("namespace"+!(IdentifierChar))+WS)+QualifiedIdentifier)+((("{"+WS)+(TopDeclaration)*)+("}"+WS)))
    // Only Nodes: (QualifiedIdentifier+(TopDeclaration)*)
    public class NamespaceDeclaration : AstNode
    {
        public NamespaceDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new NamespaceDeclaration(Children.Select(f).ToArray());
        public QualifiedIdentifier Node0 => Children[0] as QualifiedIdentifier;
        public AstStar<TopDeclaration> Node1 => Children[1] as AstStar<TopDeclaration>;
    }

    // Original Rule: (((("namespace"+!(IdentifierChar))+WS)+QualifiedIdentifier)+EOS)
    // Only Nodes: QualifiedIdentifier
    public class FileScopedNamespace : AstNode
    {
        public FileScopedNamespace(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new FileScopedNamespace(Children.Select(f).ToArray());
        public QualifiedIdentifier Node0 => Children[0] as QualifiedIdentifier;
    }

    // Original Rule: (NamespaceDeclaration|TypeDeclarationWithPreamble)
    // Only Nodes: (NamespaceDeclaration|TypeDeclarationWithPreamble)
    public class TopDeclaration : AstNode
    {
        public TopDeclaration(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TopDeclaration(Children.Select(f).ToArray());
        public NamespaceDeclaration Node0 => Children[0] as NamespaceDeclaration;
        public TypeDeclarationWithPreamble Node1 => Children[0] as TypeDeclarationWithPreamble;
    }

    // Original Rule: (((UsingDirective)*+(FileScopedNamespace)?)+(TopDeclaration)*)
    // Only Nodes: ((UsingDirective)*+(FileScopedNamespace)?+(TopDeclaration)*)
    public class File : AstNode
    {
        public File(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new File(Children.Select(f).ToArray());
        public AstStar<UsingDirective> Node0 => Children[0] as AstStar<UsingDirective>;
        public FileScopedNamespace Node1 => Children[1] as FileScopedNamespace;
        public AstStar<TopDeclaration> Node2 => Children[2] as AstStar<TopDeclaration>;
    }

    // Original Rule: ((("["+WS)+(Comma)*)+("]"+WS))
    // Only Nodes: 
    public class ArrayRankSpecifier : AstNode
    {
        public ArrayRankSpecifier(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ArrayRankSpecifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (ArrayRankSpecifier)*
    // Only Nodes: (ArrayRankSpecifier)*
    public class ArrayRankSpecifiers : AstNode
    {
        public ArrayRankSpecifiers(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new ArrayRankSpecifiers(Children.Select(f).ToArray());
        public AstStar<ArrayRankSpecifier> Node0 => Children[0] as AstStar<ArrayRankSpecifier>;
    }

    // Original Rule: ((("<"+WS)+(((TypeExpr+WS)+(((Comma+TypeExpr)+WS))*))?)+(">"+WS))
    // Only Nodes: ((TypeExpr+(TypeExpr)*))?
    public class TypeArgList : AstNode
    {
        public TypeArgList(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeArgList(Children.Select(f).ToArray());
        public AstNode Node0 => Children[0] as AstNode;
    }

    // Original Rule: (("?"+WS))?
    // Only Nodes: 
    public class Nullable : AstNode
    {
        public Nullable(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new Nullable(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((QualifiedIdentifier+(TypeArgList)?)+ArrayRankSpecifiers)
    // Only Nodes: (QualifiedIdentifier+(TypeArgList)?+ArrayRankSpecifiers)
    public class TypeExpr : AstNode
    {
        public TypeExpr(params AstNode[] children) : base(children) { }
        public override AstNode Transform(Func<AstNode, AstNode> f) => new TypeExpr(Children.Select(f).ToArray());
        public QualifiedIdentifier Node0 => Children[0] as QualifiedIdentifier;
        public TypeArgList Node1 => Children[1] as TypeArgList;
        public ArrayRankSpecifiers Node2 => Children[2] as ArrayRankSpecifiers;
    }

    public static class AstNodeHelpers
    {
        public static AstNode ToNode(this ParseTree node)
        {
            switch (node.Type)
            {
                case "FloatLiteral": return new FloatLiteral(node.Contents);
                case "HexLiteral": return new HexLiteral(node.Contents);
                case "BinaryLiteral": return new BinaryLiteral(node.Contents);
                case "IntegerLiteral": return new IntegerLiteral(node.Contents);
                case "StringLiteral": return new StringLiteral(node.Contents);
                case "CharLiteral": return new CharLiteral(node.Contents);
                case "BooleanLiteral": return new BooleanLiteral(node.Contents);
                case "NullLiteral": return new NullLiteral(node.Contents);
                case "ValueLiteral": return new ValueLiteral(node.Contents);
                case "Literal": return new Literal(node.Children.Select(ToNode).ToArray());
                case "BinaryOperator": return new BinaryOperator(node.Contents);
                case "UnaryOperator": return new UnaryOperator(node.Contents);
                case "Indexer": return new Indexer(node.Children.Select(ToNode).ToArray());
                case "OverloadableOperator": return new OverloadableOperator(node.Contents);
                case "PostfixOperator": return new PostfixOperator(node.Children.Select(ToNode).ToArray());
                case "Identifier": return new Identifier(node.Contents);
                case "BinaryOperation": return new BinaryOperation(node.Children.Select(ToNode).ToArray());
                case "TernaryOperation": return new TernaryOperation(node.Children.Select(ToNode).ToArray());
                case "ParenthesizedExpression": return new ParenthesizedExpression(node.Children.Select(ToNode).ToArray());
                case "ThrowExpression": return new ThrowExpression(node.Children.Select(ToNode).ToArray());
                case "LambdaParameter": return new LambdaParameter(node.Children.Select(ToNode).ToArray());
                case "LambdaParameters": return new LambdaParameters(node.Children.Select(ToNode).ToArray());
                case "LambdaBody": return new LambdaBody(node.Children.Select(ToNode).ToArray());
                case "LambdaExpr": return new LambdaExpr(node.Children.Select(ToNode).ToArray());
                case "MemberAccess": return new MemberAccess(node.Children.Select(ToNode).ToArray());
                case "ConditionalMemberAccess": return new ConditionalMemberAccess(node.Children.Select(ToNode).ToArray());
                case "TypeOf": return new TypeOf(node.Children.Select(ToNode).ToArray());
                case "NameOf": return new NameOf(node.Children.Select(ToNode).ToArray());
                case "Default": return new Default(node.Children.Select(ToNode).ToArray());
                case "InitializerClause": return new InitializerClause(node.Children.Select(ToNode).ToArray());
                case "ArraySizeSpecifier": return new ArraySizeSpecifier(node.Children.Select(ToNode).ToArray());
                case "NewOperation": return new NewOperation(node.Children.Select(ToNode).ToArray());
                case "IsOperation": return new IsOperation(node.Children.Select(ToNode).ToArray());
                case "AsOperation": return new AsOperation(node.Children.Select(ToNode).ToArray());
                case "StringInterpolation": return new StringInterpolation(node.Children.Select(ToNode).ToArray());
                case "FunctionArgKeyword": return new FunctionArgKeyword(node.Contents);
                case "FunctionArg": return new FunctionArg(node.Children.Select(ToNode).ToArray());
                case "FunctionArgs": return new FunctionArgs(node.Children.Select(ToNode).ToArray());
                case "LeafExpression": return new LeafExpression(node.Children.Select(ToNode).ToArray());
                case "Expression": return new Expression(node.Children.Select(ToNode).ToArray());
                case "ExpressionStatement": return new ExpressionStatement(node.Children.Select(ToNode).ToArray());
                case "ElseClause": return new ElseClause(node.Children.Select(ToNode).ToArray());
                case "IfStatement": return new IfStatement(node.Children.Select(ToNode).ToArray());
                case "WhileStatement": return new WhileStatement(node.Children.Select(ToNode).ToArray());
                case "DoWhileStatement": return new DoWhileStatement(node.Children.Select(ToNode).ToArray());
                case "ReturnStatement": return new ReturnStatement(node.Children.Select(ToNode).ToArray());
                case "BreakStatement": return new BreakStatement(node.Contents);
                case "YieldStatement": return new YieldStatement(node.Children.Select(ToNode).ToArray());
                case "YieldBreakStatement": return new YieldBreakStatement(node.Contents);
                case "ContinueStatement": return new ContinueStatement(node.Contents);
                case "CompoundStatement": return new CompoundStatement(node.Children.Select(ToNode).ToArray());
                case "CatchClause": return new CatchClause(node.Children.Select(ToNode).ToArray());
                case "FinallyClause": return new FinallyClause(node.Children.Select(ToNode).ToArray());
                case "CaseClause": return new CaseClause(node.Children.Select(ToNode).ToArray());
                case "SwitchStatement": return new SwitchStatement(node.Children.Select(ToNode).ToArray());
                case "TryStatement": return new TryStatement(node.Children.Select(ToNode).ToArray());
                case "ForEachStatement": return new ForEachStatement(node.Children.Select(ToNode).ToArray());
                case "InitializationClause": return new InitializationClause(node.Children.Select(ToNode).ToArray());
                case "InvariantClause": return new InvariantClause(node.Children.Select(ToNode).ToArray());
                case "VariantClause": return new VariantClause(node.Children.Select(ToNode).ToArray());
                case "ForStatement": return new ForStatement(node.Children.Select(ToNode).ToArray());
                case "Initialization": return new Initialization(node.Children.Select(ToNode).ToArray());
                case "VarDecl": return new VarDecl(node.Children.Select(ToNode).ToArray());
                case "VarDeclStatement": return new VarDeclStatement(node.Children.Select(ToNode).ToArray());
                case "ThrowStatement": return new ThrowStatement(node.Children.Select(ToNode).ToArray());
                case "Statement": return new Statement(node.Children.Select(ToNode).ToArray());
                case "QualifiedIdentifier": return new QualifiedIdentifier(node.Children.Select(ToNode).ToArray());
                case "Static": return new Static(node.Contents);
                case "UsingDirective": return new UsingDirective(node.Children.Select(ToNode).ToArray());
                case "Modifier": return new Modifier(node.Contents);
                case "AccessSpecifier": return new AccessSpecifier(node.Contents);
                case "Attribute": return new Attribute(node.Children.Select(ToNode).ToArray());
                case "AttributeList": return new AttributeList(node.Children.Select(ToNode).ToArray());
                case "DeclarationPreamble": return new DeclarationPreamble(node.Children.Select(ToNode).ToArray());
                case "TypeVariance": return new TypeVariance(node.Contents);
                case "TypeParameter": return new TypeParameter(node.Children.Select(ToNode).ToArray());
                case "TypeParameterList": return new TypeParameterList(node.Children.Select(ToNode).ToArray());
                case "BaseClassList": return new BaseClassList(node.Children.Select(ToNode).ToArray());
                case "Constraint": return new Constraint(node.Children.Select(ToNode).ToArray());
                case "ConstraintClause": return new ConstraintClause(node.Children.Select(ToNode).ToArray());
                case "ConstraintList": return new ConstraintList(node.Children.Select(ToNode).ToArray());
                case "Kind": return new Kind(node.Contents);
                case "TypeDeclaration": return new TypeDeclaration(node.Children.Select(ToNode).ToArray());
                case "TypeDeclarationWithPreamble": return new TypeDeclarationWithPreamble(node.Children.Select(ToNode).ToArray());
                case "FunctionParameterKeywords": return new FunctionParameterKeywords(node.Contents);
                case "DefaultValue": return new DefaultValue(node.Children.Select(ToNode).ToArray());
                case "FunctionParameter": return new FunctionParameter(node.Children.Select(ToNode).ToArray());
                case "FunctionParameterList": return new FunctionParameterList(node.Children.Select(ToNode).ToArray());
                case "ExpressionBody": return new ExpressionBody(node.Children.Select(ToNode).ToArray());
                case "FunctionBody": return new FunctionBody(node.Children.Select(ToNode).ToArray());
                case "BaseCall": return new BaseCall(node.Children.Select(ToNode).ToArray());
                case "ThisCall": return new ThisCall(node.Children.Select(ToNode).ToArray());
                case "BaseOrThisCall": return new BaseOrThisCall(node.Children.Select(ToNode).ToArray());
                case "ConstructorDeclaration": return new ConstructorDeclaration(node.Children.Select(ToNode).ToArray());
                case "MethodDeclaration": return new MethodDeclaration(node.Children.Select(ToNode).ToArray());
                case "FieldDeclaration": return new FieldDeclaration(node.Children.Select(ToNode).ToArray());
                case "Getter": return new Getter(node.Children.Select(ToNode).ToArray());
                case "Setter": return new Setter(node.Children.Select(ToNode).ToArray());
                case "Initter": return new Initter(node.Children.Select(ToNode).ToArray());
                case "PropertyClauses": return new PropertyClauses(node.Children.Select(ToNode).ToArray());
                case "PropertyBody": return new PropertyBody(node.Children.Select(ToNode).ToArray());
                case "PropertyDeclaration": return new PropertyDeclaration(node.Children.Select(ToNode).ToArray());
                case "IndexerDeclaration": return new IndexerDeclaration(node.Children.Select(ToNode).ToArray());
                case "OperatorDeclaration": return new OperatorDeclaration(node.Children.Select(ToNode).ToArray());
                case "ImplicitOrExplicit": return new ImplicitOrExplicit(node.Contents);
                case "ConverterDeclaration": return new ConverterDeclaration(node.Children.Select(ToNode).ToArray());
                case "MemberDeclaration": return new MemberDeclaration(node.Children.Select(ToNode).ToArray());
                case "NamespaceDeclaration": return new NamespaceDeclaration(node.Children.Select(ToNode).ToArray());
                case "FileScopedNamespace": return new FileScopedNamespace(node.Children.Select(ToNode).ToArray());
                case "TopDeclaration": return new TopDeclaration(node.Children.Select(ToNode).ToArray());
                case "File": return new File(node.Children.Select(ToNode).ToArray());
                case "ArrayRankSpecifier": return new ArrayRankSpecifier(node.Contents);
                case "ArrayRankSpecifiers": return new ArrayRankSpecifiers(node.Children.Select(ToNode).ToArray());
                case "TypeArgList": return new TypeArgList(node.Children.Select(ToNode).ToArray());
                case "Nullable": return new Nullable(node.Contents);
                case "TypeExpr": return new TypeExpr(node.Children.Select(ToNode).ToArray());
                default:        throw new Exception($"Unrecognized parse node {node.Type}");
            }
        }
    }
}
