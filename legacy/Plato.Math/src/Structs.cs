
// AUTOGENERATED FILE: Do not edit directly, instead edit Structs.tt

using System;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace Plato.Math
{

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Vector2 
        : IEquatable< Vector2 >
        , IArray< float >    
        , IComparable< Vector2 >
    {
        [DataMember] public readonly float X;
        [DataMember] public readonly float Y;
        public Vector2((float x, float y) tuple) : this(tuple.x, tuple.y) { }
        public Vector2(float x, float y) { X = x; Y = y; }
        public static Vector2 Create(float x, float y) => new Vector2(x, y);
        public static Vector2 Create((float x, float y) tuple) => new Vector2(tuple);
        public override bool Equals(object obj) => obj is Vector2 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
        public override string ToString() => $"Vector2(X = {X}, Y = {Y})";
        public void Deconstruct(out float x, out float y) {x = X; y = Y; }
        public bool Equals(Vector2 x) => X == x.X && Y == x.Y;
        public static bool operator ==(Vector2 x0, Vector2 x1) => x0.Equals(x1);
        public static bool operator !=(Vector2 x0, Vector2 x1) => !x0.Equals(x1);
        public static implicit operator Vector2((float x, float y) tuple) => new Vector2(tuple);
        public static implicit operator (float x, float y)(Vector2 self) => (self.X, self.Y);
        public bool AlmostEquals(Vector2 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance);
        public static Vector2 Zero = new Vector2(default, default);
        public static Vector2 MinValue = new Vector2(float.MinValue, float.MinValue);
        public static Vector2 MaxValue = new Vector2(float.MaxValue, float.MaxValue);
        public Vector2 WithX(float x) => new Vector2(x, Y);
        public Vector2 WithY(float x) => new Vector2(X, x);
        public static Vector2 operator +(Vector2 value1, Vector2 value2) => new Vector2(value1.X + value2.X,value1.Y + value2.Y);
        public static Vector2 operator +(Vector2 value1, float value2) => new Vector2(value1.X + value2,value1.Y + value2);
        public static Vector2 operator +(float value1, Vector2 value2) => new Vector2(value1 + value2.X,value1 + value2.Y);
        public static Vector2 operator -(Vector2 value1, Vector2 value2) => new Vector2(value1.X - value2.X,value1.Y - value2.Y);
        public static Vector2 operator -(Vector2 value1, float value2) => new Vector2(value1.X - value2,value1.Y - value2);
        public static Vector2 operator -(float value1, Vector2 value2) => new Vector2(value1 - value2.X,value1 - value2.Y);
        public static Vector2 operator *(Vector2 value1, Vector2 value2) => new Vector2(value1.X * value2.X,value1.Y * value2.Y);
        public static Vector2 operator *(Vector2 value1, float value2) => new Vector2(value1.X * value2,value1.Y * value2);
        public static Vector2 operator *(float value1, Vector2 value2) => new Vector2(value1 * value2.X,value1 * value2.Y);
        public static Vector2 operator /(Vector2 value1, Vector2 value2) => new Vector2(value1.X / value2.X,value1.Y / value2.Y);
        public static Vector2 operator /(Vector2 value1, float value2) => new Vector2(value1.X / value2,value1.Y / value2);
        public static Vector2 operator /(float value1, Vector2 value2) => new Vector2(value1 / value2.X,value1 / value2.Y);
        public static Vector2 One = new Vector2(1f);
        public static Vector2 UnitX = Zero.WithX(1f);
        public static Vector2 UnitY = Zero.WithY(1f);
        public Vector2(float value) : this(value, value) { }
        public static Vector2 operator -(Vector2 value) => Zero - value;
        public static float Dot(Vector2 value1, Vector2 value2) => value1.X * value2.X + value1.Y * value2.Y;
        public float Dot(Vector2 value) => Vector2.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public float MinComponent() => (X).Min(Y);
        public float MaxComponent() => (X).Max(Y);
        public float SumComponents() => (X) + (Y);
        public float SumSqrComponents() => (X).Sqr() + (Y).Sqr();
        public float ProductComponents() => (X) * (Y);
        public float GetComponent(int n) => n == 0 ? X:Y;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 2;
        public int Count => NumComponents;
        public float this[int n] => n == 0 ? X : n == 1 ? Y : throw new ArgumentOutOfRangeException("n");
        public IIterator< float > Iterator => new ArrayIterator< float >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity();
        public int CompareTo(Vector2 x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Vector2 x0, Vector2 x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Vector2 x0, Vector2 x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Vector2 x0, Vector2 x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Vector2 x0, Vector2 x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Vector3 
        : IEquatable< Vector3 >
        , IArray< float >    
        , IComparable< Vector3 >
    {
        [DataMember] public readonly float X;
        [DataMember] public readonly float Y;
        [DataMember] public readonly float Z;
        public Vector3((float x, float y, float z) tuple) : this(tuple.x, tuple.y, tuple.z) { }
        public Vector3(float x, float y, float z) { X = x; Y = y; Z = z; }
        public static Vector3 Create(float x, float y, float z) => new Vector3(x, y, z);
        public static Vector3 Create((float x, float y, float z) tuple) => new Vector3(tuple);
        public override bool Equals(object obj) => obj is Vector3 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
        public override string ToString() => $"Vector3(X = {X}, Y = {Y}, Z = {Z})";
        public void Deconstruct(out float x, out float y, out float z) {x = X; y = Y; z = Z; }
        public bool Equals(Vector3 x) => X == x.X && Y == x.Y && Z == x.Z;
        public static bool operator ==(Vector3 x0, Vector3 x1) => x0.Equals(x1);
        public static bool operator !=(Vector3 x0, Vector3 x1) => !x0.Equals(x1);
        public static implicit operator Vector3((float x, float y, float z) tuple) => new Vector3(tuple);
        public static implicit operator (float x, float y, float z)(Vector3 self) => (self.X, self.Y, self.Z);
        public bool AlmostEquals(Vector3 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance);
        public static Vector3 Zero = new Vector3(default, default, default);
        public static Vector3 MinValue = new Vector3(float.MinValue, float.MinValue, float.MinValue);
        public static Vector3 MaxValue = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
        public Vector3 WithX(float x) => new Vector3(x, Y, Z);
        public Vector3 WithY(float x) => new Vector3(X, x, Z);
        public Vector3 WithZ(float x) => new Vector3(X, Y, x);
        public static Vector3 operator +(Vector3 value1, Vector3 value2) => new Vector3(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z);
        public static Vector3 operator +(Vector3 value1, float value2) => new Vector3(value1.X + value2,value1.Y + value2,value1.Z + value2);
        public static Vector3 operator +(float value1, Vector3 value2) => new Vector3(value1 + value2.X,value1 + value2.Y,value1 + value2.Z);
        public static Vector3 operator -(Vector3 value1, Vector3 value2) => new Vector3(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z);
        public static Vector3 operator -(Vector3 value1, float value2) => new Vector3(value1.X - value2,value1.Y - value2,value1.Z - value2);
        public static Vector3 operator -(float value1, Vector3 value2) => new Vector3(value1 - value2.X,value1 - value2.Y,value1 - value2.Z);
        public static Vector3 operator *(Vector3 value1, Vector3 value2) => new Vector3(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z);
        public static Vector3 operator *(Vector3 value1, float value2) => new Vector3(value1.X * value2,value1.Y * value2,value1.Z * value2);
        public static Vector3 operator *(float value1, Vector3 value2) => new Vector3(value1 * value2.X,value1 * value2.Y,value1 * value2.Z);
        public static Vector3 operator /(Vector3 value1, Vector3 value2) => new Vector3(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z);
        public static Vector3 operator /(Vector3 value1, float value2) => new Vector3(value1.X / value2,value1.Y / value2,value1.Z / value2);
        public static Vector3 operator /(float value1, Vector3 value2) => new Vector3(value1 / value2.X,value1 / value2.Y,value1 / value2.Z);
        public static Vector3 One = new Vector3(1f);
        public static Vector3 UnitX = Zero.WithX(1f);
        public static Vector3 UnitY = Zero.WithY(1f);
        public static Vector3 UnitZ = Zero.WithZ(1f);
        public Vector3(float value) : this(value, value, value) { }
        public static Vector3 operator -(Vector3 value) => Zero - value;
        public static float Dot(Vector3 value1, Vector3 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z;
        public float Dot(Vector3 value) => Vector3.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public float MinComponent() => (X).Min(Y).Min(Z);
        public float MaxComponent() => (X).Max(Y).Max(Z);
        public float SumComponents() => (X) + (Y) + (Z);
        public float SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr();
        public float ProductComponents() => (X) * (Y) * (Z);
        public float GetComponent(int n) => n == 0 ? X : n == 1 ? Y:Z;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 3;
        public int Count => NumComponents;
        public float this[int n] => n == 0 ? X : n == 1 ? Y : n == 2 ? Z : throw new ArgumentOutOfRangeException("n");
        public IIterator< float > Iterator => new ArrayIterator< float >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity();
        public int CompareTo(Vector3 x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Vector3 x0, Vector3 x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Vector3 x0, Vector3 x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Vector3 x0, Vector3 x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Vector3 x0, Vector3 x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Vector4 
        : IEquatable< Vector4 >
        , IArray< float >    
        , IComparable< Vector4 >
    {
        [DataMember] public readonly float X;
        [DataMember] public readonly float Y;
        [DataMember] public readonly float Z;
        [DataMember] public readonly float W;
        public Vector4((float x, float y, float z, float w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) { }
        public Vector4(float x, float y, float z, float w) { X = x; Y = y; Z = z; W = w; }
        public static Vector4 Create(float x, float y, float z, float w) => new Vector4(x, y, z, w);
        public static Vector4 Create((float x, float y, float z, float w) tuple) => new Vector4(tuple);
        public override bool Equals(object obj) => obj is Vector4 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        public override string ToString() => $"Vector4(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        public void Deconstruct(out float x, out float y, out float z, out float w) {x = X; y = Y; z = Z; w = W; }
        public bool Equals(Vector4 x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        public static bool operator ==(Vector4 x0, Vector4 x1) => x0.Equals(x1);
        public static bool operator !=(Vector4 x0, Vector4 x1) => !x0.Equals(x1);
        public static implicit operator Vector4((float x, float y, float z, float w) tuple) => new Vector4(tuple);
        public static implicit operator (float x, float y, float z, float w)(Vector4 self) => (self.X, self.Y, self.Z, self.W);
        public bool AlmostEquals(Vector4 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance) && W.AlmostEquals(x.W, tolerance);
        public static Vector4 Zero = new Vector4(default, default, default, default);
        public static Vector4 MinValue = new Vector4(float.MinValue, float.MinValue, float.MinValue, float.MinValue);
        public static Vector4 MaxValue = new Vector4(float.MaxValue, float.MaxValue, float.MaxValue, float.MaxValue);
        public Vector4 WithX(float x) => new Vector4(x, Y, Z, W);
        public Vector4 WithY(float x) => new Vector4(X, x, Z, W);
        public Vector4 WithZ(float x) => new Vector4(X, Y, x, W);
        public Vector4 WithW(float x) => new Vector4(X, Y, Z, x);
        public static Vector4 operator +(Vector4 value1, Vector4 value2) => new Vector4(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z,value1.W + value2.W);
        public static Vector4 operator +(Vector4 value1, float value2) => new Vector4(value1.X + value2,value1.Y + value2,value1.Z + value2,value1.W + value2);
        public static Vector4 operator +(float value1, Vector4 value2) => new Vector4(value1 + value2.X,value1 + value2.Y,value1 + value2.Z,value1 + value2.W);
        public static Vector4 operator -(Vector4 value1, Vector4 value2) => new Vector4(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z,value1.W - value2.W);
        public static Vector4 operator -(Vector4 value1, float value2) => new Vector4(value1.X - value2,value1.Y - value2,value1.Z - value2,value1.W - value2);
        public static Vector4 operator -(float value1, Vector4 value2) => new Vector4(value1 - value2.X,value1 - value2.Y,value1 - value2.Z,value1 - value2.W);
        public static Vector4 operator *(Vector4 value1, Vector4 value2) => new Vector4(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z,value1.W * value2.W);
        public static Vector4 operator *(Vector4 value1, float value2) => new Vector4(value1.X * value2,value1.Y * value2,value1.Z * value2,value1.W * value2);
        public static Vector4 operator *(float value1, Vector4 value2) => new Vector4(value1 * value2.X,value1 * value2.Y,value1 * value2.Z,value1 * value2.W);
        public static Vector4 operator /(Vector4 value1, Vector4 value2) => new Vector4(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z,value1.W / value2.W);
        public static Vector4 operator /(Vector4 value1, float value2) => new Vector4(value1.X / value2,value1.Y / value2,value1.Z / value2,value1.W / value2);
        public static Vector4 operator /(float value1, Vector4 value2) => new Vector4(value1 / value2.X,value1 / value2.Y,value1 / value2.Z,value1 / value2.W);
        public static Vector4 One = new Vector4(1f);
        public static Vector4 UnitX = Zero.WithX(1f);
        public static Vector4 UnitY = Zero.WithY(1f);
        public static Vector4 UnitZ = Zero.WithZ(1f);
        public static Vector4 UnitW = Zero.WithW(1f);
        public Vector4(float value) : this(value, value, value, value) { }
        public static Vector4 operator -(Vector4 value) => Zero - value;
        public static float Dot(Vector4 value1, Vector4 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z + value1.W * value2.W;
        public float Dot(Vector4 value) => Vector4.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance && W.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public float MinComponent() => (X).Min(Y).Min(Z).Min(W);
        public float MaxComponent() => (X).Max(Y).Max(Z).Max(W);
        public float SumComponents() => (X) + (Y) + (Z) + (W);
        public float SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr() + (W).Sqr();
        public float ProductComponents() => (X) * (Y) * (Z) * (W);
        public float GetComponent(int n) => n == 0 ? X : n == 1 ? Y : n == 2 ? Z:W;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 4;
        public int Count => NumComponents;
        public float this[int n] => n == 0 ? X : n == 1 ? Y : n == 2 ? Z : n == 3 ? W : throw new ArgumentOutOfRangeException("n");
        public IIterator< float > Iterator => new ArrayIterator< float >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN() || W.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity() || W.IsInfinity();
        public int CompareTo(Vector4 x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Vector4 x0, Vector4 x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Vector4 x0, Vector4 x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Vector4 x0, Vector4 x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Vector4 x0, Vector4 x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DVector2 
        : IEquatable< DVector2 >
        , IArray< double >    
        , IComparable< DVector2 >
    {
        [DataMember] public readonly double X;
        [DataMember] public readonly double Y;
        public DVector2((double x, double y) tuple) : this(tuple.x, tuple.y) { }
        public DVector2(double x, double y) { X = x; Y = y; }
        public static DVector2 Create(double x, double y) => new DVector2(x, y);
        public static DVector2 Create((double x, double y) tuple) => new DVector2(tuple);
        public override bool Equals(object obj) => obj is DVector2 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
        public override string ToString() => $"DVector2(X = {X}, Y = {Y})";
        public void Deconstruct(out double x, out double y) {x = X; y = Y; }
        public bool Equals(DVector2 x) => X == x.X && Y == x.Y;
        public static bool operator ==(DVector2 x0, DVector2 x1) => x0.Equals(x1);
        public static bool operator !=(DVector2 x0, DVector2 x1) => !x0.Equals(x1);
        public static implicit operator DVector2((double x, double y) tuple) => new DVector2(tuple);
        public static implicit operator (double x, double y)(DVector2 self) => (self.X, self.Y);
        public bool AlmostEquals(DVector2 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance);
        public static DVector2 Zero = new DVector2(default, default);
        public static DVector2 MinValue = new DVector2(double.MinValue, double.MinValue);
        public static DVector2 MaxValue = new DVector2(double.MaxValue, double.MaxValue);
        public DVector2 WithX(double x) => new DVector2(x, Y);
        public DVector2 WithY(double x) => new DVector2(X, x);
        public static DVector2 operator +(DVector2 value1, DVector2 value2) => new DVector2(value1.X + value2.X,value1.Y + value2.Y);
        public static DVector2 operator +(DVector2 value1, double value2) => new DVector2(value1.X + value2,value1.Y + value2);
        public static DVector2 operator +(double value1, DVector2 value2) => new DVector2(value1 + value2.X,value1 + value2.Y);
        public static DVector2 operator -(DVector2 value1, DVector2 value2) => new DVector2(value1.X - value2.X,value1.Y - value2.Y);
        public static DVector2 operator -(DVector2 value1, double value2) => new DVector2(value1.X - value2,value1.Y - value2);
        public static DVector2 operator -(double value1, DVector2 value2) => new DVector2(value1 - value2.X,value1 - value2.Y);
        public static DVector2 operator *(DVector2 value1, DVector2 value2) => new DVector2(value1.X * value2.X,value1.Y * value2.Y);
        public static DVector2 operator *(DVector2 value1, double value2) => new DVector2(value1.X * value2,value1.Y * value2);
        public static DVector2 operator *(double value1, DVector2 value2) => new DVector2(value1 * value2.X,value1 * value2.Y);
        public static DVector2 operator /(DVector2 value1, DVector2 value2) => new DVector2(value1.X / value2.X,value1.Y / value2.Y);
        public static DVector2 operator /(DVector2 value1, double value2) => new DVector2(value1.X / value2,value1.Y / value2);
        public static DVector2 operator /(double value1, DVector2 value2) => new DVector2(value1 / value2.X,value1 / value2.Y);
        public static DVector2 One = new DVector2(1.0);
        public static DVector2 UnitX = Zero.WithX(1.0);
        public static DVector2 UnitY = Zero.WithY(1.0);
        public DVector2(double value) : this(value, value) { }
        public static DVector2 operator -(DVector2 value) => Zero - value;
        public static double Dot(DVector2 value1, DVector2 value2) => value1.X * value2.X + value1.Y * value2.Y;
        public double Dot(DVector2 value) => DVector2.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public double MinComponent() => (X).Min(Y);
        public double MaxComponent() => (X).Max(Y);
        public double SumComponents() => (X) + (Y);
        public double SumSqrComponents() => (X).Sqr() + (Y).Sqr();
        public double ProductComponents() => (X) * (Y);
        public double GetComponent(int n) => n == 0 ? X:Y;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 2;
        public int Count => NumComponents;
        public double this[int n] => n == 0 ? X : n == 1 ? Y : throw new ArgumentOutOfRangeException("n");
        public IIterator< double > Iterator => new ArrayIterator< double >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity();
        public int CompareTo(DVector2 x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(DVector2 x0, DVector2 x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(DVector2 x0, DVector2 x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(DVector2 x0, DVector2 x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(DVector2 x0, DVector2 x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DVector3 
        : IEquatable< DVector3 >
        , IArray< double >    
        , IComparable< DVector3 >
    {
        [DataMember] public readonly double X;
        [DataMember] public readonly double Y;
        [DataMember] public readonly double Z;
        public DVector3((double x, double y, double z) tuple) : this(tuple.x, tuple.y, tuple.z) { }
        public DVector3(double x, double y, double z) { X = x; Y = y; Z = z; }
        public static DVector3 Create(double x, double y, double z) => new DVector3(x, y, z);
        public static DVector3 Create((double x, double y, double z) tuple) => new DVector3(tuple);
        public override bool Equals(object obj) => obj is DVector3 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
        public override string ToString() => $"DVector3(X = {X}, Y = {Y}, Z = {Z})";
        public void Deconstruct(out double x, out double y, out double z) {x = X; y = Y; z = Z; }
        public bool Equals(DVector3 x) => X == x.X && Y == x.Y && Z == x.Z;
        public static bool operator ==(DVector3 x0, DVector3 x1) => x0.Equals(x1);
        public static bool operator !=(DVector3 x0, DVector3 x1) => !x0.Equals(x1);
        public static implicit operator DVector3((double x, double y, double z) tuple) => new DVector3(tuple);
        public static implicit operator (double x, double y, double z)(DVector3 self) => (self.X, self.Y, self.Z);
        public bool AlmostEquals(DVector3 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance);
        public static DVector3 Zero = new DVector3(default, default, default);
        public static DVector3 MinValue = new DVector3(double.MinValue, double.MinValue, double.MinValue);
        public static DVector3 MaxValue = new DVector3(double.MaxValue, double.MaxValue, double.MaxValue);
        public DVector3 WithX(double x) => new DVector3(x, Y, Z);
        public DVector3 WithY(double x) => new DVector3(X, x, Z);
        public DVector3 WithZ(double x) => new DVector3(X, Y, x);
        public static DVector3 operator +(DVector3 value1, DVector3 value2) => new DVector3(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z);
        public static DVector3 operator +(DVector3 value1, double value2) => new DVector3(value1.X + value2,value1.Y + value2,value1.Z + value2);
        public static DVector3 operator +(double value1, DVector3 value2) => new DVector3(value1 + value2.X,value1 + value2.Y,value1 + value2.Z);
        public static DVector3 operator -(DVector3 value1, DVector3 value2) => new DVector3(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z);
        public static DVector3 operator -(DVector3 value1, double value2) => new DVector3(value1.X - value2,value1.Y - value2,value1.Z - value2);
        public static DVector3 operator -(double value1, DVector3 value2) => new DVector3(value1 - value2.X,value1 - value2.Y,value1 - value2.Z);
        public static DVector3 operator *(DVector3 value1, DVector3 value2) => new DVector3(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z);
        public static DVector3 operator *(DVector3 value1, double value2) => new DVector3(value1.X * value2,value1.Y * value2,value1.Z * value2);
        public static DVector3 operator *(double value1, DVector3 value2) => new DVector3(value1 * value2.X,value1 * value2.Y,value1 * value2.Z);
        public static DVector3 operator /(DVector3 value1, DVector3 value2) => new DVector3(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z);
        public static DVector3 operator /(DVector3 value1, double value2) => new DVector3(value1.X / value2,value1.Y / value2,value1.Z / value2);
        public static DVector3 operator /(double value1, DVector3 value2) => new DVector3(value1 / value2.X,value1 / value2.Y,value1 / value2.Z);
        public static DVector3 One = new DVector3(1.0);
        public static DVector3 UnitX = Zero.WithX(1.0);
        public static DVector3 UnitY = Zero.WithY(1.0);
        public static DVector3 UnitZ = Zero.WithZ(1.0);
        public DVector3(double value) : this(value, value, value) { }
        public static DVector3 operator -(DVector3 value) => Zero - value;
        public static double Dot(DVector3 value1, DVector3 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z;
        public double Dot(DVector3 value) => DVector3.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public double MinComponent() => (X).Min(Y).Min(Z);
        public double MaxComponent() => (X).Max(Y).Max(Z);
        public double SumComponents() => (X) + (Y) + (Z);
        public double SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr();
        public double ProductComponents() => (X) * (Y) * (Z);
        public double GetComponent(int n) => n == 0 ? X : n == 1 ? Y:Z;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 3;
        public int Count => NumComponents;
        public double this[int n] => n == 0 ? X : n == 1 ? Y : n == 2 ? Z : throw new ArgumentOutOfRangeException("n");
        public IIterator< double > Iterator => new ArrayIterator< double >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity();
        public int CompareTo(DVector3 x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(DVector3 x0, DVector3 x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(DVector3 x0, DVector3 x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(DVector3 x0, DVector3 x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(DVector3 x0, DVector3 x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DVector4 
        : IEquatable< DVector4 >
        , IArray< double >    
        , IComparable< DVector4 >
    {
        [DataMember] public readonly double X;
        [DataMember] public readonly double Y;
        [DataMember] public readonly double Z;
        [DataMember] public readonly double W;
        public DVector4((double x, double y, double z, double w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) { }
        public DVector4(double x, double y, double z, double w) { X = x; Y = y; Z = z; W = w; }
        public static DVector4 Create(double x, double y, double z, double w) => new DVector4(x, y, z, w);
        public static DVector4 Create((double x, double y, double z, double w) tuple) => new DVector4(tuple);
        public override bool Equals(object obj) => obj is DVector4 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        public override string ToString() => $"DVector4(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        public void Deconstruct(out double x, out double y, out double z, out double w) {x = X; y = Y; z = Z; w = W; }
        public bool Equals(DVector4 x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        public static bool operator ==(DVector4 x0, DVector4 x1) => x0.Equals(x1);
        public static bool operator !=(DVector4 x0, DVector4 x1) => !x0.Equals(x1);
        public static implicit operator DVector4((double x, double y, double z, double w) tuple) => new DVector4(tuple);
        public static implicit operator (double x, double y, double z, double w)(DVector4 self) => (self.X, self.Y, self.Z, self.W);
        public bool AlmostEquals(DVector4 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance) && W.AlmostEquals(x.W, tolerance);
        public static DVector4 Zero = new DVector4(default, default, default, default);
        public static DVector4 MinValue = new DVector4(double.MinValue, double.MinValue, double.MinValue, double.MinValue);
        public static DVector4 MaxValue = new DVector4(double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue);
        public DVector4 WithX(double x) => new DVector4(x, Y, Z, W);
        public DVector4 WithY(double x) => new DVector4(X, x, Z, W);
        public DVector4 WithZ(double x) => new DVector4(X, Y, x, W);
        public DVector4 WithW(double x) => new DVector4(X, Y, Z, x);
        public static DVector4 operator +(DVector4 value1, DVector4 value2) => new DVector4(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z,value1.W + value2.W);
        public static DVector4 operator +(DVector4 value1, double value2) => new DVector4(value1.X + value2,value1.Y + value2,value1.Z + value2,value1.W + value2);
        public static DVector4 operator +(double value1, DVector4 value2) => new DVector4(value1 + value2.X,value1 + value2.Y,value1 + value2.Z,value1 + value2.W);
        public static DVector4 operator -(DVector4 value1, DVector4 value2) => new DVector4(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z,value1.W - value2.W);
        public static DVector4 operator -(DVector4 value1, double value2) => new DVector4(value1.X - value2,value1.Y - value2,value1.Z - value2,value1.W - value2);
        public static DVector4 operator -(double value1, DVector4 value2) => new DVector4(value1 - value2.X,value1 - value2.Y,value1 - value2.Z,value1 - value2.W);
        public static DVector4 operator *(DVector4 value1, DVector4 value2) => new DVector4(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z,value1.W * value2.W);
        public static DVector4 operator *(DVector4 value1, double value2) => new DVector4(value1.X * value2,value1.Y * value2,value1.Z * value2,value1.W * value2);
        public static DVector4 operator *(double value1, DVector4 value2) => new DVector4(value1 * value2.X,value1 * value2.Y,value1 * value2.Z,value1 * value2.W);
        public static DVector4 operator /(DVector4 value1, DVector4 value2) => new DVector4(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z,value1.W / value2.W);
        public static DVector4 operator /(DVector4 value1, double value2) => new DVector4(value1.X / value2,value1.Y / value2,value1.Z / value2,value1.W / value2);
        public static DVector4 operator /(double value1, DVector4 value2) => new DVector4(value1 / value2.X,value1 / value2.Y,value1 / value2.Z,value1 / value2.W);
        public static DVector4 One = new DVector4(1.0);
        public static DVector4 UnitX = Zero.WithX(1.0);
        public static DVector4 UnitY = Zero.WithY(1.0);
        public static DVector4 UnitZ = Zero.WithZ(1.0);
        public static DVector4 UnitW = Zero.WithW(1.0);
        public DVector4(double value) : this(value, value, value, value) { }
        public static DVector4 operator -(DVector4 value) => Zero - value;
        public static double Dot(DVector4 value1, DVector4 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z + value1.W * value2.W;
        public double Dot(DVector4 value) => DVector4.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance && W.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public double MinComponent() => (X).Min(Y).Min(Z).Min(W);
        public double MaxComponent() => (X).Max(Y).Max(Z).Max(W);
        public double SumComponents() => (X) + (Y) + (Z) + (W);
        public double SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr() + (W).Sqr();
        public double ProductComponents() => (X) * (Y) * (Z) * (W);
        public double GetComponent(int n) => n == 0 ? X : n == 1 ? Y : n == 2 ? Z:W;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 4;
        public int Count => NumComponents;
        public double this[int n] => n == 0 ? X : n == 1 ? Y : n == 2 ? Z : n == 3 ? W : throw new ArgumentOutOfRangeException("n");
        public IIterator< double > Iterator => new ArrayIterator< double >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN() || W.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity() || W.IsInfinity();
        public int CompareTo(DVector4 x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(DVector4 x0, DVector4 x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(DVector4 x0, DVector4 x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(DVector4 x0, DVector4 x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(DVector4 x0, DVector4 x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Int2 
        : IEquatable< Int2 >
        , IArray< int >    
        , IComparable< Int2 >
    {
        [DataMember] public readonly int X;
        [DataMember] public readonly int Y;
        public Int2((int x, int y) tuple) : this(tuple.x, tuple.y) { }
        public Int2(int x, int y) { X = x; Y = y; }
        public static Int2 Create(int x, int y) => new Int2(x, y);
        public static Int2 Create((int x, int y) tuple) => new Int2(tuple);
        public override bool Equals(object obj) => obj is Int2 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
        public override string ToString() => $"Int2(X = {X}, Y = {Y})";
        public void Deconstruct(out int x, out int y) {x = X; y = Y; }
        public bool Equals(Int2 x) => X == x.X && Y == x.Y;
        public static bool operator ==(Int2 x0, Int2 x1) => x0.Equals(x1);
        public static bool operator !=(Int2 x0, Int2 x1) => !x0.Equals(x1);
        public static implicit operator Int2((int x, int y) tuple) => new Int2(tuple);
        public static implicit operator (int x, int y)(Int2 self) => (self.X, self.Y);
        public static Int2 Zero = new Int2(default, default);
        public static Int2 MinValue = new Int2(int.MinValue, int.MinValue);
        public static Int2 MaxValue = new Int2(int.MaxValue, int.MaxValue);
        public Int2 WithX(int x) => new Int2(x, Y);
        public Int2 WithY(int x) => new Int2(X, x);
        public static Int2 operator +(Int2 value1, Int2 value2) => new Int2(value1.X + value2.X,value1.Y + value2.Y);
        public static Int2 operator +(Int2 value1, int value2) => new Int2(value1.X + value2,value1.Y + value2);
        public static Int2 operator +(int value1, Int2 value2) => new Int2(value1 + value2.X,value1 + value2.Y);
        public static Int2 operator -(Int2 value1, Int2 value2) => new Int2(value1.X - value2.X,value1.Y - value2.Y);
        public static Int2 operator -(Int2 value1, int value2) => new Int2(value1.X - value2,value1.Y - value2);
        public static Int2 operator -(int value1, Int2 value2) => new Int2(value1 - value2.X,value1 - value2.Y);
        public static Int2 operator *(Int2 value1, Int2 value2) => new Int2(value1.X * value2.X,value1.Y * value2.Y);
        public static Int2 operator *(Int2 value1, int value2) => new Int2(value1.X * value2,value1.Y * value2);
        public static Int2 operator *(int value1, Int2 value2) => new Int2(value1 * value2.X,value1 * value2.Y);
        public static Int2 operator /(Int2 value1, Int2 value2) => new Int2(value1.X / value2.X,value1.Y / value2.Y);
        public static Int2 operator /(Int2 value1, int value2) => new Int2(value1.X / value2,value1.Y / value2);
        public static Int2 operator /(int value1, Int2 value2) => new Int2(value1 / value2.X,value1 / value2.Y);
        public static Int2 One = new Int2(1);
        public static Int2 UnitX = Zero.WithX(1);
        public static Int2 UnitY = Zero.WithY(1);
        public Int2(int value) : this(value, value) { }
        public static Int2 operator -(Int2 value) => Zero - value;
        public static int Dot(Int2 value1, Int2 value2) => value1.X * value2.X + value1.Y * value2.Y;
        public int Dot(Int2 value) => Int2.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public int MinComponent() => (X).Min(Y);
        public int MaxComponent() => (X).Max(Y);
        public int SumComponents() => (X) + (Y);
        public int SumSqrComponents() => (X).Sqr() + (Y).Sqr();
        public int ProductComponents() => (X) * (Y);
        public int GetComponent(int n) => n == 0 ? X:Y;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 2;
        public int Count => NumComponents;
        public int this[int n] => n == 0 ? X : n == 1 ? Y : throw new ArgumentOutOfRangeException("n");
        public IIterator< int > Iterator => new ArrayIterator< int >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity();
        public int CompareTo(Int2 x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Int2 x0, Int2 x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Int2 x0, Int2 x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Int2 x0, Int2 x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Int2 x0, Int2 x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Int3 
        : IEquatable< Int3 >
        , IArray< int >    
        , IComparable< Int3 >
    {
        [DataMember] public readonly int X;
        [DataMember] public readonly int Y;
        [DataMember] public readonly int Z;
        public Int3((int x, int y, int z) tuple) : this(tuple.x, tuple.y, tuple.z) { }
        public Int3(int x, int y, int z) { X = x; Y = y; Z = z; }
        public static Int3 Create(int x, int y, int z) => new Int3(x, y, z);
        public static Int3 Create((int x, int y, int z) tuple) => new Int3(tuple);
        public override bool Equals(object obj) => obj is Int3 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
        public override string ToString() => $"Int3(X = {X}, Y = {Y}, Z = {Z})";
        public void Deconstruct(out int x, out int y, out int z) {x = X; y = Y; z = Z; }
        public bool Equals(Int3 x) => X == x.X && Y == x.Y && Z == x.Z;
        public static bool operator ==(Int3 x0, Int3 x1) => x0.Equals(x1);
        public static bool operator !=(Int3 x0, Int3 x1) => !x0.Equals(x1);
        public static implicit operator Int3((int x, int y, int z) tuple) => new Int3(tuple);
        public static implicit operator (int x, int y, int z)(Int3 self) => (self.X, self.Y, self.Z);
        public static Int3 Zero = new Int3(default, default, default);
        public static Int3 MinValue = new Int3(int.MinValue, int.MinValue, int.MinValue);
        public static Int3 MaxValue = new Int3(int.MaxValue, int.MaxValue, int.MaxValue);
        public Int3 WithX(int x) => new Int3(x, Y, Z);
        public Int3 WithY(int x) => new Int3(X, x, Z);
        public Int3 WithZ(int x) => new Int3(X, Y, x);
        public static Int3 operator +(Int3 value1, Int3 value2) => new Int3(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z);
        public static Int3 operator +(Int3 value1, int value2) => new Int3(value1.X + value2,value1.Y + value2,value1.Z + value2);
        public static Int3 operator +(int value1, Int3 value2) => new Int3(value1 + value2.X,value1 + value2.Y,value1 + value2.Z);
        public static Int3 operator -(Int3 value1, Int3 value2) => new Int3(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z);
        public static Int3 operator -(Int3 value1, int value2) => new Int3(value1.X - value2,value1.Y - value2,value1.Z - value2);
        public static Int3 operator -(int value1, Int3 value2) => new Int3(value1 - value2.X,value1 - value2.Y,value1 - value2.Z);
        public static Int3 operator *(Int3 value1, Int3 value2) => new Int3(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z);
        public static Int3 operator *(Int3 value1, int value2) => new Int3(value1.X * value2,value1.Y * value2,value1.Z * value2);
        public static Int3 operator *(int value1, Int3 value2) => new Int3(value1 * value2.X,value1 * value2.Y,value1 * value2.Z);
        public static Int3 operator /(Int3 value1, Int3 value2) => new Int3(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z);
        public static Int3 operator /(Int3 value1, int value2) => new Int3(value1.X / value2,value1.Y / value2,value1.Z / value2);
        public static Int3 operator /(int value1, Int3 value2) => new Int3(value1 / value2.X,value1 / value2.Y,value1 / value2.Z);
        public static Int3 One = new Int3(1);
        public static Int3 UnitX = Zero.WithX(1);
        public static Int3 UnitY = Zero.WithY(1);
        public static Int3 UnitZ = Zero.WithZ(1);
        public Int3(int value) : this(value, value, value) { }
        public static Int3 operator -(Int3 value) => Zero - value;
        public static int Dot(Int3 value1, Int3 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z;
        public int Dot(Int3 value) => Int3.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public int MinComponent() => (X).Min(Y).Min(Z);
        public int MaxComponent() => (X).Max(Y).Max(Z);
        public int SumComponents() => (X) + (Y) + (Z);
        public int SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr();
        public int ProductComponents() => (X) * (Y) * (Z);
        public int GetComponent(int n) => n == 0 ? X : n == 1 ? Y:Z;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 3;
        public int Count => NumComponents;
        public int this[int n] => n == 0 ? X : n == 1 ? Y : n == 2 ? Z : throw new ArgumentOutOfRangeException("n");
        public IIterator< int > Iterator => new ArrayIterator< int >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity();
        public int CompareTo(Int3 x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Int3 x0, Int3 x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Int3 x0, Int3 x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Int3 x0, Int3 x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Int3 x0, Int3 x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Int4 
        : IEquatable< Int4 >
        , IArray< int >    
        , IComparable< Int4 >
    {
        [DataMember] public readonly int X;
        [DataMember] public readonly int Y;
        [DataMember] public readonly int Z;
        [DataMember] public readonly int W;
        public Int4((int x, int y, int z, int w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) { }
        public Int4(int x, int y, int z, int w) { X = x; Y = y; Z = z; W = w; }
        public static Int4 Create(int x, int y, int z, int w) => new Int4(x, y, z, w);
        public static Int4 Create((int x, int y, int z, int w) tuple) => new Int4(tuple);
        public override bool Equals(object obj) => obj is Int4 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        public override string ToString() => $"Int4(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        public void Deconstruct(out int x, out int y, out int z, out int w) {x = X; y = Y; z = Z; w = W; }
        public bool Equals(Int4 x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        public static bool operator ==(Int4 x0, Int4 x1) => x0.Equals(x1);
        public static bool operator !=(Int4 x0, Int4 x1) => !x0.Equals(x1);
        public static implicit operator Int4((int x, int y, int z, int w) tuple) => new Int4(tuple);
        public static implicit operator (int x, int y, int z, int w)(Int4 self) => (self.X, self.Y, self.Z, self.W);
        public static Int4 Zero = new Int4(default, default, default, default);
        public static Int4 MinValue = new Int4(int.MinValue, int.MinValue, int.MinValue, int.MinValue);
        public static Int4 MaxValue = new Int4(int.MaxValue, int.MaxValue, int.MaxValue, int.MaxValue);
        public Int4 WithX(int x) => new Int4(x, Y, Z, W);
        public Int4 WithY(int x) => new Int4(X, x, Z, W);
        public Int4 WithZ(int x) => new Int4(X, Y, x, W);
        public Int4 WithW(int x) => new Int4(X, Y, Z, x);
        public static Int4 operator +(Int4 value1, Int4 value2) => new Int4(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z,value1.W + value2.W);
        public static Int4 operator +(Int4 value1, int value2) => new Int4(value1.X + value2,value1.Y + value2,value1.Z + value2,value1.W + value2);
        public static Int4 operator +(int value1, Int4 value2) => new Int4(value1 + value2.X,value1 + value2.Y,value1 + value2.Z,value1 + value2.W);
        public static Int4 operator -(Int4 value1, Int4 value2) => new Int4(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z,value1.W - value2.W);
        public static Int4 operator -(Int4 value1, int value2) => new Int4(value1.X - value2,value1.Y - value2,value1.Z - value2,value1.W - value2);
        public static Int4 operator -(int value1, Int4 value2) => new Int4(value1 - value2.X,value1 - value2.Y,value1 - value2.Z,value1 - value2.W);
        public static Int4 operator *(Int4 value1, Int4 value2) => new Int4(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z,value1.W * value2.W);
        public static Int4 operator *(Int4 value1, int value2) => new Int4(value1.X * value2,value1.Y * value2,value1.Z * value2,value1.W * value2);
        public static Int4 operator *(int value1, Int4 value2) => new Int4(value1 * value2.X,value1 * value2.Y,value1 * value2.Z,value1 * value2.W);
        public static Int4 operator /(Int4 value1, Int4 value2) => new Int4(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z,value1.W / value2.W);
        public static Int4 operator /(Int4 value1, int value2) => new Int4(value1.X / value2,value1.Y / value2,value1.Z / value2,value1.W / value2);
        public static Int4 operator /(int value1, Int4 value2) => new Int4(value1 / value2.X,value1 / value2.Y,value1 / value2.Z,value1 / value2.W);
        public static Int4 One = new Int4(1);
        public static Int4 UnitX = Zero.WithX(1);
        public static Int4 UnitY = Zero.WithY(1);
        public static Int4 UnitZ = Zero.WithZ(1);
        public static Int4 UnitW = Zero.WithW(1);
        public Int4(int value) : this(value, value, value, value) { }
        public static Int4 operator -(Int4 value) => Zero - value;
        public static int Dot(Int4 value1, Int4 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z + value1.W * value2.W;
        public int Dot(Int4 value) => Int4.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance && W.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public int MinComponent() => (X).Min(Y).Min(Z).Min(W);
        public int MaxComponent() => (X).Max(Y).Max(Z).Max(W);
        public int SumComponents() => (X) + (Y) + (Z) + (W);
        public int SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr() + (W).Sqr();
        public int ProductComponents() => (X) * (Y) * (Z) * (W);
        public int GetComponent(int n) => n == 0 ? X : n == 1 ? Y : n == 2 ? Z:W;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 4;
        public int Count => NumComponents;
        public int this[int n] => n == 0 ? X : n == 1 ? Y : n == 2 ? Z : n == 3 ? W : throw new ArgumentOutOfRangeException("n");
        public IIterator< int > Iterator => new ArrayIterator< int >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN() || W.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity() || W.IsInfinity();
        public int CompareTo(Int4 x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Int4 x0, Int4 x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Int4 x0, Int4 x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Int4 x0, Int4 x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Int4 x0, Int4 x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Byte2 
        : IEquatable< Byte2 >
    {
        [DataMember] public readonly byte X;
        [DataMember] public readonly byte Y;
        public Byte2((byte x, byte y) tuple) : this(tuple.x, tuple.y) { }
        public Byte2(byte x, byte y) { X = x; Y = y; }
        public static Byte2 Create(byte x, byte y) => new Byte2(x, y);
        public static Byte2 Create((byte x, byte y) tuple) => new Byte2(tuple);
        public override bool Equals(object obj) => obj is Byte2 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
        public override string ToString() => $"Byte2(X = {X}, Y = {Y})";
        public void Deconstruct(out byte x, out byte y) {x = X; y = Y; }
        public bool Equals(Byte2 x) => X == x.X && Y == x.Y;
        public static bool operator ==(Byte2 x0, Byte2 x1) => x0.Equals(x1);
        public static bool operator !=(Byte2 x0, Byte2 x1) => !x0.Equals(x1);
        public static implicit operator Byte2((byte x, byte y) tuple) => new Byte2(tuple);
        public static implicit operator (byte x, byte y)(Byte2 self) => (self.X, self.Y);
        public static Byte2 Zero = new Byte2(default, default);
        public static Byte2 MinValue = new Byte2(byte.MinValue, byte.MinValue);
        public static Byte2 MaxValue = new Byte2(byte.MaxValue, byte.MaxValue);
        public Byte2 WithX(byte x) => new Byte2(x, Y);
        public Byte2 WithY(byte x) => new Byte2(X, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Byte3 
        : IEquatable< Byte3 >
    {
        [DataMember] public readonly byte X;
        [DataMember] public readonly byte Y;
        [DataMember] public readonly byte Z;
        public Byte3((byte x, byte y, byte z) tuple) : this(tuple.x, tuple.y, tuple.z) { }
        public Byte3(byte x, byte y, byte z) { X = x; Y = y; Z = z; }
        public static Byte3 Create(byte x, byte y, byte z) => new Byte3(x, y, z);
        public static Byte3 Create((byte x, byte y, byte z) tuple) => new Byte3(tuple);
        public override bool Equals(object obj) => obj is Byte3 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
        public override string ToString() => $"Byte3(X = {X}, Y = {Y}, Z = {Z})";
        public void Deconstruct(out byte x, out byte y, out byte z) {x = X; y = Y; z = Z; }
        public bool Equals(Byte3 x) => X == x.X && Y == x.Y && Z == x.Z;
        public static bool operator ==(Byte3 x0, Byte3 x1) => x0.Equals(x1);
        public static bool operator !=(Byte3 x0, Byte3 x1) => !x0.Equals(x1);
        public static implicit operator Byte3((byte x, byte y, byte z) tuple) => new Byte3(tuple);
        public static implicit operator (byte x, byte y, byte z)(Byte3 self) => (self.X, self.Y, self.Z);
        public static Byte3 Zero = new Byte3(default, default, default);
        public static Byte3 MinValue = new Byte3(byte.MinValue, byte.MinValue, byte.MinValue);
        public static Byte3 MaxValue = new Byte3(byte.MaxValue, byte.MaxValue, byte.MaxValue);
        public Byte3 WithX(byte x) => new Byte3(x, Y, Z);
        public Byte3 WithY(byte x) => new Byte3(X, x, Z);
        public Byte3 WithZ(byte x) => new Byte3(X, Y, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Byte4 
        : IEquatable< Byte4 >
    {
        [DataMember] public readonly byte X;
        [DataMember] public readonly byte Y;
        [DataMember] public readonly byte Z;
        [DataMember] public readonly byte W;
        public Byte4((byte x, byte y, byte z, byte w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) { }
        public Byte4(byte x, byte y, byte z, byte w) { X = x; Y = y; Z = z; W = w; }
        public static Byte4 Create(byte x, byte y, byte z, byte w) => new Byte4(x, y, z, w);
        public static Byte4 Create((byte x, byte y, byte z, byte w) tuple) => new Byte4(tuple);
        public override bool Equals(object obj) => obj is Byte4 x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        public override string ToString() => $"Byte4(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        public void Deconstruct(out byte x, out byte y, out byte z, out byte w) {x = X; y = Y; z = Z; w = W; }
        public bool Equals(Byte4 x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        public static bool operator ==(Byte4 x0, Byte4 x1) => x0.Equals(x1);
        public static bool operator !=(Byte4 x0, Byte4 x1) => !x0.Equals(x1);
        public static implicit operator Byte4((byte x, byte y, byte z, byte w) tuple) => new Byte4(tuple);
        public static implicit operator (byte x, byte y, byte z, byte w)(Byte4 self) => (self.X, self.Y, self.Z, self.W);
        public static Byte4 Zero = new Byte4(default, default, default, default);
        public static Byte4 MinValue = new Byte4(byte.MinValue, byte.MinValue, byte.MinValue, byte.MinValue);
        public static Byte4 MaxValue = new Byte4(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
        public Byte4 WithX(byte x) => new Byte4(x, Y, Z, W);
        public Byte4 WithY(byte x) => new Byte4(X, x, Z, W);
        public Byte4 WithZ(byte x) => new Byte4(X, Y, x, W);
        public Byte4 WithW(byte x) => new Byte4(X, Y, Z, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Complex 
        : IEquatable< Complex >
        , IArray< double >    
        , IComparable< Complex >
    {
        [DataMember] public readonly double Real;
        [DataMember] public readonly double Imaginary;
        public Complex((double real, double imaginary) tuple) : this(tuple.real, tuple.imaginary) { }
        public Complex(double real, double imaginary) { Real = real; Imaginary = imaginary; }
        public static Complex Create(double real, double imaginary) => new Complex(real, imaginary);
        public static Complex Create((double real, double imaginary) tuple) => new Complex(tuple);
        public override bool Equals(object obj) => obj is Complex x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Real.GetHashCode(), Imaginary.GetHashCode());
        public override string ToString() => $"Complex(Real = {Real}, Imaginary = {Imaginary})";
        public void Deconstruct(out double real, out double imaginary) {real = Real; imaginary = Imaginary; }
        public bool Equals(Complex x) => Real == x.Real && Imaginary == x.Imaginary;
        public static bool operator ==(Complex x0, Complex x1) => x0.Equals(x1);
        public static bool operator !=(Complex x0, Complex x1) => !x0.Equals(x1);
        public static implicit operator Complex((double real, double imaginary) tuple) => new Complex(tuple);
        public static implicit operator (double real, double imaginary)(Complex self) => (self.Real, self.Imaginary);
        public bool AlmostEquals(Complex x, float tolerance = Constants.Tolerance) => Real.AlmostEquals(x.Real, tolerance) && Imaginary.AlmostEquals(x.Imaginary, tolerance);
        public static Complex Zero = new Complex(default, default);
        public static Complex MinValue = new Complex(double.MinValue, double.MinValue);
        public static Complex MaxValue = new Complex(double.MaxValue, double.MaxValue);
        public Complex WithReal(double x) => new Complex(x, Imaginary);
        public Complex WithImaginary(double x) => new Complex(Real, x);
        public static Complex operator +(Complex value1, Complex value2) => new Complex(value1.Real + value2.Real,value1.Imaginary + value2.Imaginary);
        public static Complex operator +(Complex value1, double value2) => new Complex(value1.Real + value2,value1.Imaginary + value2);
        public static Complex operator +(double value1, Complex value2) => new Complex(value1 + value2.Real,value1 + value2.Imaginary);
        public static Complex operator -(Complex value1, Complex value2) => new Complex(value1.Real - value2.Real,value1.Imaginary - value2.Imaginary);
        public static Complex operator -(Complex value1, double value2) => new Complex(value1.Real - value2,value1.Imaginary - value2);
        public static Complex operator -(double value1, Complex value2) => new Complex(value1 - value2.Real,value1 - value2.Imaginary);
        public static Complex operator *(Complex value1, Complex value2) => new Complex(value1.Real * value2.Real,value1.Imaginary * value2.Imaginary);
        public static Complex operator *(Complex value1, double value2) => new Complex(value1.Real * value2,value1.Imaginary * value2);
        public static Complex operator *(double value1, Complex value2) => new Complex(value1 * value2.Real,value1 * value2.Imaginary);
        public static Complex operator /(Complex value1, Complex value2) => new Complex(value1.Real / value2.Real,value1.Imaginary / value2.Imaginary);
        public static Complex operator /(Complex value1, double value2) => new Complex(value1.Real / value2,value1.Imaginary / value2);
        public static Complex operator /(double value1, Complex value2) => new Complex(value1 / value2.Real,value1 / value2.Imaginary);
        public static Complex One = new Complex(1.0);
        public static Complex UnitReal = Zero.WithReal(1.0);
        public static Complex UnitImaginary = Zero.WithImaginary(1.0);
        public Complex(double value) : this(value, value) { }
        public static Complex operator -(Complex value) => Zero - value;
        public static double Dot(Complex value1, Complex value2) => value1.Real * value2.Real + value1.Imaginary * value2.Imaginary;
        public double Dot(Complex value) => Complex.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => Real.Abs() < tolerance && Imaginary.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public double MinComponent() => (Real).Min(Imaginary);
        public double MaxComponent() => (Real).Max(Imaginary);
        public double SumComponents() => (Real) + (Imaginary);
        public double SumSqrComponents() => (Real).Sqr() + (Imaginary).Sqr();
        public double ProductComponents() => (Real) * (Imaginary);
        public double GetComponent(int n) => n == 0 ? Real:Imaginary;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 2;
        public int Count => NumComponents;
        public double this[int n] => n == 0 ? Real : n == 1 ? Imaginary : throw new ArgumentOutOfRangeException("n");
        public IIterator< double > Iterator => new ArrayIterator< double >(this);
        public bool IsNaN() => Real.IsNaN() || Imaginary.IsNaN();
        public bool IsInfinity() => Real.IsInfinity() || Imaginary.IsInfinity();
        public int CompareTo(Complex x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Complex x0, Complex x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Complex x0, Complex x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Complex x0, Complex x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Complex x0, Complex x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Plane 
        : IEquatable< Plane >
    {
        [DataMember] public readonly Vector3 Normal;
        [DataMember] public readonly float D;
        public Plane((Vector3 normal, float d) tuple) : this(tuple.normal, tuple.d) { }
        public Plane(Vector3 normal, float d) { Normal = normal; D = d; }
        public static Plane Create(Vector3 normal, float d) => new Plane(normal, d);
        public static Plane Create((Vector3 normal, float d) tuple) => new Plane(tuple);
        public override bool Equals(object obj) => obj is Plane x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Normal.GetHashCode(), D.GetHashCode());
        public override string ToString() => $"Plane(Normal = {Normal}, D = {D})";
        public void Deconstruct(out Vector3 normal, out float d) {normal = Normal; d = D; }
        public bool Equals(Plane x) => Normal == x.Normal && D == x.D;
        public static bool operator ==(Plane x0, Plane x1) => x0.Equals(x1);
        public static bool operator !=(Plane x0, Plane x1) => !x0.Equals(x1);
        public static implicit operator Plane((Vector3 normal, float d) tuple) => new Plane(tuple);
        public static implicit operator (Vector3 normal, float d)(Plane self) => (self.Normal, self.D);
        public bool AlmostEquals(Plane x, float tolerance = Constants.Tolerance) => Normal.AlmostEquals(x.Normal, tolerance) && D.AlmostEquals(x.D, tolerance);
        public static Plane Zero = new Plane(default, default);
        public static Plane MinValue = new Plane(Vector3.MinValue, float.MinValue);
        public static Plane MaxValue = new Plane(Vector3.MaxValue, float.MaxValue);
        public Plane WithNormal(Vector3 x) => new Plane(x, D);
        public Plane WithD(float x) => new Plane(Normal, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DPlane 
        : IEquatable< DPlane >
    {
        [DataMember] public readonly DVector3 Normal;
        [DataMember] public readonly double D;
        public DPlane((DVector3 normal, double d) tuple) : this(tuple.normal, tuple.d) { }
        public DPlane(DVector3 normal, double d) { Normal = normal; D = d; }
        public static DPlane Create(DVector3 normal, double d) => new DPlane(normal, d);
        public static DPlane Create((DVector3 normal, double d) tuple) => new DPlane(tuple);
        public override bool Equals(object obj) => obj is DPlane x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Normal.GetHashCode(), D.GetHashCode());
        public override string ToString() => $"DPlane(Normal = {Normal}, D = {D})";
        public void Deconstruct(out DVector3 normal, out double d) {normal = Normal; d = D; }
        public bool Equals(DPlane x) => Normal == x.Normal && D == x.D;
        public static bool operator ==(DPlane x0, DPlane x1) => x0.Equals(x1);
        public static bool operator !=(DPlane x0, DPlane x1) => !x0.Equals(x1);
        public static implicit operator DPlane((DVector3 normal, double d) tuple) => new DPlane(tuple);
        public static implicit operator (DVector3 normal, double d)(DPlane self) => (self.Normal, self.D);
        public bool AlmostEquals(DPlane x, float tolerance = Constants.Tolerance) => Normal.AlmostEquals(x.Normal, tolerance) && D.AlmostEquals(x.D, tolerance);
        public static DPlane Zero = new DPlane(default, default);
        public static DPlane MinValue = new DPlane(DVector3.MinValue, double.MinValue);
        public static DPlane MaxValue = new DPlane(DVector3.MaxValue, double.MaxValue);
        public DPlane WithNormal(DVector3 x) => new DPlane(x, D);
        public DPlane WithD(double x) => new DPlane(Normal, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Quaternion 
        : IEquatable< Quaternion >
    {
        [DataMember] public readonly float X;
        [DataMember] public readonly float Y;
        [DataMember] public readonly float Z;
        [DataMember] public readonly float W;
        public Quaternion((float x, float y, float z, float w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) { }
        public Quaternion(float x, float y, float z, float w) { X = x; Y = y; Z = z; W = w; }
        public static Quaternion Create(float x, float y, float z, float w) => new Quaternion(x, y, z, w);
        public static Quaternion Create((float x, float y, float z, float w) tuple) => new Quaternion(tuple);
        public override bool Equals(object obj) => obj is Quaternion x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        public override string ToString() => $"Quaternion(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        public void Deconstruct(out float x, out float y, out float z, out float w) {x = X; y = Y; z = Z; w = W; }
        public bool Equals(Quaternion x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        public static bool operator ==(Quaternion x0, Quaternion x1) => x0.Equals(x1);
        public static bool operator !=(Quaternion x0, Quaternion x1) => !x0.Equals(x1);
        public static implicit operator Quaternion((float x, float y, float z, float w) tuple) => new Quaternion(tuple);
        public static implicit operator (float x, float y, float z, float w)(Quaternion self) => (self.X, self.Y, self.Z, self.W);
        public bool AlmostEquals(Quaternion x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance) && W.AlmostEquals(x.W, tolerance);
        public static Quaternion Zero = new Quaternion(default, default, default, default);
        public static Quaternion MinValue = new Quaternion(float.MinValue, float.MinValue, float.MinValue, float.MinValue);
        public static Quaternion MaxValue = new Quaternion(float.MaxValue, float.MaxValue, float.MaxValue, float.MaxValue);
        public Quaternion WithX(float x) => new Quaternion(x, Y, Z, W);
        public Quaternion WithY(float x) => new Quaternion(X, x, Z, W);
        public Quaternion WithZ(float x) => new Quaternion(X, Y, x, W);
        public Quaternion WithW(float x) => new Quaternion(X, Y, Z, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DQuaternion 
        : IEquatable< DQuaternion >
    {
        [DataMember] public readonly double X;
        [DataMember] public readonly double Y;
        [DataMember] public readonly double Z;
        [DataMember] public readonly double W;
        public DQuaternion((double x, double y, double z, double w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) { }
        public DQuaternion(double x, double y, double z, double w) { X = x; Y = y; Z = z; W = w; }
        public static DQuaternion Create(double x, double y, double z, double w) => new DQuaternion(x, y, z, w);
        public static DQuaternion Create((double x, double y, double z, double w) tuple) => new DQuaternion(tuple);
        public override bool Equals(object obj) => obj is DQuaternion x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        public override string ToString() => $"DQuaternion(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        public void Deconstruct(out double x, out double y, out double z, out double w) {x = X; y = Y; z = Z; w = W; }
        public bool Equals(DQuaternion x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        public static bool operator ==(DQuaternion x0, DQuaternion x1) => x0.Equals(x1);
        public static bool operator !=(DQuaternion x0, DQuaternion x1) => !x0.Equals(x1);
        public static implicit operator DQuaternion((double x, double y, double z, double w) tuple) => new DQuaternion(tuple);
        public static implicit operator (double x, double y, double z, double w)(DQuaternion self) => (self.X, self.Y, self.Z, self.W);
        public bool AlmostEquals(DQuaternion x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance) && W.AlmostEquals(x.W, tolerance);
        public static DQuaternion Zero = new DQuaternion(default, default, default, default);
        public static DQuaternion MinValue = new DQuaternion(double.MinValue, double.MinValue, double.MinValue, double.MinValue);
        public static DQuaternion MaxValue = new DQuaternion(double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue);
        public DQuaternion WithX(double x) => new DQuaternion(x, Y, Z, W);
        public DQuaternion WithY(double x) => new DQuaternion(X, x, Z, W);
        public DQuaternion WithZ(double x) => new DQuaternion(X, Y, x, W);
        public DQuaternion WithW(double x) => new DQuaternion(X, Y, Z, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Interval 
        : IEquatable< Interval >
        , IComparable< Interval >
    {
        [DataMember] public readonly float Min;
        [DataMember] public readonly float Max;
        public Interval((float min, float max) tuple) : this(tuple.min, tuple.max) { }
        public Interval(float min, float max) { Min = min; Max = max; }
        public static Interval Create(float min, float max) => new Interval(min, max);
        public static Interval Create((float min, float max) tuple) => new Interval(tuple);
        public override bool Equals(object obj) => obj is Interval x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        public override string ToString() => $"Interval(Min = {Min}, Max = {Max})";
        public void Deconstruct(out float min, out float max) {min = Min; max = Max; }
        public bool Equals(Interval x) => Min == x.Min && Max == x.Max;
        public static bool operator ==(Interval x0, Interval x1) => x0.Equals(x1);
        public static bool operator !=(Interval x0, Interval x1) => !x0.Equals(x1);
        public static implicit operator Interval((float min, float max) tuple) => new Interval(tuple);
        public static implicit operator (float min, float max)(Interval self) => (self.Min, self.Max);
        public bool AlmostEquals(Interval x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);
        public static Interval Zero = new Interval(default, default);
        public static Interval MinValue = new Interval(float.MinValue, float.MinValue);
        public static Interval MaxValue = new Interval(float.MaxValue, float.MaxValue);
        public Interval WithMin(float x) => new Interval(x, Max);
        public Interval WithMax(float x) => new Interval(Min, x);
        public float Extent => (Max - Min);
        public float Center => Min.Average(Max);   
        public double MagnitudeSquared() => Extent.MagnitudeSquared();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public Interval Merge(Interval other) => new Interval(Min.Min(other.Min), Max.Max(other.Max));
        public Interval Intersection(Interval other) => new Interval(Min.Max(other.Min), Max.Min(other.Max));
        public static Interval operator + (Interval value1, Interval value2) => value1.Merge(value2);
        public static Interval operator - (Interval value1, Interval value2) => value1.Intersection(value2);
        public Interval Merge(float other) => new Interval(Min.Min(other), Max.Max(other));
        public static Interval operator + (Interval value1, float value2) => value1.Merge(value2);
        public static Interval Empty = Create(float.MaxValue, float.MinValue);
        public bool IsNaN() => Min.IsNaN() || Max.IsNaN();
        public bool IsInfinity() => Min.IsInfinity() || Max.IsInfinity();
        public int CompareTo(Interval x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Interval x0, Interval x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Interval x0, Interval x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Interval x0, Interval x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Interval x0, Interval x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Box2D 
        : IEquatable< Box2D >
        , IComparable< Box2D >
    {
        [DataMember] public readonly Vector2 Min;
        [DataMember] public readonly Vector2 Max;
        public Box2D((Vector2 min, Vector2 max) tuple) : this(tuple.min, tuple.max) { }
        public Box2D(Vector2 min, Vector2 max) { Min = min; Max = max; }
        public static Box2D Create(Vector2 min, Vector2 max) => new Box2D(min, max);
        public static Box2D Create((Vector2 min, Vector2 max) tuple) => new Box2D(tuple);
        public override bool Equals(object obj) => obj is Box2D x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        public override string ToString() => $"Box2D(Min = {Min}, Max = {Max})";
        public void Deconstruct(out Vector2 min, out Vector2 max) {min = Min; max = Max; }
        public bool Equals(Box2D x) => Min == x.Min && Max == x.Max;
        public static bool operator ==(Box2D x0, Box2D x1) => x0.Equals(x1);
        public static bool operator !=(Box2D x0, Box2D x1) => !x0.Equals(x1);
        public static implicit operator Box2D((Vector2 min, Vector2 max) tuple) => new Box2D(tuple);
        public static implicit operator (Vector2 min, Vector2 max)(Box2D self) => (self.Min, self.Max);
        public bool AlmostEquals(Box2D x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);
        public static Box2D Zero = new Box2D(default, default);
        public static Box2D MinValue = new Box2D(Vector2.MinValue, Vector2.MinValue);
        public static Box2D MaxValue = new Box2D(Vector2.MaxValue, Vector2.MaxValue);
        public Box2D WithMin(Vector2 x) => new Box2D(x, Max);
        public Box2D WithMax(Vector2 x) => new Box2D(Min, x);
        public Vector2 Extent => (Max - Min);
        public Vector2 Center => Min.Average(Max);   
        public double MagnitudeSquared() => Extent.MagnitudeSquared();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public Box2D Merge(Box2D other) => new Box2D(Min.Min(other.Min), Max.Max(other.Max));
        public Box2D Intersection(Box2D other) => new Box2D(Min.Max(other.Min), Max.Min(other.Max));
        public static Box2D operator + (Box2D value1, Box2D value2) => value1.Merge(value2);
        public static Box2D operator - (Box2D value1, Box2D value2) => value1.Intersection(value2);
        public Box2D Merge(Vector2 other) => new Box2D(Min.Min(other), Max.Max(other));
        public static Box2D operator + (Box2D value1, Vector2 value2) => value1.Merge(value2);
        public static Box2D Empty = Create(Vector2.MaxValue, Vector2.MinValue);
        public bool IsNaN() => Min.IsNaN() || Max.IsNaN();
        public bool IsInfinity() => Min.IsInfinity() || Max.IsInfinity();
        public int CompareTo(Box2D x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Box2D x0, Box2D x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Box2D x0, Box2D x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Box2D x0, Box2D x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Box2D x0, Box2D x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Box 
        : IEquatable< Box >
        , IComparable< Box >
    {
        [DataMember] public readonly Vector3 Min;
        [DataMember] public readonly Vector3 Max;
        public Box((Vector3 min, Vector3 max) tuple) : this(tuple.min, tuple.max) { }
        public Box(Vector3 min, Vector3 max) { Min = min; Max = max; }
        public static Box Create(Vector3 min, Vector3 max) => new Box(min, max);
        public static Box Create((Vector3 min, Vector3 max) tuple) => new Box(tuple);
        public override bool Equals(object obj) => obj is Box x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        public override string ToString() => $"Box(Min = {Min}, Max = {Max})";
        public void Deconstruct(out Vector3 min, out Vector3 max) {min = Min; max = Max; }
        public bool Equals(Box x) => Min == x.Min && Max == x.Max;
        public static bool operator ==(Box x0, Box x1) => x0.Equals(x1);
        public static bool operator !=(Box x0, Box x1) => !x0.Equals(x1);
        public static implicit operator Box((Vector3 min, Vector3 max) tuple) => new Box(tuple);
        public static implicit operator (Vector3 min, Vector3 max)(Box self) => (self.Min, self.Max);
        public bool AlmostEquals(Box x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);
        public static Box Zero = new Box(default, default);
        public static Box MinValue = new Box(Vector3.MinValue, Vector3.MinValue);
        public static Box MaxValue = new Box(Vector3.MaxValue, Vector3.MaxValue);
        public Box WithMin(Vector3 x) => new Box(x, Max);
        public Box WithMax(Vector3 x) => new Box(Min, x);
        public Vector3 Extent => (Max - Min);
        public Vector3 Center => Min.Average(Max);   
        public double MagnitudeSquared() => Extent.MagnitudeSquared();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public Box Merge(Box other) => new Box(Min.Min(other.Min), Max.Max(other.Max));
        public Box Intersection(Box other) => new Box(Min.Max(other.Min), Max.Min(other.Max));
        public static Box operator + (Box value1, Box value2) => value1.Merge(value2);
        public static Box operator - (Box value1, Box value2) => value1.Intersection(value2);
        public Box Merge(Vector3 other) => new Box(Min.Min(other), Max.Max(other));
        public static Box operator + (Box value1, Vector3 value2) => value1.Merge(value2);
        public static Box Empty = Create(Vector3.MaxValue, Vector3.MinValue);
        public bool IsNaN() => Min.IsNaN() || Max.IsNaN();
        public bool IsInfinity() => Min.IsInfinity() || Max.IsInfinity();
        public int CompareTo(Box x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Box x0, Box x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Box x0, Box x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Box x0, Box x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Box x0, Box x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Box4D 
        : IEquatable< Box4D >
        , IComparable< Box4D >
    {
        [DataMember] public readonly Vector4 Min;
        [DataMember] public readonly Vector4 Max;
        public Box4D((Vector4 min, Vector4 max) tuple) : this(tuple.min, tuple.max) { }
        public Box4D(Vector4 min, Vector4 max) { Min = min; Max = max; }
        public static Box4D Create(Vector4 min, Vector4 max) => new Box4D(min, max);
        public static Box4D Create((Vector4 min, Vector4 max) tuple) => new Box4D(tuple);
        public override bool Equals(object obj) => obj is Box4D x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        public override string ToString() => $"Box4D(Min = {Min}, Max = {Max})";
        public void Deconstruct(out Vector4 min, out Vector4 max) {min = Min; max = Max; }
        public bool Equals(Box4D x) => Min == x.Min && Max == x.Max;
        public static bool operator ==(Box4D x0, Box4D x1) => x0.Equals(x1);
        public static bool operator !=(Box4D x0, Box4D x1) => !x0.Equals(x1);
        public static implicit operator Box4D((Vector4 min, Vector4 max) tuple) => new Box4D(tuple);
        public static implicit operator (Vector4 min, Vector4 max)(Box4D self) => (self.Min, self.Max);
        public bool AlmostEquals(Box4D x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);
        public static Box4D Zero = new Box4D(default, default);
        public static Box4D MinValue = new Box4D(Vector4.MinValue, Vector4.MinValue);
        public static Box4D MaxValue = new Box4D(Vector4.MaxValue, Vector4.MaxValue);
        public Box4D WithMin(Vector4 x) => new Box4D(x, Max);
        public Box4D WithMax(Vector4 x) => new Box4D(Min, x);
        public Vector4 Extent => (Max - Min);
        public Vector4 Center => Min.Average(Max);   
        public double MagnitudeSquared() => Extent.MagnitudeSquared();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public Box4D Merge(Box4D other) => new Box4D(Min.Min(other.Min), Max.Max(other.Max));
        public Box4D Intersection(Box4D other) => new Box4D(Min.Max(other.Min), Max.Min(other.Max));
        public static Box4D operator + (Box4D value1, Box4D value2) => value1.Merge(value2);
        public static Box4D operator - (Box4D value1, Box4D value2) => value1.Intersection(value2);
        public Box4D Merge(Vector4 other) => new Box4D(Min.Min(other), Max.Max(other));
        public static Box4D operator + (Box4D value1, Vector4 value2) => value1.Merge(value2);
        public static Box4D Empty = Create(Vector4.MaxValue, Vector4.MinValue);
        public bool IsNaN() => Min.IsNaN() || Max.IsNaN();
        public bool IsInfinity() => Min.IsInfinity() || Max.IsInfinity();
        public int CompareTo(Box4D x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Box4D x0, Box4D x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Box4D x0, Box4D x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Box4D x0, Box4D x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Box4D x0, Box4D x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DInterval 
        : IEquatable< DInterval >
        , IComparable< DInterval >
    {
        [DataMember] public readonly double Min;
        [DataMember] public readonly double Max;
        public DInterval((double min, double max) tuple) : this(tuple.min, tuple.max) { }
        public DInterval(double min, double max) { Min = min; Max = max; }
        public static DInterval Create(double min, double max) => new DInterval(min, max);
        public static DInterval Create((double min, double max) tuple) => new DInterval(tuple);
        public override bool Equals(object obj) => obj is DInterval x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        public override string ToString() => $"DInterval(Min = {Min}, Max = {Max})";
        public void Deconstruct(out double min, out double max) {min = Min; max = Max; }
        public bool Equals(DInterval x) => Min == x.Min && Max == x.Max;
        public static bool operator ==(DInterval x0, DInterval x1) => x0.Equals(x1);
        public static bool operator !=(DInterval x0, DInterval x1) => !x0.Equals(x1);
        public static implicit operator DInterval((double min, double max) tuple) => new DInterval(tuple);
        public static implicit operator (double min, double max)(DInterval self) => (self.Min, self.Max);
        public bool AlmostEquals(DInterval x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);
        public static DInterval Zero = new DInterval(default, default);
        public static DInterval MinValue = new DInterval(double.MinValue, double.MinValue);
        public static DInterval MaxValue = new DInterval(double.MaxValue, double.MaxValue);
        public DInterval WithMin(double x) => new DInterval(x, Max);
        public DInterval WithMax(double x) => new DInterval(Min, x);
        public double Extent => (Max - Min);
        public double Center => Min.Average(Max);   
        public double MagnitudeSquared() => Extent.MagnitudeSquared();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public DInterval Merge(DInterval other) => new DInterval(Min.Min(other.Min), Max.Max(other.Max));
        public DInterval Intersection(DInterval other) => new DInterval(Min.Max(other.Min), Max.Min(other.Max));
        public static DInterval operator + (DInterval value1, DInterval value2) => value1.Merge(value2);
        public static DInterval operator - (DInterval value1, DInterval value2) => value1.Intersection(value2);
        public DInterval Merge(double other) => new DInterval(Min.Min(other), Max.Max(other));
        public static DInterval operator + (DInterval value1, double value2) => value1.Merge(value2);
        public static DInterval Empty = Create(double.MaxValue, double.MinValue);
        public bool IsNaN() => Min.IsNaN() || Max.IsNaN();
        public bool IsInfinity() => Min.IsInfinity() || Max.IsInfinity();
        public int CompareTo(DInterval x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(DInterval x0, DInterval x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(DInterval x0, DInterval x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(DInterval x0, DInterval x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(DInterval x0, DInterval x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DBox2D 
        : IEquatable< DBox2D >
        , IComparable< DBox2D >
    {
        [DataMember] public readonly DVector2 Min;
        [DataMember] public readonly DVector2 Max;
        public DBox2D((DVector2 min, DVector2 max) tuple) : this(tuple.min, tuple.max) { }
        public DBox2D(DVector2 min, DVector2 max) { Min = min; Max = max; }
        public static DBox2D Create(DVector2 min, DVector2 max) => new DBox2D(min, max);
        public static DBox2D Create((DVector2 min, DVector2 max) tuple) => new DBox2D(tuple);
        public override bool Equals(object obj) => obj is DBox2D x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        public override string ToString() => $"DBox2D(Min = {Min}, Max = {Max})";
        public void Deconstruct(out DVector2 min, out DVector2 max) {min = Min; max = Max; }
        public bool Equals(DBox2D x) => Min == x.Min && Max == x.Max;
        public static bool operator ==(DBox2D x0, DBox2D x1) => x0.Equals(x1);
        public static bool operator !=(DBox2D x0, DBox2D x1) => !x0.Equals(x1);
        public static implicit operator DBox2D((DVector2 min, DVector2 max) tuple) => new DBox2D(tuple);
        public static implicit operator (DVector2 min, DVector2 max)(DBox2D self) => (self.Min, self.Max);
        public bool AlmostEquals(DBox2D x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);
        public static DBox2D Zero = new DBox2D(default, default);
        public static DBox2D MinValue = new DBox2D(DVector2.MinValue, DVector2.MinValue);
        public static DBox2D MaxValue = new DBox2D(DVector2.MaxValue, DVector2.MaxValue);
        public DBox2D WithMin(DVector2 x) => new DBox2D(x, Max);
        public DBox2D WithMax(DVector2 x) => new DBox2D(Min, x);
        public DVector2 Extent => (Max - Min);
        public DVector2 Center => Min.Average(Max);   
        public double MagnitudeSquared() => Extent.MagnitudeSquared();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public DBox2D Merge(DBox2D other) => new DBox2D(Min.Min(other.Min), Max.Max(other.Max));
        public DBox2D Intersection(DBox2D other) => new DBox2D(Min.Max(other.Min), Max.Min(other.Max));
        public static DBox2D operator + (DBox2D value1, DBox2D value2) => value1.Merge(value2);
        public static DBox2D operator - (DBox2D value1, DBox2D value2) => value1.Intersection(value2);
        public DBox2D Merge(DVector2 other) => new DBox2D(Min.Min(other), Max.Max(other));
        public static DBox2D operator + (DBox2D value1, DVector2 value2) => value1.Merge(value2);
        public static DBox2D Empty = Create(DVector2.MaxValue, DVector2.MinValue);
        public bool IsNaN() => Min.IsNaN() || Max.IsNaN();
        public bool IsInfinity() => Min.IsInfinity() || Max.IsInfinity();
        public int CompareTo(DBox2D x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(DBox2D x0, DBox2D x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(DBox2D x0, DBox2D x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(DBox2D x0, DBox2D x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(DBox2D x0, DBox2D x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DBox 
        : IEquatable< DBox >
        , IComparable< DBox >
    {
        [DataMember] public readonly DVector3 Min;
        [DataMember] public readonly DVector3 Max;
        public DBox((DVector3 min, DVector3 max) tuple) : this(tuple.min, tuple.max) { }
        public DBox(DVector3 min, DVector3 max) { Min = min; Max = max; }
        public static DBox Create(DVector3 min, DVector3 max) => new DBox(min, max);
        public static DBox Create((DVector3 min, DVector3 max) tuple) => new DBox(tuple);
        public override bool Equals(object obj) => obj is DBox x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        public override string ToString() => $"DBox(Min = {Min}, Max = {Max})";
        public void Deconstruct(out DVector3 min, out DVector3 max) {min = Min; max = Max; }
        public bool Equals(DBox x) => Min == x.Min && Max == x.Max;
        public static bool operator ==(DBox x0, DBox x1) => x0.Equals(x1);
        public static bool operator !=(DBox x0, DBox x1) => !x0.Equals(x1);
        public static implicit operator DBox((DVector3 min, DVector3 max) tuple) => new DBox(tuple);
        public static implicit operator (DVector3 min, DVector3 max)(DBox self) => (self.Min, self.Max);
        public bool AlmostEquals(DBox x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);
        public static DBox Zero = new DBox(default, default);
        public static DBox MinValue = new DBox(DVector3.MinValue, DVector3.MinValue);
        public static DBox MaxValue = new DBox(DVector3.MaxValue, DVector3.MaxValue);
        public DBox WithMin(DVector3 x) => new DBox(x, Max);
        public DBox WithMax(DVector3 x) => new DBox(Min, x);
        public DVector3 Extent => (Max - Min);
        public DVector3 Center => Min.Average(Max);   
        public double MagnitudeSquared() => Extent.MagnitudeSquared();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public DBox Merge(DBox other) => new DBox(Min.Min(other.Min), Max.Max(other.Max));
        public DBox Intersection(DBox other) => new DBox(Min.Max(other.Min), Max.Min(other.Max));
        public static DBox operator + (DBox value1, DBox value2) => value1.Merge(value2);
        public static DBox operator - (DBox value1, DBox value2) => value1.Intersection(value2);
        public DBox Merge(DVector3 other) => new DBox(Min.Min(other), Max.Max(other));
        public static DBox operator + (DBox value1, DVector3 value2) => value1.Merge(value2);
        public static DBox Empty = Create(DVector3.MaxValue, DVector3.MinValue);
        public bool IsNaN() => Min.IsNaN() || Max.IsNaN();
        public bool IsInfinity() => Min.IsInfinity() || Max.IsInfinity();
        public int CompareTo(DBox x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(DBox x0, DBox x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(DBox x0, DBox x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(DBox x0, DBox x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(DBox x0, DBox x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DBox4D 
        : IEquatable< DBox4D >
        , IComparable< DBox4D >
    {
        [DataMember] public readonly DVector4 Min;
        [DataMember] public readonly DVector4 Max;
        public DBox4D((DVector4 min, DVector4 max) tuple) : this(tuple.min, tuple.max) { }
        public DBox4D(DVector4 min, DVector4 max) { Min = min; Max = max; }
        public static DBox4D Create(DVector4 min, DVector4 max) => new DBox4D(min, max);
        public static DBox4D Create((DVector4 min, DVector4 max) tuple) => new DBox4D(tuple);
        public override bool Equals(object obj) => obj is DBox4D x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        public override string ToString() => $"DBox4D(Min = {Min}, Max = {Max})";
        public void Deconstruct(out DVector4 min, out DVector4 max) {min = Min; max = Max; }
        public bool Equals(DBox4D x) => Min == x.Min && Max == x.Max;
        public static bool operator ==(DBox4D x0, DBox4D x1) => x0.Equals(x1);
        public static bool operator !=(DBox4D x0, DBox4D x1) => !x0.Equals(x1);
        public static implicit operator DBox4D((DVector4 min, DVector4 max) tuple) => new DBox4D(tuple);
        public static implicit operator (DVector4 min, DVector4 max)(DBox4D self) => (self.Min, self.Max);
        public bool AlmostEquals(DBox4D x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);
        public static DBox4D Zero = new DBox4D(default, default);
        public static DBox4D MinValue = new DBox4D(DVector4.MinValue, DVector4.MinValue);
        public static DBox4D MaxValue = new DBox4D(DVector4.MaxValue, DVector4.MaxValue);
        public DBox4D WithMin(DVector4 x) => new DBox4D(x, Max);
        public DBox4D WithMax(DVector4 x) => new DBox4D(Min, x);
        public DVector4 Extent => (Max - Min);
        public DVector4 Center => Min.Average(Max);   
        public double MagnitudeSquared() => Extent.MagnitudeSquared();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public DBox4D Merge(DBox4D other) => new DBox4D(Min.Min(other.Min), Max.Max(other.Max));
        public DBox4D Intersection(DBox4D other) => new DBox4D(Min.Max(other.Min), Max.Min(other.Max));
        public static DBox4D operator + (DBox4D value1, DBox4D value2) => value1.Merge(value2);
        public static DBox4D operator - (DBox4D value1, DBox4D value2) => value1.Intersection(value2);
        public DBox4D Merge(DVector4 other) => new DBox4D(Min.Min(other), Max.Max(other));
        public static DBox4D operator + (DBox4D value1, DVector4 value2) => value1.Merge(value2);
        public static DBox4D Empty = Create(DVector4.MaxValue, DVector4.MinValue);
        public bool IsNaN() => Min.IsNaN() || Max.IsNaN();
        public bool IsInfinity() => Min.IsInfinity() || Max.IsInfinity();
        public int CompareTo(DBox4D x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(DBox4D x0, DBox4D x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(DBox4D x0, DBox4D x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(DBox4D x0, DBox4D x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(DBox4D x0, DBox4D x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Ray 
        : IEquatable< Ray >
    {
        [DataMember] public readonly Vector3 Position;
        [DataMember] public readonly Vector3 Direction;
        public Ray((Vector3 position, Vector3 direction) tuple) : this(tuple.position, tuple.direction) { }
        public Ray(Vector3 position, Vector3 direction) { Position = position; Direction = direction; }
        public static Ray Create(Vector3 position, Vector3 direction) => new Ray(position, direction);
        public static Ray Create((Vector3 position, Vector3 direction) tuple) => new Ray(tuple);
        public override bool Equals(object obj) => obj is Ray x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Direction.GetHashCode());
        public override string ToString() => $"Ray(Position = {Position}, Direction = {Direction})";
        public void Deconstruct(out Vector3 position, out Vector3 direction) {position = Position; direction = Direction; }
        public bool Equals(Ray x) => Position == x.Position && Direction == x.Direction;
        public static bool operator ==(Ray x0, Ray x1) => x0.Equals(x1);
        public static bool operator !=(Ray x0, Ray x1) => !x0.Equals(x1);
        public static implicit operator Ray((Vector3 position, Vector3 direction) tuple) => new Ray(tuple);
        public static implicit operator (Vector3 position, Vector3 direction)(Ray self) => (self.Position, self.Direction);
        public bool AlmostEquals(Ray x, float tolerance = Constants.Tolerance) => Position.AlmostEquals(x.Position, tolerance) && Direction.AlmostEquals(x.Direction, tolerance);
        public static Ray Zero = new Ray(default, default);
        public static Ray MinValue = new Ray(Vector3.MinValue, Vector3.MinValue);
        public static Ray MaxValue = new Ray(Vector3.MaxValue, Vector3.MaxValue);
        public Ray WithPosition(Vector3 x) => new Ray(x, Direction);
        public Ray WithDirection(Vector3 x) => new Ray(Position, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DRay 
        : IEquatable< DRay >
    {
        [DataMember] public readonly DVector3 Position;
        [DataMember] public readonly DVector3 Direction;
        public DRay((DVector3 position, DVector3 direction) tuple) : this(tuple.position, tuple.direction) { }
        public DRay(DVector3 position, DVector3 direction) { Position = position; Direction = direction; }
        public static DRay Create(DVector3 position, DVector3 direction) => new DRay(position, direction);
        public static DRay Create((DVector3 position, DVector3 direction) tuple) => new DRay(tuple);
        public override bool Equals(object obj) => obj is DRay x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Direction.GetHashCode());
        public override string ToString() => $"DRay(Position = {Position}, Direction = {Direction})";
        public void Deconstruct(out DVector3 position, out DVector3 direction) {position = Position; direction = Direction; }
        public bool Equals(DRay x) => Position == x.Position && Direction == x.Direction;
        public static bool operator ==(DRay x0, DRay x1) => x0.Equals(x1);
        public static bool operator !=(DRay x0, DRay x1) => !x0.Equals(x1);
        public static implicit operator DRay((DVector3 position, DVector3 direction) tuple) => new DRay(tuple);
        public static implicit operator (DVector3 position, DVector3 direction)(DRay self) => (self.Position, self.Direction);
        public bool AlmostEquals(DRay x, float tolerance = Constants.Tolerance) => Position.AlmostEquals(x.Position, tolerance) && Direction.AlmostEquals(x.Direction, tolerance);
        public static DRay Zero = new DRay(default, default);
        public static DRay MinValue = new DRay(DVector3.MinValue, DVector3.MinValue);
        public static DRay MaxValue = new DRay(DVector3.MaxValue, DVector3.MaxValue);
        public DRay WithPosition(DVector3 x) => new DRay(x, Direction);
        public DRay WithDirection(DVector3 x) => new DRay(Position, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Ray2D 
        : IEquatable< Ray2D >
    {
        [DataMember] public readonly Vector2 Position;
        [DataMember] public readonly Vector2 Direction;
        public Ray2D((Vector2 position, Vector2 direction) tuple) : this(tuple.position, tuple.direction) { }
        public Ray2D(Vector2 position, Vector2 direction) { Position = position; Direction = direction; }
        public static Ray2D Create(Vector2 position, Vector2 direction) => new Ray2D(position, direction);
        public static Ray2D Create((Vector2 position, Vector2 direction) tuple) => new Ray2D(tuple);
        public override bool Equals(object obj) => obj is Ray2D x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Direction.GetHashCode());
        public override string ToString() => $"Ray2D(Position = {Position}, Direction = {Direction})";
        public void Deconstruct(out Vector2 position, out Vector2 direction) {position = Position; direction = Direction; }
        public bool Equals(Ray2D x) => Position == x.Position && Direction == x.Direction;
        public static bool operator ==(Ray2D x0, Ray2D x1) => x0.Equals(x1);
        public static bool operator !=(Ray2D x0, Ray2D x1) => !x0.Equals(x1);
        public static implicit operator Ray2D((Vector2 position, Vector2 direction) tuple) => new Ray2D(tuple);
        public static implicit operator (Vector2 position, Vector2 direction)(Ray2D self) => (self.Position, self.Direction);
        public bool AlmostEquals(Ray2D x, float tolerance = Constants.Tolerance) => Position.AlmostEquals(x.Position, tolerance) && Direction.AlmostEquals(x.Direction, tolerance);
        public static Ray2D Zero = new Ray2D(default, default);
        public static Ray2D MinValue = new Ray2D(Vector2.MinValue, Vector2.MinValue);
        public static Ray2D MaxValue = new Ray2D(Vector2.MaxValue, Vector2.MaxValue);
        public Ray2D WithPosition(Vector2 x) => new Ray2D(x, Direction);
        public Ray2D WithDirection(Vector2 x) => new Ray2D(Position, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DRay2D 
        : IEquatable< DRay2D >
    {
        [DataMember] public readonly DVector2 Position;
        [DataMember] public readonly DVector2 Direction;
        public DRay2D((DVector2 position, DVector2 direction) tuple) : this(tuple.position, tuple.direction) { }
        public DRay2D(DVector2 position, DVector2 direction) { Position = position; Direction = direction; }
        public static DRay2D Create(DVector2 position, DVector2 direction) => new DRay2D(position, direction);
        public static DRay2D Create((DVector2 position, DVector2 direction) tuple) => new DRay2D(tuple);
        public override bool Equals(object obj) => obj is DRay2D x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Direction.GetHashCode());
        public override string ToString() => $"DRay2D(Position = {Position}, Direction = {Direction})";
        public void Deconstruct(out DVector2 position, out DVector2 direction) {position = Position; direction = Direction; }
        public bool Equals(DRay2D x) => Position == x.Position && Direction == x.Direction;
        public static bool operator ==(DRay2D x0, DRay2D x1) => x0.Equals(x1);
        public static bool operator !=(DRay2D x0, DRay2D x1) => !x0.Equals(x1);
        public static implicit operator DRay2D((DVector2 position, DVector2 direction) tuple) => new DRay2D(tuple);
        public static implicit operator (DVector2 position, DVector2 direction)(DRay2D self) => (self.Position, self.Direction);
        public bool AlmostEquals(DRay2D x, float tolerance = Constants.Tolerance) => Position.AlmostEquals(x.Position, tolerance) && Direction.AlmostEquals(x.Direction, tolerance);
        public static DRay2D Zero = new DRay2D(default, default);
        public static DRay2D MinValue = new DRay2D(DVector2.MinValue, DVector2.MinValue);
        public static DRay2D MaxValue = new DRay2D(DVector2.MaxValue, DVector2.MaxValue);
        public DRay2D WithPosition(DVector2 x) => new DRay2D(x, Direction);
        public DRay2D WithDirection(DVector2 x) => new DRay2D(Position, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Sphere 
        : IEquatable< Sphere >
    {
        [DataMember] public readonly Vector3 Center;
        [DataMember] public readonly float Radius;
        public Sphere((Vector3 center, float radius) tuple) : this(tuple.center, tuple.radius) { }
        public Sphere(Vector3 center, float radius) { Center = center; Radius = radius; }
        public static Sphere Create(Vector3 center, float radius) => new Sphere(center, radius);
        public static Sphere Create((Vector3 center, float radius) tuple) => new Sphere(tuple);
        public override bool Equals(object obj) => obj is Sphere x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Center.GetHashCode(), Radius.GetHashCode());
        public override string ToString() => $"Sphere(Center = {Center}, Radius = {Radius})";
        public void Deconstruct(out Vector3 center, out float radius) {center = Center; radius = Radius; }
        public bool Equals(Sphere x) => Center == x.Center && Radius == x.Radius;
        public static bool operator ==(Sphere x0, Sphere x1) => x0.Equals(x1);
        public static bool operator !=(Sphere x0, Sphere x1) => !x0.Equals(x1);
        public static implicit operator Sphere((Vector3 center, float radius) tuple) => new Sphere(tuple);
        public static implicit operator (Vector3 center, float radius)(Sphere self) => (self.Center, self.Radius);
        public bool AlmostEquals(Sphere x, float tolerance = Constants.Tolerance) => Center.AlmostEquals(x.Center, tolerance) && Radius.AlmostEquals(x.Radius, tolerance);
        public static Sphere Zero = new Sphere(default, default);
        public static Sphere MinValue = new Sphere(Vector3.MinValue, float.MinValue);
        public static Sphere MaxValue = new Sphere(Vector3.MaxValue, float.MaxValue);
        public Sphere WithCenter(Vector3 x) => new Sphere(x, Radius);
        public Sphere WithRadius(float x) => new Sphere(Center, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DSphere 
        : IEquatable< DSphere >
    {
        [DataMember] public readonly DVector3 Center;
        [DataMember] public readonly double Radius;
        public DSphere((DVector3 center, double radius) tuple) : this(tuple.center, tuple.radius) { }
        public DSphere(DVector3 center, double radius) { Center = center; Radius = radius; }
        public static DSphere Create(DVector3 center, double radius) => new DSphere(center, radius);
        public static DSphere Create((DVector3 center, double radius) tuple) => new DSphere(tuple);
        public override bool Equals(object obj) => obj is DSphere x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Center.GetHashCode(), Radius.GetHashCode());
        public override string ToString() => $"DSphere(Center = {Center}, Radius = {Radius})";
        public void Deconstruct(out DVector3 center, out double radius) {center = Center; radius = Radius; }
        public bool Equals(DSphere x) => Center == x.Center && Radius == x.Radius;
        public static bool operator ==(DSphere x0, DSphere x1) => x0.Equals(x1);
        public static bool operator !=(DSphere x0, DSphere x1) => !x0.Equals(x1);
        public static implicit operator DSphere((DVector3 center, double radius) tuple) => new DSphere(tuple);
        public static implicit operator (DVector3 center, double radius)(DSphere self) => (self.Center, self.Radius);
        public bool AlmostEquals(DSphere x, float tolerance = Constants.Tolerance) => Center.AlmostEquals(x.Center, tolerance) && Radius.AlmostEquals(x.Radius, tolerance);
        public static DSphere Zero = new DSphere(default, default);
        public static DSphere MinValue = new DSphere(DVector3.MinValue, double.MinValue);
        public static DSphere MaxValue = new DSphere(DVector3.MaxValue, double.MaxValue);
        public DSphere WithCenter(DVector3 x) => new DSphere(x, Radius);
        public DSphere WithRadius(double x) => new DSphere(Center, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Pose 
        : IEquatable< Pose >
    {
        [DataMember] public readonly Vector3 Position;
        [DataMember] public readonly Quaternion Orientation;
        public Pose((Vector3 position, Quaternion orientation) tuple) : this(tuple.position, tuple.orientation) { }
        public Pose(Vector3 position, Quaternion orientation) { Position = position; Orientation = orientation; }
        public static Pose Create(Vector3 position, Quaternion orientation) => new Pose(position, orientation);
        public static Pose Create((Vector3 position, Quaternion orientation) tuple) => new Pose(tuple);
        public override bool Equals(object obj) => obj is Pose x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Orientation.GetHashCode());
        public override string ToString() => $"Pose(Position = {Position}, Orientation = {Orientation})";
        public void Deconstruct(out Vector3 position, out Quaternion orientation) {position = Position; orientation = Orientation; }
        public bool Equals(Pose x) => Position == x.Position && Orientation == x.Orientation;
        public static bool operator ==(Pose x0, Pose x1) => x0.Equals(x1);
        public static bool operator !=(Pose x0, Pose x1) => !x0.Equals(x1);
        public static implicit operator Pose((Vector3 position, Quaternion orientation) tuple) => new Pose(tuple);
        public static implicit operator (Vector3 position, Quaternion orientation)(Pose self) => (self.Position, self.Orientation);
        public bool AlmostEquals(Pose x, float tolerance = Constants.Tolerance) => Position.AlmostEquals(x.Position, tolerance) && Orientation.AlmostEquals(x.Orientation, tolerance);
        public static Pose Zero = new Pose(default, default);
        public static Pose MinValue = new Pose(Vector3.MinValue, Quaternion.MinValue);
        public static Pose MaxValue = new Pose(Vector3.MaxValue, Quaternion.MaxValue);
        public Pose WithPosition(Vector3 x) => new Pose(x, Orientation);
        public Pose WithOrientation(Quaternion x) => new Pose(Position, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DPose 
        : IEquatable< DPose >
    {
        [DataMember] public readonly DVector3 Position;
        [DataMember] public readonly DQuaternion Orientation;
        public DPose((DVector3 position, DQuaternion orientation) tuple) : this(tuple.position, tuple.orientation) { }
        public DPose(DVector3 position, DQuaternion orientation) { Position = position; Orientation = orientation; }
        public static DPose Create(DVector3 position, DQuaternion orientation) => new DPose(position, orientation);
        public static DPose Create((DVector3 position, DQuaternion orientation) tuple) => new DPose(tuple);
        public override bool Equals(object obj) => obj is DPose x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Orientation.GetHashCode());
        public override string ToString() => $"DPose(Position = {Position}, Orientation = {Orientation})";
        public void Deconstruct(out DVector3 position, out DQuaternion orientation) {position = Position; orientation = Orientation; }
        public bool Equals(DPose x) => Position == x.Position && Orientation == x.Orientation;
        public static bool operator ==(DPose x0, DPose x1) => x0.Equals(x1);
        public static bool operator !=(DPose x0, DPose x1) => !x0.Equals(x1);
        public static implicit operator DPose((DVector3 position, DQuaternion orientation) tuple) => new DPose(tuple);
        public static implicit operator (DVector3 position, DQuaternion orientation)(DPose self) => (self.Position, self.Orientation);
        public bool AlmostEquals(DPose x, float tolerance = Constants.Tolerance) => Position.AlmostEquals(x.Position, tolerance) && Orientation.AlmostEquals(x.Orientation, tolerance);
        public static DPose Zero = new DPose(default, default);
        public static DPose MinValue = new DPose(DVector3.MinValue, DQuaternion.MinValue);
        public static DPose MaxValue = new DPose(DVector3.MaxValue, DQuaternion.MaxValue);
        public DPose WithPosition(DVector3 x) => new DPose(x, Orientation);
        public DPose WithOrientation(DQuaternion x) => new DPose(Position, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Line 
        : IEquatable< Line >
    {
        [DataMember] public readonly Vector3 A;
        [DataMember] public readonly Vector3 B;
        public Line((Vector3 a, Vector3 b) tuple) : this(tuple.a, tuple.b) { }
        public Line(Vector3 a, Vector3 b) { A = a; B = b; }
        public static Line Create(Vector3 a, Vector3 b) => new Line(a, b);
        public static Line Create((Vector3 a, Vector3 b) tuple) => new Line(tuple);
        public override bool Equals(object obj) => obj is Line x && Equals(x);
        public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode());
        public override string ToString() => $"Line(A = {A}, B = {B})";
        public void Deconstruct(out Vector3 a, out Vector3 b) {a = A; b = B; }
        public bool Equals(Line x) => A == x.A && B == x.B;
        public static bool operator ==(Line x0, Line x1) => x0.Equals(x1);
        public static bool operator !=(Line x0, Line x1) => !x0.Equals(x1);
        public static implicit operator Line((Vector3 a, Vector3 b) tuple) => new Line(tuple);
        public static implicit operator (Vector3 a, Vector3 b)(Line self) => (self.A, self.B);
        public bool AlmostEquals(Line x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance);
        public static Line Zero = new Line(default, default);
        public static Line MinValue = new Line(Vector3.MinValue, Vector3.MinValue);
        public static Line MaxValue = new Line(Vector3.MaxValue, Vector3.MaxValue);
        public Line WithA(Vector3 x) => new Line(x, B);
        public Line WithB(Vector3 x) => new Line(A, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Line2D 
        : IEquatable< Line2D >
    {
        [DataMember] public readonly Vector2 A;
        [DataMember] public readonly Vector2 B;
        public Line2D((Vector2 a, Vector2 b) tuple) : this(tuple.a, tuple.b) { }
        public Line2D(Vector2 a, Vector2 b) { A = a; B = b; }
        public static Line2D Create(Vector2 a, Vector2 b) => new Line2D(a, b);
        public static Line2D Create((Vector2 a, Vector2 b) tuple) => new Line2D(tuple);
        public override bool Equals(object obj) => obj is Line2D x && Equals(x);
        public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode());
        public override string ToString() => $"Line2D(A = {A}, B = {B})";
        public void Deconstruct(out Vector2 a, out Vector2 b) {a = A; b = B; }
        public bool Equals(Line2D x) => A == x.A && B == x.B;
        public static bool operator ==(Line2D x0, Line2D x1) => x0.Equals(x1);
        public static bool operator !=(Line2D x0, Line2D x1) => !x0.Equals(x1);
        public static implicit operator Line2D((Vector2 a, Vector2 b) tuple) => new Line2D(tuple);
        public static implicit operator (Vector2 a, Vector2 b)(Line2D self) => (self.A, self.B);
        public bool AlmostEquals(Line2D x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance);
        public static Line2D Zero = new Line2D(default, default);
        public static Line2D MinValue = new Line2D(Vector2.MinValue, Vector2.MinValue);
        public static Line2D MaxValue = new Line2D(Vector2.MaxValue, Vector2.MaxValue);
        public Line2D WithA(Vector2 x) => new Line2D(x, B);
        public Line2D WithB(Vector2 x) => new Line2D(A, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Triangle 
        : IEquatable< Triangle >
    {
        [DataMember] public readonly Vector3 A;
        [DataMember] public readonly Vector3 B;
        [DataMember] public readonly Vector3 C;
        public Triangle((Vector3 a, Vector3 b, Vector3 c) tuple) : this(tuple.a, tuple.b, tuple.c) { }
        public Triangle(Vector3 a, Vector3 b, Vector3 c) { A = a; B = b; C = c; }
        public static Triangle Create(Vector3 a, Vector3 b, Vector3 c) => new Triangle(a, b, c);
        public static Triangle Create((Vector3 a, Vector3 b, Vector3 c) tuple) => new Triangle(tuple);
        public override bool Equals(object obj) => obj is Triangle x && Equals(x);
        public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
        public override string ToString() => $"Triangle(A = {A}, B = {B}, C = {C})";
        public void Deconstruct(out Vector3 a, out Vector3 b, out Vector3 c) {a = A; b = B; c = C; }
        public bool Equals(Triangle x) => A == x.A && B == x.B && C == x.C;
        public static bool operator ==(Triangle x0, Triangle x1) => x0.Equals(x1);
        public static bool operator !=(Triangle x0, Triangle x1) => !x0.Equals(x1);
        public static implicit operator Triangle((Vector3 a, Vector3 b, Vector3 c) tuple) => new Triangle(tuple);
        public static implicit operator (Vector3 a, Vector3 b, Vector3 c)(Triangle self) => (self.A, self.B, self.C);
        public bool AlmostEquals(Triangle x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance) && C.AlmostEquals(x.C, tolerance);
        public static Triangle Zero = new Triangle(default, default, default);
        public static Triangle MinValue = new Triangle(Vector3.MinValue, Vector3.MinValue, Vector3.MinValue);
        public static Triangle MaxValue = new Triangle(Vector3.MaxValue, Vector3.MaxValue, Vector3.MaxValue);
        public Triangle WithA(Vector3 x) => new Triangle(x, B, C);
        public Triangle WithB(Vector3 x) => new Triangle(A, x, C);
        public Triangle WithC(Vector3 x) => new Triangle(A, B, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Triangle2D 
        : IEquatable< Triangle2D >
    {
        [DataMember] public readonly Vector2 A;
        [DataMember] public readonly Vector2 B;
        [DataMember] public readonly Vector2 C;
        public Triangle2D((Vector2 a, Vector2 b, Vector2 c) tuple) : this(tuple.a, tuple.b, tuple.c) { }
        public Triangle2D(Vector2 a, Vector2 b, Vector2 c) { A = a; B = b; C = c; }
        public static Triangle2D Create(Vector2 a, Vector2 b, Vector2 c) => new Triangle2D(a, b, c);
        public static Triangle2D Create((Vector2 a, Vector2 b, Vector2 c) tuple) => new Triangle2D(tuple);
        public override bool Equals(object obj) => obj is Triangle2D x && Equals(x);
        public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
        public override string ToString() => $"Triangle2D(A = {A}, B = {B}, C = {C})";
        public void Deconstruct(out Vector2 a, out Vector2 b, out Vector2 c) {a = A; b = B; c = C; }
        public bool Equals(Triangle2D x) => A == x.A && B == x.B && C == x.C;
        public static bool operator ==(Triangle2D x0, Triangle2D x1) => x0.Equals(x1);
        public static bool operator !=(Triangle2D x0, Triangle2D x1) => !x0.Equals(x1);
        public static implicit operator Triangle2D((Vector2 a, Vector2 b, Vector2 c) tuple) => new Triangle2D(tuple);
        public static implicit operator (Vector2 a, Vector2 b, Vector2 c)(Triangle2D self) => (self.A, self.B, self.C);
        public bool AlmostEquals(Triangle2D x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance) && C.AlmostEquals(x.C, tolerance);
        public static Triangle2D Zero = new Triangle2D(default, default, default);
        public static Triangle2D MinValue = new Triangle2D(Vector2.MinValue, Vector2.MinValue, Vector2.MinValue);
        public static Triangle2D MaxValue = new Triangle2D(Vector2.MaxValue, Vector2.MaxValue, Vector2.MaxValue);
        public Triangle2D WithA(Vector2 x) => new Triangle2D(x, B, C);
        public Triangle2D WithB(Vector2 x) => new Triangle2D(A, x, C);
        public Triangle2D WithC(Vector2 x) => new Triangle2D(A, B, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Quad 
        : IEquatable< Quad >
    {
        [DataMember] public readonly Vector3 A;
        [DataMember] public readonly Vector3 B;
        [DataMember] public readonly Vector3 C;
        [DataMember] public readonly Vector3 D;
        public Quad((Vector3 a, Vector3 b, Vector3 c, Vector3 d) tuple) : this(tuple.a, tuple.b, tuple.c, tuple.d) { }
        public Quad(Vector3 a, Vector3 b, Vector3 c, Vector3 d) { A = a; B = b; C = c; D = d; }
        public static Quad Create(Vector3 a, Vector3 b, Vector3 c, Vector3 d) => new Quad(a, b, c, d);
        public static Quad Create((Vector3 a, Vector3 b, Vector3 c, Vector3 d) tuple) => new Quad(tuple);
        public override bool Equals(object obj) => obj is Quad x && Equals(x);
        public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode(), D.GetHashCode());
        public override string ToString() => $"Quad(A = {A}, B = {B}, C = {C}, D = {D})";
        public void Deconstruct(out Vector3 a, out Vector3 b, out Vector3 c, out Vector3 d) {a = A; b = B; c = C; d = D; }
        public bool Equals(Quad x) => A == x.A && B == x.B && C == x.C && D == x.D;
        public static bool operator ==(Quad x0, Quad x1) => x0.Equals(x1);
        public static bool operator !=(Quad x0, Quad x1) => !x0.Equals(x1);
        public static implicit operator Quad((Vector3 a, Vector3 b, Vector3 c, Vector3 d) tuple) => new Quad(tuple);
        public static implicit operator (Vector3 a, Vector3 b, Vector3 c, Vector3 d)(Quad self) => (self.A, self.B, self.C, self.D);
        public bool AlmostEquals(Quad x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance) && C.AlmostEquals(x.C, tolerance) && D.AlmostEquals(x.D, tolerance);
        public static Quad Zero = new Quad(default, default, default, default);
        public static Quad MinValue = new Quad(Vector3.MinValue, Vector3.MinValue, Vector3.MinValue, Vector3.MinValue);
        public static Quad MaxValue = new Quad(Vector3.MaxValue, Vector3.MaxValue, Vector3.MaxValue, Vector3.MaxValue);
        public Quad WithA(Vector3 x) => new Quad(x, B, C, D);
        public Quad WithB(Vector3 x) => new Quad(A, x, C, D);
        public Quad WithC(Vector3 x) => new Quad(A, B, x, D);
        public Quad WithD(Vector3 x) => new Quad(A, B, C, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Quad2D 
        : IEquatable< Quad2D >
    {
        [DataMember] public readonly Vector2 A;
        [DataMember] public readonly Vector2 B;
        [DataMember] public readonly Vector2 C;
        [DataMember] public readonly Vector2 D;
        public Quad2D((Vector2 a, Vector2 b, Vector2 c, Vector2 d) tuple) : this(tuple.a, tuple.b, tuple.c, tuple.d) { }
        public Quad2D(Vector2 a, Vector2 b, Vector2 c, Vector2 d) { A = a; B = b; C = c; D = d; }
        public static Quad2D Create(Vector2 a, Vector2 b, Vector2 c, Vector2 d) => new Quad2D(a, b, c, d);
        public static Quad2D Create((Vector2 a, Vector2 b, Vector2 c, Vector2 d) tuple) => new Quad2D(tuple);
        public override bool Equals(object obj) => obj is Quad2D x && Equals(x);
        public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode(), D.GetHashCode());
        public override string ToString() => $"Quad2D(A = {A}, B = {B}, C = {C}, D = {D})";
        public void Deconstruct(out Vector2 a, out Vector2 b, out Vector2 c, out Vector2 d) {a = A; b = B; c = C; d = D; }
        public bool Equals(Quad2D x) => A == x.A && B == x.B && C == x.C && D == x.D;
        public static bool operator ==(Quad2D x0, Quad2D x1) => x0.Equals(x1);
        public static bool operator !=(Quad2D x0, Quad2D x1) => !x0.Equals(x1);
        public static implicit operator Quad2D((Vector2 a, Vector2 b, Vector2 c, Vector2 d) tuple) => new Quad2D(tuple);
        public static implicit operator (Vector2 a, Vector2 b, Vector2 c, Vector2 d)(Quad2D self) => (self.A, self.B, self.C, self.D);
        public bool AlmostEquals(Quad2D x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance) && C.AlmostEquals(x.C, tolerance) && D.AlmostEquals(x.D, tolerance);
        public static Quad2D Zero = new Quad2D(default, default, default, default);
        public static Quad2D MinValue = new Quad2D(Vector2.MinValue, Vector2.MinValue, Vector2.MinValue, Vector2.MinValue);
        public static Quad2D MaxValue = new Quad2D(Vector2.MaxValue, Vector2.MaxValue, Vector2.MaxValue, Vector2.MaxValue);
        public Quad2D WithA(Vector2 x) => new Quad2D(x, B, C, D);
        public Quad2D WithB(Vector2 x) => new Quad2D(A, x, C, D);
        public Quad2D WithC(Vector2 x) => new Quad2D(A, B, x, D);
        public Quad2D WithD(Vector2 x) => new Quad2D(A, B, C, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct ColorRGB 
        : IEquatable< ColorRGB >
    {
        [DataMember] public readonly byte R;
        [DataMember] public readonly byte G;
        [DataMember] public readonly byte B;
        public ColorRGB((byte r, byte g, byte b) tuple) : this(tuple.r, tuple.g, tuple.b) { }
        public ColorRGB(byte r, byte g, byte b) { R = r; G = g; B = b; }
        public static ColorRGB Create(byte r, byte g, byte b) => new ColorRGB(r, g, b);
        public static ColorRGB Create((byte r, byte g, byte b) tuple) => new ColorRGB(tuple);
        public override bool Equals(object obj) => obj is ColorRGB x && Equals(x);
        public override int GetHashCode() => Hash.Combine(R.GetHashCode(), G.GetHashCode(), B.GetHashCode());
        public override string ToString() => $"ColorRGB(R = {R}, G = {G}, B = {B})";
        public void Deconstruct(out byte r, out byte g, out byte b) {r = R; g = G; b = B; }
        public bool Equals(ColorRGB x) => R == x.R && G == x.G && B == x.B;
        public static bool operator ==(ColorRGB x0, ColorRGB x1) => x0.Equals(x1);
        public static bool operator !=(ColorRGB x0, ColorRGB x1) => !x0.Equals(x1);
        public static implicit operator ColorRGB((byte r, byte g, byte b) tuple) => new ColorRGB(tuple);
        public static implicit operator (byte r, byte g, byte b)(ColorRGB self) => (self.R, self.G, self.B);
        public static ColorRGB Zero = new ColorRGB(default, default, default);
        public static ColorRGB MinValue = new ColorRGB(byte.MinValue, byte.MinValue, byte.MinValue);
        public static ColorRGB MaxValue = new ColorRGB(byte.MaxValue, byte.MaxValue, byte.MaxValue);
        public ColorRGB WithR(byte x) => new ColorRGB(x, G, B);
        public ColorRGB WithG(byte x) => new ColorRGB(R, x, B);
        public ColorRGB WithB(byte x) => new ColorRGB(R, G, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct ColorRGBA 
        : IEquatable< ColorRGBA >
    {
        [DataMember] public readonly byte R;
        [DataMember] public readonly byte G;
        [DataMember] public readonly byte B;
        [DataMember] public readonly byte A;
        public ColorRGBA((byte r, byte g, byte b, byte a) tuple) : this(tuple.r, tuple.g, tuple.b, tuple.a) { }
        public ColorRGBA(byte r, byte g, byte b, byte a) { R = r; G = g; B = b; A = a; }
        public static ColorRGBA Create(byte r, byte g, byte b, byte a) => new ColorRGBA(r, g, b, a);
        public static ColorRGBA Create((byte r, byte g, byte b, byte a) tuple) => new ColorRGBA(tuple);
        public override bool Equals(object obj) => obj is ColorRGBA x && Equals(x);
        public override int GetHashCode() => Hash.Combine(R.GetHashCode(), G.GetHashCode(), B.GetHashCode(), A.GetHashCode());
        public override string ToString() => $"ColorRGBA(R = {R}, G = {G}, B = {B}, A = {A})";
        public void Deconstruct(out byte r, out byte g, out byte b, out byte a) {r = R; g = G; b = B; a = A; }
        public bool Equals(ColorRGBA x) => R == x.R && G == x.G && B == x.B && A == x.A;
        public static bool operator ==(ColorRGBA x0, ColorRGBA x1) => x0.Equals(x1);
        public static bool operator !=(ColorRGBA x0, ColorRGBA x1) => !x0.Equals(x1);
        public static implicit operator ColorRGBA((byte r, byte g, byte b, byte a) tuple) => new ColorRGBA(tuple);
        public static implicit operator (byte r, byte g, byte b, byte a)(ColorRGBA self) => (self.R, self.G, self.B, self.A);
        public static ColorRGBA Zero = new ColorRGBA(default, default, default, default);
        public static ColorRGBA MinValue = new ColorRGBA(byte.MinValue, byte.MinValue, byte.MinValue, byte.MinValue);
        public static ColorRGBA MaxValue = new ColorRGBA(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
        public ColorRGBA WithR(byte x) => new ColorRGBA(x, G, B, A);
        public ColorRGBA WithG(byte x) => new ColorRGBA(R, x, B, A);
        public ColorRGBA WithB(byte x) => new ColorRGBA(R, G, x, A);
        public ColorRGBA WithA(byte x) => new ColorRGBA(R, G, B, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct ColorHDR 
        : IEquatable< ColorHDR >
    {
        [DataMember] public readonly float R;
        [DataMember] public readonly float G;
        [DataMember] public readonly float B;
        [DataMember] public readonly float A;
        public ColorHDR((float r, float g, float b, float a) tuple) : this(tuple.r, tuple.g, tuple.b, tuple.a) { }
        public ColorHDR(float r, float g, float b, float a) { R = r; G = g; B = b; A = a; }
        public static ColorHDR Create(float r, float g, float b, float a) => new ColorHDR(r, g, b, a);
        public static ColorHDR Create((float r, float g, float b, float a) tuple) => new ColorHDR(tuple);
        public override bool Equals(object obj) => obj is ColorHDR x && Equals(x);
        public override int GetHashCode() => Hash.Combine(R.GetHashCode(), G.GetHashCode(), B.GetHashCode(), A.GetHashCode());
        public override string ToString() => $"ColorHDR(R = {R}, G = {G}, B = {B}, A = {A})";
        public void Deconstruct(out float r, out float g, out float b, out float a) {r = R; g = G; b = B; a = A; }
        public bool Equals(ColorHDR x) => R == x.R && G == x.G && B == x.B && A == x.A;
        public static bool operator ==(ColorHDR x0, ColorHDR x1) => x0.Equals(x1);
        public static bool operator !=(ColorHDR x0, ColorHDR x1) => !x0.Equals(x1);
        public static implicit operator ColorHDR((float r, float g, float b, float a) tuple) => new ColorHDR(tuple);
        public static implicit operator (float r, float g, float b, float a)(ColorHDR self) => (self.R, self.G, self.B, self.A);
        public bool AlmostEquals(ColorHDR x, float tolerance = Constants.Tolerance) => R.AlmostEquals(x.R, tolerance) && G.AlmostEquals(x.G, tolerance) && B.AlmostEquals(x.B, tolerance) && A.AlmostEquals(x.A, tolerance);
        public static ColorHDR Zero = new ColorHDR(default, default, default, default);
        public static ColorHDR MinValue = new ColorHDR(float.MinValue, float.MinValue, float.MinValue, float.MinValue);
        public static ColorHDR MaxValue = new ColorHDR(float.MaxValue, float.MaxValue, float.MaxValue, float.MaxValue);
        public ColorHDR WithR(float x) => new ColorHDR(x, G, B, A);
        public ColorHDR WithG(float x) => new ColorHDR(R, x, B, A);
        public ColorHDR WithB(float x) => new ColorHDR(R, G, x, A);
        public ColorHDR WithA(float x) => new ColorHDR(R, G, B, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct ColorHSV 
        : IEquatable< ColorHSV >
    {
        [DataMember] public readonly float H;
        [DataMember] public readonly float S;
        [DataMember] public readonly float V;
        public ColorHSV((float h, float s, float v) tuple) : this(tuple.h, tuple.s, tuple.v) { }
        public ColorHSV(float h, float s, float v) { H = h; S = s; V = v; }
        public static ColorHSV Create(float h, float s, float v) => new ColorHSV(h, s, v);
        public static ColorHSV Create((float h, float s, float v) tuple) => new ColorHSV(tuple);
        public override bool Equals(object obj) => obj is ColorHSV x && Equals(x);
        public override int GetHashCode() => Hash.Combine(H.GetHashCode(), S.GetHashCode(), V.GetHashCode());
        public override string ToString() => $"ColorHSV(H = {H}, S = {S}, V = {V})";
        public void Deconstruct(out float h, out float s, out float v) {h = H; s = S; v = V; }
        public bool Equals(ColorHSV x) => H == x.H && S == x.S && V == x.V;
        public static bool operator ==(ColorHSV x0, ColorHSV x1) => x0.Equals(x1);
        public static bool operator !=(ColorHSV x0, ColorHSV x1) => !x0.Equals(x1);
        public static implicit operator ColorHSV((float h, float s, float v) tuple) => new ColorHSV(tuple);
        public static implicit operator (float h, float s, float v)(ColorHSV self) => (self.H, self.S, self.V);
        public bool AlmostEquals(ColorHSV x, float tolerance = Constants.Tolerance) => H.AlmostEquals(x.H, tolerance) && S.AlmostEquals(x.S, tolerance) && V.AlmostEquals(x.V, tolerance);
        public static ColorHSV Zero = new ColorHSV(default, default, default);
        public static ColorHSV MinValue = new ColorHSV(float.MinValue, float.MinValue, float.MinValue);
        public static ColorHSV MaxValue = new ColorHSV(float.MaxValue, float.MaxValue, float.MaxValue);
        public ColorHSV WithH(float x) => new ColorHSV(x, S, V);
        public ColorHSV WithS(float x) => new ColorHSV(H, x, V);
        public ColorHSV WithV(float x) => new ColorHSV(H, S, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct ColorHSL 
        : IEquatable< ColorHSL >
    {
        [DataMember] public readonly float H;
        [DataMember] public readonly float S;
        [DataMember] public readonly float L;
        public ColorHSL((float h, float s, float l) tuple) : this(tuple.h, tuple.s, tuple.l) { }
        public ColorHSL(float h, float s, float l) { H = h; S = s; L = l; }
        public static ColorHSL Create(float h, float s, float l) => new ColorHSL(h, s, l);
        public static ColorHSL Create((float h, float s, float l) tuple) => new ColorHSL(tuple);
        public override bool Equals(object obj) => obj is ColorHSL x && Equals(x);
        public override int GetHashCode() => Hash.Combine(H.GetHashCode(), S.GetHashCode(), L.GetHashCode());
        public override string ToString() => $"ColorHSL(H = {H}, S = {S}, L = {L})";
        public void Deconstruct(out float h, out float s, out float l) {h = H; s = S; l = L; }
        public bool Equals(ColorHSL x) => H == x.H && S == x.S && L == x.L;
        public static bool operator ==(ColorHSL x0, ColorHSL x1) => x0.Equals(x1);
        public static bool operator !=(ColorHSL x0, ColorHSL x1) => !x0.Equals(x1);
        public static implicit operator ColorHSL((float h, float s, float l) tuple) => new ColorHSL(tuple);
        public static implicit operator (float h, float s, float l)(ColorHSL self) => (self.H, self.S, self.L);
        public bool AlmostEquals(ColorHSL x, float tolerance = Constants.Tolerance) => H.AlmostEquals(x.H, tolerance) && S.AlmostEquals(x.S, tolerance) && L.AlmostEquals(x.L, tolerance);
        public static ColorHSL Zero = new ColorHSL(default, default, default);
        public static ColorHSL MinValue = new ColorHSL(float.MinValue, float.MinValue, float.MinValue);
        public static ColorHSL MaxValue = new ColorHSL(float.MaxValue, float.MaxValue, float.MaxValue);
        public ColorHSL WithH(float x) => new ColorHSL(x, S, L);
        public ColorHSL WithS(float x) => new ColorHSL(H, x, L);
        public ColorHSL WithL(float x) => new ColorHSL(H, S, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct ColorYCbCr 
        : IEquatable< ColorYCbCr >
    {
        [DataMember] public readonly float Y;
        [DataMember] public readonly float Cb;
        [DataMember] public readonly float Cr;
        public ColorYCbCr((float y, float cb, float cr) tuple) : this(tuple.y, tuple.cb, tuple.cr) { }
        public ColorYCbCr(float y, float cb, float cr) { Y = y; Cb = cb; Cr = cr; }
        public static ColorYCbCr Create(float y, float cb, float cr) => new ColorYCbCr(y, cb, cr);
        public static ColorYCbCr Create((float y, float cb, float cr) tuple) => new ColorYCbCr(tuple);
        public override bool Equals(object obj) => obj is ColorYCbCr x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Y.GetHashCode(), Cb.GetHashCode(), Cr.GetHashCode());
        public override string ToString() => $"ColorYCbCr(Y = {Y}, Cb = {Cb}, Cr = {Cr})";
        public void Deconstruct(out float y, out float cb, out float cr) {y = Y; cb = Cb; cr = Cr; }
        public bool Equals(ColorYCbCr x) => Y == x.Y && Cb == x.Cb && Cr == x.Cr;
        public static bool operator ==(ColorYCbCr x0, ColorYCbCr x1) => x0.Equals(x1);
        public static bool operator !=(ColorYCbCr x0, ColorYCbCr x1) => !x0.Equals(x1);
        public static implicit operator ColorYCbCr((float y, float cb, float cr) tuple) => new ColorYCbCr(tuple);
        public static implicit operator (float y, float cb, float cr)(ColorYCbCr self) => (self.Y, self.Cb, self.Cr);
        public bool AlmostEquals(ColorYCbCr x, float tolerance = Constants.Tolerance) => Y.AlmostEquals(x.Y, tolerance) && Cb.AlmostEquals(x.Cb, tolerance) && Cr.AlmostEquals(x.Cr, tolerance);
        public static ColorYCbCr Zero = new ColorYCbCr(default, default, default);
        public static ColorYCbCr MinValue = new ColorYCbCr(float.MinValue, float.MinValue, float.MinValue);
        public static ColorYCbCr MaxValue = new ColorYCbCr(float.MaxValue, float.MaxValue, float.MaxValue);
        public ColorYCbCr WithY(float x) => new ColorYCbCr(x, Cb, Cr);
        public ColorYCbCr WithCb(float x) => new ColorYCbCr(Y, x, Cr);
        public ColorYCbCr WithCr(float x) => new ColorYCbCr(Y, Cb, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct SphericalCoordinate 
        : IEquatable< SphericalCoordinate >
    {
        [DataMember] public readonly double Radius;
        [DataMember] public readonly double Azimuth;
        [DataMember] public readonly double Inclination;
        public SphericalCoordinate((double radius, double azimuth, double inclination) tuple) : this(tuple.radius, tuple.azimuth, tuple.inclination) { }
        public SphericalCoordinate(double radius, double azimuth, double inclination) { Radius = radius; Azimuth = azimuth; Inclination = inclination; }
        public static SphericalCoordinate Create(double radius, double azimuth, double inclination) => new SphericalCoordinate(radius, azimuth, inclination);
        public static SphericalCoordinate Create((double radius, double azimuth, double inclination) tuple) => new SphericalCoordinate(tuple);
        public override bool Equals(object obj) => obj is SphericalCoordinate x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Radius.GetHashCode(), Azimuth.GetHashCode(), Inclination.GetHashCode());
        public override string ToString() => $"SphericalCoordinate(Radius = {Radius}, Azimuth = {Azimuth}, Inclination = {Inclination})";
        public void Deconstruct(out double radius, out double azimuth, out double inclination) {radius = Radius; azimuth = Azimuth; inclination = Inclination; }
        public bool Equals(SphericalCoordinate x) => Radius == x.Radius && Azimuth == x.Azimuth && Inclination == x.Inclination;
        public static bool operator ==(SphericalCoordinate x0, SphericalCoordinate x1) => x0.Equals(x1);
        public static bool operator !=(SphericalCoordinate x0, SphericalCoordinate x1) => !x0.Equals(x1);
        public static implicit operator SphericalCoordinate((double radius, double azimuth, double inclination) tuple) => new SphericalCoordinate(tuple);
        public static implicit operator (double radius, double azimuth, double inclination)(SphericalCoordinate self) => (self.Radius, self.Azimuth, self.Inclination);
        public bool AlmostEquals(SphericalCoordinate x, float tolerance = Constants.Tolerance) => Radius.AlmostEquals(x.Radius, tolerance) && Azimuth.AlmostEquals(x.Azimuth, tolerance) && Inclination.AlmostEquals(x.Inclination, tolerance);
        public static SphericalCoordinate Zero = new SphericalCoordinate(default, default, default);
        public static SphericalCoordinate MinValue = new SphericalCoordinate(double.MinValue, double.MinValue, double.MinValue);
        public static SphericalCoordinate MaxValue = new SphericalCoordinate(double.MaxValue, double.MaxValue, double.MaxValue);
        public SphericalCoordinate WithRadius(double x) => new SphericalCoordinate(x, Azimuth, Inclination);
        public SphericalCoordinate WithAzimuth(double x) => new SphericalCoordinate(Radius, x, Inclination);
        public SphericalCoordinate WithInclination(double x) => new SphericalCoordinate(Radius, Azimuth, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct PolarCoordinate 
        : IEquatable< PolarCoordinate >
    {
        [DataMember] public readonly double Radius;
        [DataMember] public readonly double Azimuth;
        public PolarCoordinate((double radius, double azimuth) tuple) : this(tuple.radius, tuple.azimuth) { }
        public PolarCoordinate(double radius, double azimuth) { Radius = radius; Azimuth = azimuth; }
        public static PolarCoordinate Create(double radius, double azimuth) => new PolarCoordinate(radius, azimuth);
        public static PolarCoordinate Create((double radius, double azimuth) tuple) => new PolarCoordinate(tuple);
        public override bool Equals(object obj) => obj is PolarCoordinate x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Radius.GetHashCode(), Azimuth.GetHashCode());
        public override string ToString() => $"PolarCoordinate(Radius = {Radius}, Azimuth = {Azimuth})";
        public void Deconstruct(out double radius, out double azimuth) {radius = Radius; azimuth = Azimuth; }
        public bool Equals(PolarCoordinate x) => Radius == x.Radius && Azimuth == x.Azimuth;
        public static bool operator ==(PolarCoordinate x0, PolarCoordinate x1) => x0.Equals(x1);
        public static bool operator !=(PolarCoordinate x0, PolarCoordinate x1) => !x0.Equals(x1);
        public static implicit operator PolarCoordinate((double radius, double azimuth) tuple) => new PolarCoordinate(tuple);
        public static implicit operator (double radius, double azimuth)(PolarCoordinate self) => (self.Radius, self.Azimuth);
        public bool AlmostEquals(PolarCoordinate x, float tolerance = Constants.Tolerance) => Radius.AlmostEquals(x.Radius, tolerance) && Azimuth.AlmostEquals(x.Azimuth, tolerance);
        public static PolarCoordinate Zero = new PolarCoordinate(default, default);
        public static PolarCoordinate MinValue = new PolarCoordinate(double.MinValue, double.MinValue);
        public static PolarCoordinate MaxValue = new PolarCoordinate(double.MaxValue, double.MaxValue);
        public PolarCoordinate WithRadius(double x) => new PolarCoordinate(x, Azimuth);
        public PolarCoordinate WithAzimuth(double x) => new PolarCoordinate(Radius, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct LogPolarCoordinate 
        : IEquatable< LogPolarCoordinate >
    {
        [DataMember] public readonly double Rho;
        [DataMember] public readonly double Azimuth;
        public LogPolarCoordinate((double rho, double azimuth) tuple) : this(tuple.rho, tuple.azimuth) { }
        public LogPolarCoordinate(double rho, double azimuth) { Rho = rho; Azimuth = azimuth; }
        public static LogPolarCoordinate Create(double rho, double azimuth) => new LogPolarCoordinate(rho, azimuth);
        public static LogPolarCoordinate Create((double rho, double azimuth) tuple) => new LogPolarCoordinate(tuple);
        public override bool Equals(object obj) => obj is LogPolarCoordinate x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Rho.GetHashCode(), Azimuth.GetHashCode());
        public override string ToString() => $"LogPolarCoordinate(Rho = {Rho}, Azimuth = {Azimuth})";
        public void Deconstruct(out double rho, out double azimuth) {rho = Rho; azimuth = Azimuth; }
        public bool Equals(LogPolarCoordinate x) => Rho == x.Rho && Azimuth == x.Azimuth;
        public static bool operator ==(LogPolarCoordinate x0, LogPolarCoordinate x1) => x0.Equals(x1);
        public static bool operator !=(LogPolarCoordinate x0, LogPolarCoordinate x1) => !x0.Equals(x1);
        public static implicit operator LogPolarCoordinate((double rho, double azimuth) tuple) => new LogPolarCoordinate(tuple);
        public static implicit operator (double rho, double azimuth)(LogPolarCoordinate self) => (self.Rho, self.Azimuth);
        public bool AlmostEquals(LogPolarCoordinate x, float tolerance = Constants.Tolerance) => Rho.AlmostEquals(x.Rho, tolerance) && Azimuth.AlmostEquals(x.Azimuth, tolerance);
        public static LogPolarCoordinate Zero = new LogPolarCoordinate(default, default);
        public static LogPolarCoordinate MinValue = new LogPolarCoordinate(double.MinValue, double.MinValue);
        public static LogPolarCoordinate MaxValue = new LogPolarCoordinate(double.MaxValue, double.MaxValue);
        public LogPolarCoordinate WithRho(double x) => new LogPolarCoordinate(x, Azimuth);
        public LogPolarCoordinate WithAzimuth(double x) => new LogPolarCoordinate(Rho, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct CylindricalCoordinate 
        : IEquatable< CylindricalCoordinate >
    {
        [DataMember] public readonly double Radius;
        [DataMember] public readonly double Azimuth;
        [DataMember] public readonly double Height;
        public CylindricalCoordinate((double radius, double azimuth, double height) tuple) : this(tuple.radius, tuple.azimuth, tuple.height) { }
        public CylindricalCoordinate(double radius, double azimuth, double height) { Radius = radius; Azimuth = azimuth; Height = height; }
        public static CylindricalCoordinate Create(double radius, double azimuth, double height) => new CylindricalCoordinate(radius, azimuth, height);
        public static CylindricalCoordinate Create((double radius, double azimuth, double height) tuple) => new CylindricalCoordinate(tuple);
        public override bool Equals(object obj) => obj is CylindricalCoordinate x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Radius.GetHashCode(), Azimuth.GetHashCode(), Height.GetHashCode());
        public override string ToString() => $"CylindricalCoordinate(Radius = {Radius}, Azimuth = {Azimuth}, Height = {Height})";
        public void Deconstruct(out double radius, out double azimuth, out double height) {radius = Radius; azimuth = Azimuth; height = Height; }
        public bool Equals(CylindricalCoordinate x) => Radius == x.Radius && Azimuth == x.Azimuth && Height == x.Height;
        public static bool operator ==(CylindricalCoordinate x0, CylindricalCoordinate x1) => x0.Equals(x1);
        public static bool operator !=(CylindricalCoordinate x0, CylindricalCoordinate x1) => !x0.Equals(x1);
        public static implicit operator CylindricalCoordinate((double radius, double azimuth, double height) tuple) => new CylindricalCoordinate(tuple);
        public static implicit operator (double radius, double azimuth, double height)(CylindricalCoordinate self) => (self.Radius, self.Azimuth, self.Height);
        public bool AlmostEquals(CylindricalCoordinate x, float tolerance = Constants.Tolerance) => Radius.AlmostEquals(x.Radius, tolerance) && Azimuth.AlmostEquals(x.Azimuth, tolerance) && Height.AlmostEquals(x.Height, tolerance);
        public static CylindricalCoordinate Zero = new CylindricalCoordinate(default, default, default);
        public static CylindricalCoordinate MinValue = new CylindricalCoordinate(double.MinValue, double.MinValue, double.MinValue);
        public static CylindricalCoordinate MaxValue = new CylindricalCoordinate(double.MaxValue, double.MaxValue, double.MaxValue);
        public CylindricalCoordinate WithRadius(double x) => new CylindricalCoordinate(x, Azimuth, Height);
        public CylindricalCoordinate WithAzimuth(double x) => new CylindricalCoordinate(Radius, x, Height);
        public CylindricalCoordinate WithHeight(double x) => new CylindricalCoordinate(Radius, Azimuth, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct HorizontalCoordinate 
        : IEquatable< HorizontalCoordinate >
        , IArray< double >    
        , IComparable< HorizontalCoordinate >
    {
        [DataMember] public readonly double Azimuth;
        [DataMember] public readonly double Inclination;
        public HorizontalCoordinate((double azimuth, double inclination) tuple) : this(tuple.azimuth, tuple.inclination) { }
        public HorizontalCoordinate(double azimuth, double inclination) { Azimuth = azimuth; Inclination = inclination; }
        public static HorizontalCoordinate Create(double azimuth, double inclination) => new HorizontalCoordinate(azimuth, inclination);
        public static HorizontalCoordinate Create((double azimuth, double inclination) tuple) => new HorizontalCoordinate(tuple);
        public override bool Equals(object obj) => obj is HorizontalCoordinate x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Azimuth.GetHashCode(), Inclination.GetHashCode());
        public override string ToString() => $"HorizontalCoordinate(Azimuth = {Azimuth}, Inclination = {Inclination})";
        public void Deconstruct(out double azimuth, out double inclination) {azimuth = Azimuth; inclination = Inclination; }
        public bool Equals(HorizontalCoordinate x) => Azimuth == x.Azimuth && Inclination == x.Inclination;
        public static bool operator ==(HorizontalCoordinate x0, HorizontalCoordinate x1) => x0.Equals(x1);
        public static bool operator !=(HorizontalCoordinate x0, HorizontalCoordinate x1) => !x0.Equals(x1);
        public static implicit operator HorizontalCoordinate((double azimuth, double inclination) tuple) => new HorizontalCoordinate(tuple);
        public static implicit operator (double azimuth, double inclination)(HorizontalCoordinate self) => (self.Azimuth, self.Inclination);
        public bool AlmostEquals(HorizontalCoordinate x, float tolerance = Constants.Tolerance) => Azimuth.AlmostEquals(x.Azimuth, tolerance) && Inclination.AlmostEquals(x.Inclination, tolerance);
        public static HorizontalCoordinate Zero = new HorizontalCoordinate(default, default);
        public static HorizontalCoordinate MinValue = new HorizontalCoordinate(double.MinValue, double.MinValue);
        public static HorizontalCoordinate MaxValue = new HorizontalCoordinate(double.MaxValue, double.MaxValue);
        public HorizontalCoordinate WithAzimuth(double x) => new HorizontalCoordinate(x, Inclination);
        public HorizontalCoordinate WithInclination(double x) => new HorizontalCoordinate(Azimuth, x);
        public static HorizontalCoordinate operator +(HorizontalCoordinate value1, HorizontalCoordinate value2) => new HorizontalCoordinate(value1.Azimuth + value2.Azimuth,value1.Inclination + value2.Inclination);
        public static HorizontalCoordinate operator +(HorizontalCoordinate value1, double value2) => new HorizontalCoordinate(value1.Azimuth + value2,value1.Inclination + value2);
        public static HorizontalCoordinate operator +(double value1, HorizontalCoordinate value2) => new HorizontalCoordinate(value1 + value2.Azimuth,value1 + value2.Inclination);
        public static HorizontalCoordinate operator -(HorizontalCoordinate value1, HorizontalCoordinate value2) => new HorizontalCoordinate(value1.Azimuth - value2.Azimuth,value1.Inclination - value2.Inclination);
        public static HorizontalCoordinate operator -(HorizontalCoordinate value1, double value2) => new HorizontalCoordinate(value1.Azimuth - value2,value1.Inclination - value2);
        public static HorizontalCoordinate operator -(double value1, HorizontalCoordinate value2) => new HorizontalCoordinate(value1 - value2.Azimuth,value1 - value2.Inclination);
        public static HorizontalCoordinate operator *(HorizontalCoordinate value1, HorizontalCoordinate value2) => new HorizontalCoordinate(value1.Azimuth * value2.Azimuth,value1.Inclination * value2.Inclination);
        public static HorizontalCoordinate operator *(HorizontalCoordinate value1, double value2) => new HorizontalCoordinate(value1.Azimuth * value2,value1.Inclination * value2);
        public static HorizontalCoordinate operator *(double value1, HorizontalCoordinate value2) => new HorizontalCoordinate(value1 * value2.Azimuth,value1 * value2.Inclination);
        public static HorizontalCoordinate operator /(HorizontalCoordinate value1, HorizontalCoordinate value2) => new HorizontalCoordinate(value1.Azimuth / value2.Azimuth,value1.Inclination / value2.Inclination);
        public static HorizontalCoordinate operator /(HorizontalCoordinate value1, double value2) => new HorizontalCoordinate(value1.Azimuth / value2,value1.Inclination / value2);
        public static HorizontalCoordinate operator /(double value1, HorizontalCoordinate value2) => new HorizontalCoordinate(value1 / value2.Azimuth,value1 / value2.Inclination);
        public static HorizontalCoordinate One = new HorizontalCoordinate(1.0);
        public static HorizontalCoordinate UnitAzimuth = Zero.WithAzimuth(1.0);
        public static HorizontalCoordinate UnitInclination = Zero.WithInclination(1.0);
        public HorizontalCoordinate(double value) : this(value, value) { }
        public static HorizontalCoordinate operator -(HorizontalCoordinate value) => Zero - value;
        public static double Dot(HorizontalCoordinate value1, HorizontalCoordinate value2) => value1.Azimuth * value2.Azimuth + value1.Inclination * value2.Inclination;
        public double Dot(HorizontalCoordinate value) => HorizontalCoordinate.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => Azimuth.Abs() < tolerance && Inclination.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public double MinComponent() => (Azimuth).Min(Inclination);
        public double MaxComponent() => (Azimuth).Max(Inclination);
        public double SumComponents() => (Azimuth) + (Inclination);
        public double SumSqrComponents() => (Azimuth).Sqr() + (Inclination).Sqr();
        public double ProductComponents() => (Azimuth) * (Inclination);
        public double GetComponent(int n) => n == 0 ? Azimuth:Inclination;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 2;
        public int Count => NumComponents;
        public double this[int n] => n == 0 ? Azimuth : n == 1 ? Inclination : throw new ArgumentOutOfRangeException("n");
        public IIterator< double > Iterator => new ArrayIterator< double >(this);
        public bool IsNaN() => Azimuth.IsNaN() || Inclination.IsNaN();
        public bool IsInfinity() => Azimuth.IsInfinity() || Inclination.IsInfinity();
        public int CompareTo(HorizontalCoordinate x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(HorizontalCoordinate x0, HorizontalCoordinate x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(HorizontalCoordinate x0, HorizontalCoordinate x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(HorizontalCoordinate x0, HorizontalCoordinate x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(HorizontalCoordinate x0, HorizontalCoordinate x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct GeoCoordinate 
        : IEquatable< GeoCoordinate >
        , IArray< double >    
        , IComparable< GeoCoordinate >
    {
        [DataMember] public readonly double Latitude;
        [DataMember] public readonly double Longitude;
        [DataMember] public readonly double Altitude;
        public GeoCoordinate((double latitude, double longitude, double altitude) tuple) : this(tuple.latitude, tuple.longitude, tuple.altitude) { }
        public GeoCoordinate(double latitude, double longitude, double altitude) { Latitude = latitude; Longitude = longitude; Altitude = altitude; }
        public static GeoCoordinate Create(double latitude, double longitude, double altitude) => new GeoCoordinate(latitude, longitude, altitude);
        public static GeoCoordinate Create((double latitude, double longitude, double altitude) tuple) => new GeoCoordinate(tuple);
        public override bool Equals(object obj) => obj is GeoCoordinate x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Latitude.GetHashCode(), Longitude.GetHashCode(), Altitude.GetHashCode());
        public override string ToString() => $"GeoCoordinate(Latitude = {Latitude}, Longitude = {Longitude}, Altitude = {Altitude})";
        public void Deconstruct(out double latitude, out double longitude, out double altitude) {latitude = Latitude; longitude = Longitude; altitude = Altitude; }
        public bool Equals(GeoCoordinate x) => Latitude == x.Latitude && Longitude == x.Longitude && Altitude == x.Altitude;
        public static bool operator ==(GeoCoordinate x0, GeoCoordinate x1) => x0.Equals(x1);
        public static bool operator !=(GeoCoordinate x0, GeoCoordinate x1) => !x0.Equals(x1);
        public static implicit operator GeoCoordinate((double latitude, double longitude, double altitude) tuple) => new GeoCoordinate(tuple);
        public static implicit operator (double latitude, double longitude, double altitude)(GeoCoordinate self) => (self.Latitude, self.Longitude, self.Altitude);
        public bool AlmostEquals(GeoCoordinate x, float tolerance = Constants.Tolerance) => Latitude.AlmostEquals(x.Latitude, tolerance) && Longitude.AlmostEquals(x.Longitude, tolerance) && Altitude.AlmostEquals(x.Altitude, tolerance);
        public static GeoCoordinate Zero = new GeoCoordinate(default, default, default);
        public static GeoCoordinate MinValue = new GeoCoordinate(double.MinValue, double.MinValue, double.MinValue);
        public static GeoCoordinate MaxValue = new GeoCoordinate(double.MaxValue, double.MaxValue, double.MaxValue);
        public GeoCoordinate WithLatitude(double x) => new GeoCoordinate(x, Longitude, Altitude);
        public GeoCoordinate WithLongitude(double x) => new GeoCoordinate(Latitude, x, Altitude);
        public GeoCoordinate WithAltitude(double x) => new GeoCoordinate(Latitude, Longitude, x);
        public static GeoCoordinate operator +(GeoCoordinate value1, GeoCoordinate value2) => new GeoCoordinate(value1.Latitude + value2.Latitude,value1.Longitude + value2.Longitude,value1.Altitude + value2.Altitude);
        public static GeoCoordinate operator +(GeoCoordinate value1, double value2) => new GeoCoordinate(value1.Latitude + value2,value1.Longitude + value2,value1.Altitude + value2);
        public static GeoCoordinate operator +(double value1, GeoCoordinate value2) => new GeoCoordinate(value1 + value2.Latitude,value1 + value2.Longitude,value1 + value2.Altitude);
        public static GeoCoordinate operator -(GeoCoordinate value1, GeoCoordinate value2) => new GeoCoordinate(value1.Latitude - value2.Latitude,value1.Longitude - value2.Longitude,value1.Altitude - value2.Altitude);
        public static GeoCoordinate operator -(GeoCoordinate value1, double value2) => new GeoCoordinate(value1.Latitude - value2,value1.Longitude - value2,value1.Altitude - value2);
        public static GeoCoordinate operator -(double value1, GeoCoordinate value2) => new GeoCoordinate(value1 - value2.Latitude,value1 - value2.Longitude,value1 - value2.Altitude);
        public static GeoCoordinate operator *(GeoCoordinate value1, GeoCoordinate value2) => new GeoCoordinate(value1.Latitude * value2.Latitude,value1.Longitude * value2.Longitude,value1.Altitude * value2.Altitude);
        public static GeoCoordinate operator *(GeoCoordinate value1, double value2) => new GeoCoordinate(value1.Latitude * value2,value1.Longitude * value2,value1.Altitude * value2);
        public static GeoCoordinate operator *(double value1, GeoCoordinate value2) => new GeoCoordinate(value1 * value2.Latitude,value1 * value2.Longitude,value1 * value2.Altitude);
        public static GeoCoordinate operator /(GeoCoordinate value1, GeoCoordinate value2) => new GeoCoordinate(value1.Latitude / value2.Latitude,value1.Longitude / value2.Longitude,value1.Altitude / value2.Altitude);
        public static GeoCoordinate operator /(GeoCoordinate value1, double value2) => new GeoCoordinate(value1.Latitude / value2,value1.Longitude / value2,value1.Altitude / value2);
        public static GeoCoordinate operator /(double value1, GeoCoordinate value2) => new GeoCoordinate(value1 / value2.Latitude,value1 / value2.Longitude,value1 / value2.Altitude);
        public static GeoCoordinate One = new GeoCoordinate(1.0);
        public static GeoCoordinate UnitLatitude = Zero.WithLatitude(1.0);
        public static GeoCoordinate UnitLongitude = Zero.WithLongitude(1.0);
        public static GeoCoordinate UnitAltitude = Zero.WithAltitude(1.0);
        public GeoCoordinate(double value) : this(value, value, value) { }
        public static GeoCoordinate operator -(GeoCoordinate value) => Zero - value;
        public static double Dot(GeoCoordinate value1, GeoCoordinate value2) => value1.Latitude * value2.Latitude + value1.Longitude * value2.Longitude + value1.Altitude * value2.Altitude;
        public double Dot(GeoCoordinate value) => GeoCoordinate.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => Latitude.Abs() < tolerance && Longitude.Abs() < tolerance && Altitude.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public double MinComponent() => (Latitude).Min(Longitude).Min(Altitude);
        public double MaxComponent() => (Latitude).Max(Longitude).Max(Altitude);
        public double SumComponents() => (Latitude) + (Longitude) + (Altitude);
        public double SumSqrComponents() => (Latitude).Sqr() + (Longitude).Sqr() + (Altitude).Sqr();
        public double ProductComponents() => (Latitude) * (Longitude) * (Altitude);
        public double GetComponent(int n) => n == 0 ? Latitude : n == 1 ? Longitude:Altitude;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 3;
        public int Count => NumComponents;
        public double this[int n] => n == 0 ? Latitude : n == 1 ? Longitude : n == 2 ? Altitude : throw new ArgumentOutOfRangeException("n");
        public IIterator< double > Iterator => new ArrayIterator< double >(this);
        public bool IsNaN() => Latitude.IsNaN() || Longitude.IsNaN() || Altitude.IsNaN();
        public bool IsInfinity() => Latitude.IsInfinity() || Longitude.IsInfinity() || Altitude.IsInfinity();
        public int CompareTo(GeoCoordinate x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(GeoCoordinate x0, GeoCoordinate x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(GeoCoordinate x0, GeoCoordinate x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(GeoCoordinate x0, GeoCoordinate x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(GeoCoordinate x0, GeoCoordinate x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct AxisAngle 
        : IEquatable< AxisAngle >
    {
        [DataMember] public readonly DVector3 Axis;
        [DataMember] public readonly double Angle;
        public AxisAngle((DVector3 axis, double angle) tuple) : this(tuple.axis, tuple.angle) { }
        public AxisAngle(DVector3 axis, double angle) { Axis = axis; Angle = angle; }
        public static AxisAngle Create(DVector3 axis, double angle) => new AxisAngle(axis, angle);
        public static AxisAngle Create((DVector3 axis, double angle) tuple) => new AxisAngle(tuple);
        public override bool Equals(object obj) => obj is AxisAngle x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Axis.GetHashCode(), Angle.GetHashCode());
        public override string ToString() => $"AxisAngle(Axis = {Axis}, Angle = {Angle})";
        public void Deconstruct(out DVector3 axis, out double angle) {axis = Axis; angle = Angle; }
        public bool Equals(AxisAngle x) => Axis == x.Axis && Angle == x.Angle;
        public static bool operator ==(AxisAngle x0, AxisAngle x1) => x0.Equals(x1);
        public static bool operator !=(AxisAngle x0, AxisAngle x1) => !x0.Equals(x1);
        public static implicit operator AxisAngle((DVector3 axis, double angle) tuple) => new AxisAngle(tuple);
        public static implicit operator (DVector3 axis, double angle)(AxisAngle self) => (self.Axis, self.Angle);
        public bool AlmostEquals(AxisAngle x, float tolerance = Constants.Tolerance) => Axis.AlmostEquals(x.Axis, tolerance) && Angle.AlmostEquals(x.Angle, tolerance);
        public static AxisAngle Zero = new AxisAngle(default, default);
        public static AxisAngle MinValue = new AxisAngle(DVector3.MinValue, double.MinValue);
        public static AxisAngle MaxValue = new AxisAngle(DVector3.MaxValue, double.MaxValue);
        public AxisAngle WithAxis(DVector3 x) => new AxisAngle(x, Angle);
        public AxisAngle WithAngle(double x) => new AxisAngle(Axis, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Euler 
        : IEquatable< Euler >
        , IArray< double >    
        , IComparable< Euler >
    {
        [DataMember] public readonly double Yaw;
        [DataMember] public readonly double Pitch;
        [DataMember] public readonly double Roll;
        public Euler((double yaw, double pitch, double roll) tuple) : this(tuple.yaw, tuple.pitch, tuple.roll) { }
        public Euler(double yaw, double pitch, double roll) { Yaw = yaw; Pitch = pitch; Roll = roll; }
        public static Euler Create(double yaw, double pitch, double roll) => new Euler(yaw, pitch, roll);
        public static Euler Create((double yaw, double pitch, double roll) tuple) => new Euler(tuple);
        public override bool Equals(object obj) => obj is Euler x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Yaw.GetHashCode(), Pitch.GetHashCode(), Roll.GetHashCode());
        public override string ToString() => $"Euler(Yaw = {Yaw}, Pitch = {Pitch}, Roll = {Roll})";
        public void Deconstruct(out double yaw, out double pitch, out double roll) {yaw = Yaw; pitch = Pitch; roll = Roll; }
        public bool Equals(Euler x) => Yaw == x.Yaw && Pitch == x.Pitch && Roll == x.Roll;
        public static bool operator ==(Euler x0, Euler x1) => x0.Equals(x1);
        public static bool operator !=(Euler x0, Euler x1) => !x0.Equals(x1);
        public static implicit operator Euler((double yaw, double pitch, double roll) tuple) => new Euler(tuple);
        public static implicit operator (double yaw, double pitch, double roll)(Euler self) => (self.Yaw, self.Pitch, self.Roll);
        public bool AlmostEquals(Euler x, float tolerance = Constants.Tolerance) => Yaw.AlmostEquals(x.Yaw, tolerance) && Pitch.AlmostEquals(x.Pitch, tolerance) && Roll.AlmostEquals(x.Roll, tolerance);
        public static Euler Zero = new Euler(default, default, default);
        public static Euler MinValue = new Euler(double.MinValue, double.MinValue, double.MinValue);
        public static Euler MaxValue = new Euler(double.MaxValue, double.MaxValue, double.MaxValue);
        public Euler WithYaw(double x) => new Euler(x, Pitch, Roll);
        public Euler WithPitch(double x) => new Euler(Yaw, x, Roll);
        public Euler WithRoll(double x) => new Euler(Yaw, Pitch, x);
        public static Euler operator +(Euler value1, Euler value2) => new Euler(value1.Yaw + value2.Yaw,value1.Pitch + value2.Pitch,value1.Roll + value2.Roll);
        public static Euler operator +(Euler value1, double value2) => new Euler(value1.Yaw + value2,value1.Pitch + value2,value1.Roll + value2);
        public static Euler operator +(double value1, Euler value2) => new Euler(value1 + value2.Yaw,value1 + value2.Pitch,value1 + value2.Roll);
        public static Euler operator -(Euler value1, Euler value2) => new Euler(value1.Yaw - value2.Yaw,value1.Pitch - value2.Pitch,value1.Roll - value2.Roll);
        public static Euler operator -(Euler value1, double value2) => new Euler(value1.Yaw - value2,value1.Pitch - value2,value1.Roll - value2);
        public static Euler operator -(double value1, Euler value2) => new Euler(value1 - value2.Yaw,value1 - value2.Pitch,value1 - value2.Roll);
        public static Euler operator *(Euler value1, Euler value2) => new Euler(value1.Yaw * value2.Yaw,value1.Pitch * value2.Pitch,value1.Roll * value2.Roll);
        public static Euler operator *(Euler value1, double value2) => new Euler(value1.Yaw * value2,value1.Pitch * value2,value1.Roll * value2);
        public static Euler operator *(double value1, Euler value2) => new Euler(value1 * value2.Yaw,value1 * value2.Pitch,value1 * value2.Roll);
        public static Euler operator /(Euler value1, Euler value2) => new Euler(value1.Yaw / value2.Yaw,value1.Pitch / value2.Pitch,value1.Roll / value2.Roll);
        public static Euler operator /(Euler value1, double value2) => new Euler(value1.Yaw / value2,value1.Pitch / value2,value1.Roll / value2);
        public static Euler operator /(double value1, Euler value2) => new Euler(value1 / value2.Yaw,value1 / value2.Pitch,value1 / value2.Roll);
        public static Euler One = new Euler(1.0);
        public static Euler UnitYaw = Zero.WithYaw(1.0);
        public static Euler UnitPitch = Zero.WithPitch(1.0);
        public static Euler UnitRoll = Zero.WithRoll(1.0);
        public Euler(double value) : this(value, value, value) { }
        public static Euler operator -(Euler value) => Zero - value;
        public static double Dot(Euler value1, Euler value2) => value1.Yaw * value2.Yaw + value1.Pitch * value2.Pitch + value1.Roll * value2.Roll;
        public double Dot(Euler value) => Euler.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => Yaw.Abs() < tolerance && Pitch.Abs() < tolerance && Roll.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public double MinComponent() => (Yaw).Min(Pitch).Min(Roll);
        public double MaxComponent() => (Yaw).Max(Pitch).Max(Roll);
        public double SumComponents() => (Yaw) + (Pitch) + (Roll);
        public double SumSqrComponents() => (Yaw).Sqr() + (Pitch).Sqr() + (Roll).Sqr();
        public double ProductComponents() => (Yaw) * (Pitch) * (Roll);
        public double GetComponent(int n) => n == 0 ? Yaw : n == 1 ? Pitch:Roll;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 3;
        public int Count => NumComponents;
        public double this[int n] => n == 0 ? Yaw : n == 1 ? Pitch : n == 2 ? Roll : throw new ArgumentOutOfRangeException("n");
        public IIterator< double > Iterator => new ArrayIterator< double >(this);
        public bool IsNaN() => Yaw.IsNaN() || Pitch.IsNaN() || Roll.IsNaN();
        public bool IsInfinity() => Yaw.IsInfinity() || Pitch.IsInfinity() || Roll.IsInfinity();
        public int CompareTo(Euler x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Euler x0, Euler x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Euler x0, Euler x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Euler x0, Euler x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Euler x0, Euler x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Point 
        : IEquatable< Point >
        , IArray< double >    
        , IComparable< Point >
    {
        [DataMember] public readonly double X;
        [DataMember] public readonly double Y;
        public Point((double x, double y) tuple) : this(tuple.x, tuple.y) { }
        public Point(double x, double y) { X = x; Y = y; }
        public static Point Create(double x, double y) => new Point(x, y);
        public static Point Create((double x, double y) tuple) => new Point(tuple);
        public override bool Equals(object obj) => obj is Point x && Equals(x);
        public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
        public override string ToString() => $"Point(X = {X}, Y = {Y})";
        public void Deconstruct(out double x, out double y) {x = X; y = Y; }
        public bool Equals(Point x) => X == x.X && Y == x.Y;
        public static bool operator ==(Point x0, Point x1) => x0.Equals(x1);
        public static bool operator !=(Point x0, Point x1) => !x0.Equals(x1);
        public static implicit operator Point((double x, double y) tuple) => new Point(tuple);
        public static implicit operator (double x, double y)(Point self) => (self.X, self.Y);
        public bool AlmostEquals(Point x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance);
        public static Point Zero = new Point(default, default);
        public static Point MinValue = new Point(double.MinValue, double.MinValue);
        public static Point MaxValue = new Point(double.MaxValue, double.MaxValue);
        public Point WithX(double x) => new Point(x, Y);
        public Point WithY(double x) => new Point(X, x);
        public static Point operator +(Point value1, Point value2) => new Point(value1.X + value2.X,value1.Y + value2.Y);
        public static Point operator +(Point value1, double value2) => new Point(value1.X + value2,value1.Y + value2);
        public static Point operator +(double value1, Point value2) => new Point(value1 + value2.X,value1 + value2.Y);
        public static Point operator -(Point value1, Point value2) => new Point(value1.X - value2.X,value1.Y - value2.Y);
        public static Point operator -(Point value1, double value2) => new Point(value1.X - value2,value1.Y - value2);
        public static Point operator -(double value1, Point value2) => new Point(value1 - value2.X,value1 - value2.Y);
        public static Point operator *(Point value1, Point value2) => new Point(value1.X * value2.X,value1.Y * value2.Y);
        public static Point operator *(Point value1, double value2) => new Point(value1.X * value2,value1.Y * value2);
        public static Point operator *(double value1, Point value2) => new Point(value1 * value2.X,value1 * value2.Y);
        public static Point operator /(Point value1, Point value2) => new Point(value1.X / value2.X,value1.Y / value2.Y);
        public static Point operator /(Point value1, double value2) => new Point(value1.X / value2,value1.Y / value2);
        public static Point operator /(double value1, Point value2) => new Point(value1 / value2.X,value1 / value2.Y);
        public static Point One = new Point(1.0);
        public static Point UnitX = Zero.WithX(1.0);
        public static Point UnitY = Zero.WithY(1.0);
        public Point(double value) : this(value, value) { }
        public static Point operator -(Point value) => Zero - value;
        public static double Dot(Point value1, Point value2) => value1.X * value2.X + value1.Y * value2.Y;
        public double Dot(Point value) => Point.Dot(this, value);
        public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance;
        public bool AnyComponentNegative() => MinComponent() < 0;
        public double MinComponent() => (X).Min(Y);
        public double MaxComponent() => (X).Max(Y);
        public double SumComponents() => (X) + (Y);
        public double SumSqrComponents() => (X).Sqr() + (Y).Sqr();
        public double ProductComponents() => (X) * (Y);
        public double GetComponent(int n) => n == 0 ? X:Y;
        public double MagnitudeSquared() => SumSqrComponents();
        public double Magnitude() => MagnitudeSquared().Sqrt();        
        public const int NumComponents = 2;
        public int Count => NumComponents;
        public double this[int n] => n == 0 ? X : n == 1 ? Y : throw new ArgumentOutOfRangeException("n");
        public IIterator< double > Iterator => new ArrayIterator< double >(this);
        public bool IsNaN() => X.IsNaN() || Y.IsNaN();
        public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity();
        public int CompareTo(Point x) => (MagnitudeSquared() - x.MagnitudeSquared()).Sign();
        public static bool operator <(Point x0, Point x1) => x0.CompareTo(x1) < 0;
        public static bool operator <=(Point x0, Point x1) => x0.CompareTo(x1) <= 0;
        public static bool operator >(Point x0, Point x1) => x0.CompareTo(x1) > 0;
        public static bool operator >=(Point x0, Point x1) => x0.CompareTo(x1) >= 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Size 
        : IEquatable< Size >
    {
        [DataMember] public readonly double Width;
        [DataMember] public readonly double Height;
        public Size((double width, double height) tuple) : this(tuple.width, tuple.height) { }
        public Size(double width, double height) { Width = width; Height = height; }
        public static Size Create(double width, double height) => new Size(width, height);
        public static Size Create((double width, double height) tuple) => new Size(tuple);
        public override bool Equals(object obj) => obj is Size x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Width.GetHashCode(), Height.GetHashCode());
        public override string ToString() => $"Size(Width = {Width}, Height = {Height})";
        public void Deconstruct(out double width, out double height) {width = Width; height = Height; }
        public bool Equals(Size x) => Width == x.Width && Height == x.Height;
        public static bool operator ==(Size x0, Size x1) => x0.Equals(x1);
        public static bool operator !=(Size x0, Size x1) => !x0.Equals(x1);
        public static implicit operator Size((double width, double height) tuple) => new Size(tuple);
        public static implicit operator (double width, double height)(Size self) => (self.Width, self.Height);
        public bool AlmostEquals(Size x, float tolerance = Constants.Tolerance) => Width.AlmostEquals(x.Width, tolerance) && Height.AlmostEquals(x.Height, tolerance);
        public static Size Zero = new Size(default, default);
        public static Size MinValue = new Size(double.MinValue, double.MinValue);
        public static Size MaxValue = new Size(double.MaxValue, double.MaxValue);
        public Size WithWidth(double x) => new Size(x, Height);
        public Size WithHeight(double x) => new Size(Width, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Rectangle 
        : IEquatable< Rectangle >
    {
        [DataMember] public readonly Point TopLeft;
        [DataMember] public readonly Size Size;
        public Rectangle((Point topleft, Size size) tuple) : this(tuple.topleft, tuple.size) { }
        public Rectangle(Point topleft, Size size) { TopLeft = topleft; Size = size; }
        public static Rectangle Create(Point topleft, Size size) => new Rectangle(topleft, size);
        public static Rectangle Create((Point topleft, Size size) tuple) => new Rectangle(tuple);
        public override bool Equals(object obj) => obj is Rectangle x && Equals(x);
        public override int GetHashCode() => Hash.Combine(TopLeft.GetHashCode(), Size.GetHashCode());
        public override string ToString() => $"Rectangle(TopLeft = {TopLeft}, Size = {Size})";
        public void Deconstruct(out Point topleft, out Size size) {topleft = TopLeft; size = Size; }
        public bool Equals(Rectangle x) => TopLeft == x.TopLeft && Size == x.Size;
        public static bool operator ==(Rectangle x0, Rectangle x1) => x0.Equals(x1);
        public static bool operator !=(Rectangle x0, Rectangle x1) => !x0.Equals(x1);
        public static implicit operator Rectangle((Point topleft, Size size) tuple) => new Rectangle(tuple);
        public static implicit operator (Point topleft, Size size)(Rectangle self) => (self.TopLeft, self.Size);
        public bool AlmostEquals(Rectangle x, float tolerance = Constants.Tolerance) => TopLeft.AlmostEquals(x.TopLeft, tolerance) && Size.AlmostEquals(x.Size, tolerance);
        public static Rectangle Zero = new Rectangle(default, default);
        public static Rectangle MinValue = new Rectangle(Point.MinValue, Size.MinValue);
        public static Rectangle MaxValue = new Rectangle(Point.MaxValue, Size.MaxValue);
        public Rectangle WithTopLeft(Point x) => new Rectangle(x, Size);
        public Rectangle WithSize(Size x) => new Rectangle(TopLeft, x);
    }

    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Circle 
        : IEquatable< Circle >
    {
        [DataMember] public readonly Point Center;
        [DataMember] public readonly double Radius;
        public Circle((Point center, double radius) tuple) : this(tuple.center, tuple.radius) { }
        public Circle(Point center, double radius) { Center = center; Radius = radius; }
        public static Circle Create(Point center, double radius) => new Circle(center, radius);
        public static Circle Create((Point center, double radius) tuple) => new Circle(tuple);
        public override bool Equals(object obj) => obj is Circle x && Equals(x);
        public override int GetHashCode() => Hash.Combine(Center.GetHashCode(), Radius.GetHashCode());
        public override string ToString() => $"Circle(Center = {Center}, Radius = {Radius})";
        public void Deconstruct(out Point center, out double radius) {center = Center; radius = Radius; }
        public bool Equals(Circle x) => Center == x.Center && Radius == x.Radius;
        public static bool operator ==(Circle x0, Circle x1) => x0.Equals(x1);
        public static bool operator !=(Circle x0, Circle x1) => !x0.Equals(x1);
        public static implicit operator Circle((Point center, double radius) tuple) => new Circle(tuple);
        public static implicit operator (Point center, double radius)(Circle self) => (self.Center, self.Radius);
        public bool AlmostEquals(Circle x, float tolerance = Constants.Tolerance) => Center.AlmostEquals(x.Center, tolerance) && Radius.AlmostEquals(x.Radius, tolerance);
        public static Circle Zero = new Circle(default, default);
        public static Circle MinValue = new Circle(Point.MinValue, double.MinValue);
        public static Circle MaxValue = new Circle(Point.MaxValue, double.MaxValue);
        public Circle WithCenter(Point x) => new Circle(x, Radius);
        public Circle WithRadius(double x) => new Circle(Center, x);
    }
}
