[0:00.001] Creating compiler
[0:00.001] Opening files
[0:00.093] Starting compiling C:\Users\cdigg\git\plato\PlatoStandardLibrary\intrinsics.plato at 2023-09-13 8:33:45 PM
[0:00.093] Starting to parse 38 lines containing 1086 characters
[0:00.093] Tokenization phase
[0:00.095] Completed tokenization
[0:00.096] Starting main parse
[0:00.098] Completed parsing
[0:00.098] Gathering parse errors
[0:00.099] Found 0 errors
[0:00.099] Gathering parse nodes
[0:00.099] Found 782 nodes
[0:00.099] Creating parse tree
[0:00.099] Creating Concrete Syntax Tree (CST)
[0:00.107] Creating Abstract Syntax Tree (AST)
[0:00.115] Completed all steps, result is successful
[0:00.134] Starting compiling C:\Users\cdigg\git\plato\PlatoStandardLibrary\concepts.plato at 2023-09-13 8:33:45 PM
[0:00.134] Starting to parse 124 lines containing 2557 characters
[0:00.134] Tokenization phase
[0:00.136] Completed tokenization
[0:00.136] Starting main parse
[0:00.148] Completed parsing
[0:00.148] Gathering parse errors
[0:00.148] Found 0 errors
[0:00.148] Gathering parse nodes
[0:00.148] Found 1348 nodes
[0:00.148] Creating parse tree
[0:00.148] Creating Concrete Syntax Tree (CST)
[0:00.149] Creating Abstract Syntax Tree (AST)
[0:00.158] Completed all steps, result is successful
[0:00.176] Starting compiling C:\Users\cdigg\git\plato\PlatoStandardLibrary\types.plato at 2023-09-13 8:33:45 PM
[0:00.176] Starting to parse 872 lines containing 12978 characters
[0:00.176] Tokenization phase
[0:00.182] Completed tokenization
[0:00.183] Starting main parse
[0:00.188] Completed parsing
[0:00.188] Gathering parse errors
[0:00.188] Found 0 errors
[0:00.188] Gathering parse nodes
[0:00.188] Found 3800 nodes
[0:00.188] Creating parse tree
[0:00.188] Creating Concrete Syntax Tree (CST)
[0:00.190] Creating Abstract Syntax Tree (AST)
[0:00.192] Completed all steps, result is successful
[0:00.247] Starting compiling C:\Users\cdigg\git\plato\PlatoStandardLibrary\libraries.plato at 2023-09-13 8:33:45 PM
[0:00.247] Starting to parse 442 lines containing 11214 characters
[0:00.247] Tokenization phase
[0:00.255] Completed tokenization
[0:00.255] Starting main parse
[0:00.264] Completed parsing
[0:00.264] Gathering parse errors
[0:00.264] Found 0 errors
[0:00.264] Gathering parse nodes
[0:00.264] Found 6283 nodes
[0:00.264] Creating parse tree
[0:00.264] Creating Concrete Syntax Tree (CST)
[0:00.267] Creating Abstract Syntax Tree (AST)
[0:00.273] Completed all steps, result is successful
[0:00.273] Applying syntax coloring
[0:00.273] Completed syntax coloring
[0:00.284] Initializing Compiler
[0:00.284] Gathering parsers
[0:00.284] Gathering AST trees
[0:00.285] Gathering type declarations
[0:00.292] Creating symbol resolver
[0:00.294] Creating type definitions
[0:00.301] Found 0 symbol resolution errors
[0:00.301] Gathering function definitions
[0:00.302] Found 428 functions
[0:00.302] Checking semantics
[0:00.302] Creating Reified Types
[0:00.319] Found 117 types
[0:00.319] Created a total of 1465 reified functions
[0:00.319] Adding library functions to reified types
[0:00.366] Grouping Reified functions by name for faster type resolution
[0:00.369] Creating function analysis
[0:00.374] Function AnalysisConcept functions
Original function: Any_9:Concept.FieldNames(): Concept:Array<ConcreteType:String>;
New signature: Any_9:Concept.FieldNames(): $0
Variables: $0
Constraints:
   $0 implements (Array, String)
Original function: Any_9:Concept.FieldValues(x: TypeVariable:Self): Concept:Array<Concept:Any>;
New signature: Any_9:Concept.FieldValues(x: Any): $1
Variables: $1, $2
Constraints:
   $2 implements (Any)
   $1 implements (Array, $2)
Original function: Any_9:Concept.FieldTypes(x: TypeVariable:Self): Concept:Array<ConcreteType:Type>;
New signature: Any_9:Concept.FieldTypes(x: Any): $3
Variables: $3
Constraints:
   $3 implements (Array, Type)
Original function: Any_9:Concept.TypeOf(): ConcreteType:Type;
New signature: Any_9:Concept.TypeOf(): Type
Variables: 
Constraints:
Original function: Value_12:Concept.Default(): TypeVariable:Self;
New signature: Value_12:Concept.Default(): Value
Variables: 
Constraints:
Original function: Array_15:Concept.Count(xs: TypeVariable:Self): ConcreteType:Integer;
New signature: Array_15:Concept.Count(xs: Array): Integer
Variables: $4
Constraints:
   $4 implements (Any)
Original function: Array_15:Concept.At(xs: TypeVariable:Self,n: ConcreteType:Integer): TypeVariable:T;
New signature: Array_15:Concept.At(xs: Array, n: Integer): $5
Variables: $5
Constraints:
   $5 implements (Any)
Original function: Measure_21:Concept.Value(x: TypeVariable:Self): ConcreteType:Number;
New signature: Measure_21:Concept.Value(x: Measure): Number
Variables: 
Constraints:
Original function: Numerical_24:Concept.Zero(): TypeVariable:Self;
New signature: Numerical_24:Concept.Zero(): Numerical
Variables: 
Constraints:
Original function: Numerical_24:Concept.One(): TypeVariable:Self;
New signature: Numerical_24:Concept.One(): Numerical
Variables: 
Constraints:
Original function: Numerical_24:Concept.MinValue(): TypeVariable:Self;
New signature: Numerical_24:Concept.MinValue(): Numerical
Variables: 
Constraints:
Original function: Numerical_24:Concept.MaxValue(): TypeVariable:Self;
New signature: Numerical_24:Concept.MaxValue(): Numerical
Variables: 
Constraints:
Original function: Magnitudinal_27:Concept.Magnitude(x: TypeVariable:Self): ConcreteType:Number;
New signature: Magnitudinal_27:Concept.Magnitude(x: Magnitudinal): Number
Variables: 
Constraints:
Original function: Comparable_30:Concept.Compare(x: TypeVariable:Self): ConcreteType:Integer;
New signature: Comparable_30:Concept.Compare(x: Comparable): Integer
Variables: 
Constraints:
Original function: Equatable_33:Concept.Equals(a: TypeVariable:Self,b: TypeVariable:Self): ConcreteType:Boolean;
New signature: Equatable_33:Concept.Equals(a: Equatable, b: Equatable): Boolean
Variables: 
Constraints:
Original function: Arithmetic_36:Concept.Add(self: TypeVariable:Self,other: TypeVariable:Self): TypeVariable:Self;
New signature: Arithmetic_36:Concept.Add(self: Arithmetic, other: Arithmetic): Arithmetic
Variables: 
Constraints:
Original function: Arithmetic_36:Concept.Subtract(self: TypeVariable:Self,other: TypeVariable:Self): TypeVariable:Self;
New signature: Arithmetic_36:Concept.Subtract(self: Arithmetic, other: Arithmetic): Arithmetic
Variables: 
Constraints:
Original function: Arithmetic_36:Concept.Negative(self: TypeVariable:Self): TypeVariable:Self;
New signature: Arithmetic_36:Concept.Negative(self: Arithmetic): Arithmetic
Variables: 
Constraints:
Original function: Arithmetic_36:Concept.Reciprocal(self: TypeVariable:Self): TypeVariable:Self;
New signature: Arithmetic_36:Concept.Reciprocal(self: Arithmetic): Arithmetic
Variables: 
Constraints:
Original function: Arithmetic_36:Concept.Multiply(self: TypeVariable:Self,other: TypeVariable:Self): TypeVariable:Self;
New signature: Arithmetic_36:Concept.Multiply(self: Arithmetic, other: Arithmetic): Arithmetic
Variables: 
Constraints:
Original function: Arithmetic_36:Concept.Divide(self: TypeVariable:Self,other: TypeVariable:Self): TypeVariable:Self;
New signature: Arithmetic_36:Concept.Divide(self: Arithmetic, other: Arithmetic): Arithmetic
Variables: 
Constraints:
Original function: Arithmetic_36:Concept.Modulo(self: TypeVariable:Self,other: TypeVariable:Self): TypeVariable:Self;
New signature: Arithmetic_36:Concept.Modulo(self: Arithmetic, other: Arithmetic): Arithmetic
Variables: 
Constraints:
Original function: ScalarArithmetic_39:Concept.Add(self: TypeVariable:Self,scalar: ConcreteType:Number): TypeVariable:Self;
New signature: ScalarArithmetic_39:Concept.Add(self: ScalarArithmetic, scalar: Number): ScalarArithmetic
Variables: 
Constraints:
Original function: ScalarArithmetic_39:Concept.Subtract(self: TypeVariable:Self,scalar: ConcreteType:Number): TypeVariable:Self;
New signature: ScalarArithmetic_39:Concept.Subtract(self: ScalarArithmetic, scalar: Number): ScalarArithmetic
Variables: 
Constraints:
Original function: ScalarArithmetic_39:Concept.Multiply(self: TypeVariable:Self,scalar: ConcreteType:Number): TypeVariable:Self;
New signature: ScalarArithmetic_39:Concept.Multiply(self: ScalarArithmetic, scalar: Number): ScalarArithmetic
Variables: 
Constraints:
Original function: ScalarArithmetic_39:Concept.Divide(self: TypeVariable:Self,scalar: ConcreteType:Number): TypeVariable:Self;
New signature: ScalarArithmetic_39:Concept.Divide(self: ScalarArithmetic, scalar: Number): ScalarArithmetic
Variables: 
Constraints:
Original function: ScalarArithmetic_39:Concept.Modulo(self: TypeVariable:Self,scalar: ConcreteType:Number): TypeVariable:Self;
New signature: ScalarArithmetic_39:Concept.Modulo(self: ScalarArithmetic, scalar: Number): ScalarArithmetic
Variables: 
Constraints:
Original function: BooleanOperations_42:Concept.And(a: TypeVariable:Self,b: TypeVariable:Self): TypeVariable:Self;
New signature: BooleanOperations_42:Concept.And(a: BooleanOperations, b: BooleanOperations): BooleanOperations
Variables: 
Constraints:
Original function: BooleanOperations_42:Concept.Or(a: TypeVariable:Self,b: TypeVariable:Self): TypeVariable:Self;
New signature: BooleanOperations_42:Concept.Or(a: BooleanOperations, b: BooleanOperations): BooleanOperations
Variables: 
Constraints:
Original function: BooleanOperations_42:Concept.Not(a: TypeVariable:Self): TypeVariable:Self;
New signature: BooleanOperations_42:Concept.Not(a: BooleanOperations): BooleanOperations
Variables: 
Constraints:
Original function: Interval_45:Concept.Min(x: TypeVariable:Self): TypeVariable:T;
New signature: Interval_45:Concept.Min(x: Interval): $6
Variables: $6
Constraints:
   $6 implements (Numerical)
Original function: Interval_45:Concept.Max(x: TypeVariable:Self): TypeVariable:T;
New signature: Interval_45:Concept.Max(x: Interval): $7
Variables: $7
Constraints:
   $7 implements (Numerical)
Generic library functions
Original function: Intrinsics_6:Library.Interpolate(xs: Concept:Array): ConcreteType:String;
New signature: Intrinsics_6:Library.Interpolate(xs: $26): String
Variables: $26, $27
Constraints:
   $27 implements (Any)
   $26 implements (Array, $27)
Original function: Intrinsics_6:Library.Throw(x: Concept:Any): Concept:Any;
New signature: Intrinsics_6:Library.Throw(x: $28): $29
Variables: $28, $29
Constraints:
   $28 implements (Any)
   $29 implements (Any)
Original function: Intrinsics_6:Library.TypeOf(x: Concept:Any): ConcreteType:Type;
New signature: Intrinsics_6:Library.TypeOf(x: $30): Type
Variables: $30
Constraints:
   $30 implements (Any)
Original function: Array_165:Library.Map(xs: Concept:Array,f: Primitive:Function): Concept:Array;
New signature: Array_165:Library.Map(xs: $31, f: (Function, $33, $34)): $35
Variables: $31, $32, $33, $34, $35, $36
Constraints:
   $32 implements (Any)
   $31 implements (Array, $32)
   $36 implements (Any)
   $35 implements (Array, $36)
Original function: Array_165:Library.Reverse(xs: Concept:Array): Concept:Array;
New signature: Array_165:Library.Reverse(xs: $37): $39
Variables: $37, $38, $39, $40
Constraints:
   $38 implements (Any)
   $37 implements (Array, $38)
   $40 implements (Any)
   $39 implements (Array, $40)
Original function: Array_165:Library.Zip(xs: Concept:Array,ys: Concept:Array,f: Primitive:Function): Concept:Array;
New signature: Array_165:Library.Zip(xs: $41, ys: $43, f: (Function, $45, $46, $47)): $48
Variables: $41, $42, $43, $44, $45, $46, $47, $48, $49
Constraints:
   $42 implements (Any)
   $41 implements (Array, $42)
   $44 implements (Any)
   $43 implements (Array, $44)
   $49 implements (Any)
   $48 implements (Array, $49)
Original function: Array_165:Library.Zip(xs: Concept:Array,ys: Concept:Array,zs: Concept:Array,f: Primitive:Function): Concept:Array;
New signature: Array_165:Library.Zip(xs: $50, ys: $52, zs: $54, f: (Function, $56, $57, $58, $59)): $60
Variables: $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61
Constraints:
   $51 implements (Any)
   $50 implements (Array, $51)
   $53 implements (Any)
   $52 implements (Array, $53)
   $55 implements (Any)
   $54 implements (Array, $55)
   $61 implements (Any)
   $60 implements (Array, $61)
Original function: Array_165:Library.Skip(xs: Concept:Array,n: ConcreteType:Integer): Concept:Array;
New signature: Array_165:Library.Skip(xs: $62, n: Integer): $64
Variables: $62, $63, $64, $65
Constraints:
   $63 implements (Any)
   $62 implements (Array, $63)
   $65 implements (Any)
   $64 implements (Array, $65)
Original function: Array_165:Library.Take(xs: Concept:Array,n: ConcreteType:Integer): Concept:Array;
New signature: Array_165:Library.Take(xs: $66, n: Integer): $68
Variables: $66, $67, $68, $69
Constraints:
   $67 implements (Any)
   $66 implements (Array, $67)
   $69 implements (Any)
   $68 implements (Array, $69)
Original function: Array_165:Library.Aggregate(xs: Concept:Array,init: Concept:Any,f: Primitive:Function): Concept:Any;
New signature: Array_165:Library.Aggregate(xs: $70, init: $72, f: (Function, $73, $74, $75)): $76
Variables: $70, $71, $72, $73, $74, $75, $76
Constraints:
   $71 implements (Any)
   $70 implements (Array, $71)
   $72 implements (Any)
   $76 implements (Any)
Original function: Array_165:Library.Rest(xs: Concept:Array): Concept:Array;
New signature: Array_165:Library.Rest(xs: $77): $79
Variables: $77, $78, $79, $80
Constraints:
   $78 implements (Any)
   $77 implements (Array, $78)
   $80 implements (Any)
   $79 implements (Array, $80)
Original function: Array_165:Library.IsEmpty(xs: Concept:Array): ConcreteType:Boolean;
New signature: Array_165:Library.IsEmpty(xs: $81): Boolean
Variables: $81, $82
Constraints:
   $82 implements (Any)
   $81 implements (Array, $82)
Original function: Array_165:Library.First(xs: Concept:Array): Concept:Any;
New signature: Array_165:Library.First(xs: $83): $85
Variables: $83, $84, $85
Constraints:
   $84 implements (Any)
   $83 implements (Array, $84)
   $85 implements (Any)
Original function: Array_165:Library.Last(xs: Concept:Array): Concept:Any;
New signature: Array_165:Library.Last(xs: $86): $88
Variables: $86, $87, $88
Constraints:
   $87 implements (Any)
   $86 implements (Array, $87)
   $88 implements (Any)
Original function: Array_165:Library.Slice(xs: Concept:Array,from: ConcreteType:Integer,count: ConcreteType:Integer): Concept:Array;
New signature: Array_165:Library.Slice(xs: $89, from: Integer, count: Integer): $91
Variables: $89, $90, $91, $92
Constraints:
   $90 implements (Any)
   $89 implements (Array, $90)
   $92 implements (Any)
   $91 implements (Array, $92)
Original function: Array_165:Library.Join(xs: Concept:Array,sep: ConcreteType:String): ConcreteType:String;
New signature: Array_165:Library.Join(xs: $93, sep: String): String
Variables: $93, $94
Constraints:
   $94 implements (Any)
   $93 implements (Array, $94)
Original function: Array_165:Library.All(xs: Concept:Array,f: Primitive:Function): ConcreteType:Boolean;
New signature: Array_165:Library.All(xs: $95, f: (Function, $97, $98)): Boolean
Variables: $95, $96, $97, $98
Constraints:
   $96 implements (Any)
   $95 implements (Array, $96)
Original function: Array_165:Library.All(xs: Concept:Array): ConcreteType:Boolean;
New signature: Array_165:Library.All(xs: $99): Boolean
Variables: $99, $100
Constraints:
   $100 implements (Any)
   $99 implements (Array, $100)
Original function: Interval_168:Library.Size(x: Concept:Interval): Concept:Numerical;
New signature: Interval_168:Library.Size(x: $101): $103
Variables: $101, $102, $103
Constraints:
   $102 implements (Numerical)
   $101 implements (Interval, $102)
   $103 implements (Numerical)
Original function: Interval_168:Library.IsEmpty(x: Concept:Interval): ConcreteType:Boolean;
New signature: Interval_168:Library.IsEmpty(x: $104): Boolean
Variables: $104, $105
Constraints:
   $105 implements (Numerical)
   $104 implements (Interval, $105)
Original function: Interval_168:Library.Lerp(x: Concept:Interval,amount: ConcreteType:Unit): Concept:Numerical;
New signature: Interval_168:Library.Lerp(x: $106, amount: Unit): $108
Variables: $106, $107, $108
Constraints:
   $107 implements (Numerical)
   $106 implements (Interval, $107)
   $108 implements (Numerical)
Original function: Interval_168:Library.InverseLerp(x: Concept:Interval,value: Concept:Numerical): ConcreteType:Unit;
New signature: Interval_168:Library.InverseLerp(x: $109, value: $111): Unit
Variables: $109, $110, $111
Constraints:
   $110 implements (Numerical)
   $109 implements (Interval, $110)
   $111 implements (Numerical)
Original function: Interval_168:Library.Negate(x: Concept:Interval): Concept:Interval;
New signature: Interval_168:Library.Negate(x: $112): $114
Variables: $112, $113, $114, $115
Constraints:
   $113 implements (Numerical)
   $112 implements (Interval, $113)
   $115 implements (Numerical)
   $114 implements (Interval, $115)
Original function: Interval_168:Library.Reverse(x: Concept:Interval): Concept:Interval;
New signature: Interval_168:Library.Reverse(x: $116): $118
Variables: $116, $117, $118, $119
Constraints:
   $117 implements (Numerical)
   $116 implements (Interval, $117)
   $119 implements (Numerical)
   $118 implements (Interval, $119)
Original function: Interval_168:Library.Center(x: Concept:Interval): Concept:Numerical;
New signature: Interval_168:Library.Center(x: $120): $122
Variables: $120, $121, $122
Constraints:
   $121 implements (Numerical)
   $120 implements (Interval, $121)
   $122 implements (Numerical)
Original function: Interval_168:Library.Contains(x: Concept:Interval,value: Concept:Numerical): ConcreteType:Boolean;
New signature: Interval_168:Library.Contains(x: $123, value: $125): Boolean
Variables: $123, $124, $125
Constraints:
   $124 implements (Numerical)
   $123 implements (Interval, $124)
   $125 implements (Numerical)
Original function: Interval_168:Library.Contains(x: Concept:Interval,other: Concept:Interval): ConcreteType:Boolean;
New signature: Interval_168:Library.Contains(x: $126, other: $128): Boolean
Variables: $126, $127, $128, $129
Constraints:
   $127 implements (Numerical)
   $126 implements (Interval, $127)
   $129 implements (Numerical)
   $128 implements (Interval, $129)
Original function: Interval_168:Library.Overlaps(x: Concept:Interval,y: Concept:Interval): ConcreteType:Boolean;
New signature: Interval_168:Library.Overlaps(x: $130, y: $132): Boolean
Variables: $130, $131, $132, $133
Constraints:
   $131 implements (Numerical)
   $130 implements (Interval, $131)
   $133 implements (Numerical)
   $132 implements (Interval, $133)
Original function: Interval_168:Library.Split(x: Concept:Interval,t: ConcreteType:Unit): Primitive:Tuple;
New signature: Interval_168:Library.Split(x: $134, t: Unit): Tuple
Variables: $134, $135
Constraints:
   $135 implements (Numerical)
   $134 implements (Interval, $135)
Original function: Interval_168:Library.Split(x: Concept:Interval): Primitive:Tuple;
New signature: Interval_168:Library.Split(x: $136): Tuple
Variables: $136, $137
Constraints:
   $137 implements (Numerical)
   $136 implements (Interval, $137)
Original function: Interval_168:Library.Left(x: Concept:Interval,t: ConcreteType:Unit): Concept:Interval;
New signature: Interval_168:Library.Left(x: $138, t: Unit): $140
Variables: $138, $139, $140, $141
Constraints:
   $139 implements (Numerical)
   $138 implements (Interval, $139)
   $141 implements (Numerical)
   $140 implements (Interval, $141)
Original function: Interval_168:Library.Right(x: Concept:Interval,t: ConcreteType:Unit): Concept:Interval;
New signature: Interval_168:Library.Right(x: $142, t: Unit): $144
Variables: $142, $143, $144, $145
Constraints:
   $143 implements (Numerical)
   $142 implements (Interval, $143)
   $145 implements (Numerical)
   $144 implements (Interval, $145)
Original function: Interval_168:Library.MoveTo(x: Concept:Interval,v: Concept:Numerical): Concept:Interval;
New signature: Interval_168:Library.MoveTo(x: $146, v: $148): $149
Variables: $146, $147, $148, $149, $150
Constraints:
   $147 implements (Numerical)
   $146 implements (Interval, $147)
   $148 implements (Numerical)
   $150 implements (Numerical)
   $149 implements (Interval, $150)
Original function: Interval_168:Library.LeftHalf(x: Concept:Interval): Concept:Interval;
New signature: Interval_168:Library.LeftHalf(x: $151): $153
Variables: $151, $152, $153, $154
Constraints:
   $152 implements (Numerical)
   $151 implements (Interval, $152)
   $154 implements (Numerical)
   $153 implements (Interval, $154)
Original function: Interval_168:Library.RightHalf(x: Concept:Interval): Concept:Interval;
New signature: Interval_168:Library.RightHalf(x: $155): $157
Variables: $155, $156, $157, $158
Constraints:
   $156 implements (Numerical)
   $155 implements (Interval, $156)
   $158 implements (Numerical)
   $157 implements (Interval, $158)
Original function: Interval_168:Library.HalfSize(x: Concept:Interval): Concept:Numerical;
New signature: Interval_168:Library.HalfSize(x: $159): $161
Variables: $159, $160, $161
Constraints:
   $160 implements (Numerical)
   $159 implements (Interval, $160)
   $161 implements (Numerical)
Original function: Interval_168:Library.Recenter(x: Concept:Interval,c: Concept:Numerical): Concept:Interval;
New signature: Interval_168:Library.Recenter(x: $162, c: $164): $165
Variables: $162, $163, $164, $165, $166
Constraints:
   $163 implements (Numerical)
   $162 implements (Interval, $163)
   $164 implements (Numerical)
   $166 implements (Numerical)
   $165 implements (Interval, $166)
Original function: Interval_168:Library.Clamp(x: Concept:Interval,y: Concept:Interval): Concept:Interval;
New signature: Interval_168:Library.Clamp(x: $167, y: $169): $171
Variables: $167, $168, $169, $170, $171, $172
Constraints:
   $168 implements (Numerical)
   $167 implements (Interval, $168)
   $170 implements (Numerical)
   $169 implements (Interval, $170)
   $172 implements (Numerical)
   $171 implements (Interval, $172)
Original function: Interval_168:Library.Clamp(x: Concept:Interval,value: Concept:Numerical): Concept:Numerical;
New signature: Interval_168:Library.Clamp(x: $173, value: $175): $176
Variables: $173, $174, $175, $176
Constraints:
   $174 implements (Numerical)
   $173 implements (Interval, $174)
   $175 implements (Numerical)
   $176 implements (Numerical)
Original function: Interval_168:Library.Within(x: Concept:Interval,value: Concept:Numerical): ConcreteType:Boolean;
New signature: Interval_168:Library.Within(x: $177, value: $179): Boolean
Variables: $177, $178, $179
Constraints:
   $178 implements (Numerical)
   $177 implements (Interval, $178)
   $179 implements (Numerical)
Original function: Value_171:Library.ToString(x: Concept:Value): ConcreteType:String;
New signature: Value_171:Library.ToString(x: $180): String
Variables: $180
Constraints:
   $180 implements (Value)
Original function: Vector_174:Library.Sum(v: Concept:Array): Concept:Numerical;
New signature: Vector_174:Library.Sum(v: $181): $183
Variables: $181, $182, $183
Constraints:
   $182 implements (Any)
   $181 implements (Array, $182)
   $183 implements (Numerical)
Original function: Vector_174:Library.SumSquares(v: Concept:Array): ConcreteType:Number;
New signature: Vector_174:Library.SumSquares(v: $184): Number
Variables: $184, $185
Constraints:
   $185 implements (Any)
   $184 implements (Array, $185)
Original function: Vector_174:Library.LengthSquared(v: Concept:Array): ConcreteType:Number;
New signature: Vector_174:Library.LengthSquared(v: $186): Number
Variables: $186, $187
Constraints:
   $187 implements (Any)
   $186 implements (Array, $187)
Original function: Vector_174:Library.Length(v: Concept:Array): ConcreteType:Number;
New signature: Vector_174:Library.Length(v: $188): Number
Variables: $188, $189
Constraints:
   $189 implements (Any)
   $188 implements (Array, $189)
Original function: Vector_174:Library.Dot(v1: Concept:Vector,v2: Concept:Vector): ConcreteType:Number;
New signature: Vector_174:Library.Dot(v1: $190, v2: $192): Number
Variables: $190, $191, $192, $193
Constraints:
   $191 implements (Numerical)
   $190 implements (Vector, $191)
   $193 implements (Numerical)
   $192 implements (Vector, $193)
Original function: Vector_174:Library.Normal(v: Concept:Vector): Concept:Vector;
New signature: Vector_174:Library.Normal(v: $194): $196
Variables: $194, $195, $196, $197
Constraints:
   $195 implements (Numerical)
   $194 implements (Vector, $195)
   $197 implements (Numerical)
   $196 implements (Vector, $197)
Original function: Comparable_183:Library.Equals(a: Concept:Comparable,b: Concept:Comparable): ConcreteType:Boolean;
New signature: Comparable_183:Library.Equals(a: $198, b: $199): Boolean
Variables: $198, $199
Constraints:
   $198 implements (Comparable)
   $199 implements (Comparable)
Original function: Comparable_183:Library.LessThan(a: Concept:Comparable,b: Concept:Comparable): ConcreteType:Boolean;
New signature: Comparable_183:Library.LessThan(a: $200, b: $201): Boolean
Variables: $200, $201
Constraints:
   $200 implements (Comparable)
   $201 implements (Comparable)
Original function: Comparable_183:Library.LessThanOrEquals(a: Concept:Comparable,b: Concept:Comparable): ConcreteType:Boolean;
New signature: Comparable_183:Library.LessThanOrEquals(a: $202, b: $203): Boolean
Variables: $202, $203
Constraints:
   $202 implements (Comparable)
   $203 implements (Comparable)
Original function: Comparable_183:Library.GreaterThan(a: Concept:Comparable,b: Concept:Comparable): ConcreteType:Boolean;
New signature: Comparable_183:Library.GreaterThan(a: $204, b: $205): Boolean
Variables: $204, $205
Constraints:
   $204 implements (Comparable)
   $205 implements (Comparable)
Original function: Comparable_183:Library.GreaterThanOrEquals(a: Concept:Comparable,b: Concept:Comparable): ConcreteType:Boolean;
New signature: Comparable_183:Library.GreaterThanOrEquals(a: $206, b: $207): Boolean
Variables: $206, $207
Constraints:
   $206 implements (Comparable)
   $207 implements (Comparable)
Original function: Comparable_183:Library.Between(v: Concept:Comparable,a: Concept:Comparable,b: Concept:Comparable): Concept:Value;
New signature: Comparable_183:Library.Between(v: $208, a: $209, b: $210): $211
Variables: $208, $209, $210, $211
Constraints:
   $208 implements (Comparable)
   $209 implements (Comparable)
   $210 implements (Comparable)
   $211 implements (Value)
Original function: Comparable_183:Library.Between(v: Concept:Value,i: Concept:Interval): Concept:Interval;
New signature: Comparable_183:Library.Between(v: $212, i: $213): $215
Variables: $212, $213, $214, $215, $216
Constraints:
   $212 implements (Value)
   $214 implements (Numerical)
   $213 implements (Interval, $214)
   $216 implements (Numerical)
   $215 implements (Interval, $216)
Original function: Comparable_183:Library.Min(a: Concept:Comparable,b: Concept:Comparable): Concept:Comparable;
New signature: Comparable_183:Library.Min(a: $217, b: $218): $219
Variables: $217, $218, $219
Constraints:
   $217 implements (Comparable)
   $218 implements (Comparable)
   $219 implements (Comparable)
Original function: Comparable_183:Library.Max(a: Concept:Comparable,b: Concept:Comparable): Concept:Comparable;
New signature: Comparable_183:Library.Max(a: $220, b: $221): $222
Variables: $220, $221, $222
Constraints:
   $220 implements (Comparable)
   $221 implements (Comparable)
   $222 implements (Comparable)
Original function: Equatable_186:Library.NotEquals(x: Concept:Equatable,y: Concept:Equatable): ConcreteType:Boolean;
New signature: Equatable_186:Library.NotEquals(x: $223, y: $224): Boolean
Variables: $223, $224
Constraints:
   $223 implements (Equatable)
   $224 implements (Equatable)
Original function: Easings_189:Library.BlendEaseFunc(p: ConcreteType:Number,easeIn: Primitive:Function,easeOut: Primitive:Function): ConcreteType:Number;
New signature: Easings_189:Library.BlendEaseFunc(p: Number, easeIn: (Function, $225, $226), easeOut: (Function, $227, $228)): Number
Variables: $225, $226, $227, $228
Constraints:
Original function: Easings_189:Library.InvertEaseFunc(p: ConcreteType:Number,easeIn: Primitive:Function): ConcreteType:Number;
New signature: Easings_189:Library.InvertEaseFunc(p: Number, easeIn: (Function, $229, $230)): Number
Variables: $229, $230
Constraints:

[0:00.374] Outputting errors and warnings
