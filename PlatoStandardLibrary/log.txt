[0:00.001] Creating compiler
[0:00.001] Opening files
[0:00.132] Starting compiling C:\Users\cdigg\git\plato\PlatoStandardLibrary\intrinsics.plato at 2023-10-08 8:39:02 PM
[0:00.133] Starting to parse 38 lines containing 1086 characters
[0:00.133] Tokenization phase
[0:00.135] Completed tokenization
[0:00.135] Starting main parse
[0:00.137] Completed parsing
[0:00.137] Gathering parse errors
[0:00.137] Found 0 errors
[0:00.137] Gathering parse nodes
[0:00.137] Found 782 nodes
[0:00.137] Creating parse tree
[0:00.138] Creating Concrete Syntax Tree (CST)
[0:00.144] Creating Abstract Syntax Tree (AST)
[0:00.155] Completed all steps, result is successful
[0:00.209] Starting compiling C:\Users\cdigg\git\plato\PlatoStandardLibrary\concepts.plato at 2023-10-08 8:39:02 PM
[0:00.209] Starting to parse 124 lines containing 2566 characters
[0:00.209] Tokenization phase
[0:00.210] Completed tokenization
[0:00.210] Starting main parse
[0:00.221] Completed parsing
[0:00.221] Gathering parse errors
[0:00.221] Found 0 errors
[0:00.221] Gathering parse nodes
[0:00.221] Found 1358 nodes
[0:00.221] Creating parse tree
[0:00.221] Creating Concrete Syntax Tree (CST)
[0:00.222] Creating Abstract Syntax Tree (AST)
[0:00.230] Completed all steps, result is successful
[0:00.274] Starting compiling C:\Users\cdigg\git\plato\PlatoStandardLibrary\types.plato at 2023-10-08 8:39:03 PM
[0:00.275] Starting to parse 872 lines containing 12978 characters
[0:00.275] Tokenization phase
[0:00.279] Completed tokenization
[0:00.279] Starting main parse
[0:00.284] Completed parsing
[0:00.284] Gathering parse errors
[0:00.284] Found 0 errors
[0:00.284] Gathering parse nodes
[0:00.284] Found 3800 nodes
[0:00.284] Creating parse tree
[0:00.284] Creating Concrete Syntax Tree (CST)
[0:00.286] Creating Abstract Syntax Tree (AST)
[0:00.288] Completed all steps, result is successful
[0:00.345] Starting compiling C:\Users\cdigg\git\plato\PlatoStandardLibrary\libraries.plato at 2023-10-08 8:39:03 PM
[0:00.345] Starting to parse 442 lines containing 11214 characters
[0:00.345] Tokenization phase
[0:00.359] Completed tokenization
[0:00.360] Starting main parse
[0:00.372] Completed parsing
[0:00.372] Gathering parse errors
[0:00.372] Found 0 errors
[0:00.372] Gathering parse nodes
[0:00.372] Found 6283 nodes
[0:00.372] Creating parse tree
[0:00.373] Creating Concrete Syntax Tree (CST)
[0:00.375] Creating Abstract Syntax Tree (AST)
[0:00.380] Completed all steps, result is successful
[0:00.380] Applying syntax coloring
[0:00.380] Completed syntax coloring
[0:00.525] Initializing Compiler
[0:00.525] Gathering parsers
[0:00.526] Gathering AST trees
[0:00.527] Gathering type declarations
[0:00.543] Creating symbol resolver
[0:00.545] Creating type definitions
[0:00.556] Found 0 symbol resolution errors
[0:00.556] Gathering function definitions
[0:00.557] Found 428 functions
[0:00.557] Checking semantics
[0:00.557] Creating Reified Types
[0:00.593] Found 117 types
[0:00.593] Created a total of 1465 reified functions
[0:00.593] Adding library functions to reified types
[0:00.689] Grouping Reified functions by name for faster type resolution
[0:00.692] Creating function analysis
[0:00.725] Creating function analysesGathering constraints for each function
Function group call unresolved: no functions
One(x) with (Number) has 0 possible return types 
One(x) with (Number) has 0 possible return types 
One(x) with (Number) has 0 possible return types 
One(x) with (Number) has 0 possible return types 
One(x) with (Number) has 0 possible return types 
Zero(x) with (Number) has 0 possible return types 
Function group call unresolved: ambiguous
Add(FieldValues(self), scalar) with ((Array, Any), Number) has 2 possible return types Number, Integer
Add(FieldValues(self), FieldValues(other)) with ((Array, Any), (Array, Any)) has 2 possible return types Number, Integer
Add(FieldValues(self), FieldValues(other)) with ((Array, Any), (Array, Any)) has 2 possible return types Number, Integer
Multiply(FieldValues(self), scalar) with ((Array, Any), Number) has 2 possible return types Number, Integer
Negative(FieldValues(self)) with ((Array, Any)) has 2 possible return types Number, Integer
Negative(self) with ((Arithmetic)) has 2 possible return types Number, Integer
Add(self, Negative(self)) with ((Arithmetic), Number) has 2 possible return types Number, Integer
Add(self, Negative(scalar)) with ((ScalarArithmetic), Number) has 2 possible return types Number, Integer
Subtract(Count, n) with ($158, Integer) has 2 possible return types Number, Integer
Multiply(self, Reciprocal(scalar)) with ((ScalarArithmetic), (Arithmetic)) has 2 possible return types Number, Integer
Divide(FieldValues(self), FieldValues(other)) with ((Array, Any), (Array, Any)) has 2 possible return types Number, Integer
Modulo(FieldValues(self), scalar) with ((Array, Any), Number) has 2 possible return types Number, Integer
Modulo(FieldValues(self), FieldValues(other)) with ((Array, Any), (Array, Any)) has 2 possible return types Number, Integer
Add(ToString(First(xs)), Aggregate(Rest(xs), , (\(ParameterDefinition=acc$3211:ConcreteType:String, ParameterDefinition=cur$3213:Concept:Any) -> Primitive:Function)) with (String, Any) has 2 possible return types Number, Integer
Subtract(Max(x), Min(x)) with ($3, $2) has 2 possible return types Number, Integer
Multiply(Max(x), amount) with ($3, Unit) has 2 possible return types Number, Integer
Multiply(Min(x), Add(Subtract(1, amount), Multiply(Max(x), amount))) with ($2, Number) has 2 possible return types Number, Integer
Subtract(value, Min(x)) with (Numerical, $2) has 2 possible return types Number, Integer
Negative(Max(x)) with ($3) has 2 possible return types Number, Integer
Negative(Min(x)) with ($2) has 2 possible return types Number, Integer
Multiply(t, b) with (Unit, Number) has 2 possible return types Number, Integer
Clamp(x, Tuple(0, 1)) with (Number, (Tuple, Integer, Integer)) has 2 possible return types (Interval, $94), Numerical
Clamp(x, Min(y)) with ((Interval, $92), $2) has 2 possible return types (Interval, $94), Numerical
Clamp(x, Max(y)) with ((Interval, $92), $3) has 2 possible return types (Interval, $94), Numerical
Clamp(x, y) with ((Interval, $75), (Interval, $76)) has 2 possible return types (Interval, $94), Numerical
Not(IsEmpty(Clamp(x, y))) with (Boolean) has 2 possible return types Boolean, (BooleanOperations)
Add(v, Size(x)) with (Numerical, Size2D) has 2 possible return types Number, Integer
Subtract(c, HalfSize(x)) with (Numerical, Numerical) has 2 possible return types Number, Integer
Add(c, HalfSize(x)) with (Numerical, Numerical) has 2 possible return types Number, Integer
Multiply(v1, v2) with ((Vector, $101), (Vector, $102)) has 2 possible return types Number, Integer
Divide(v, Length(v)) with ((Vector, $103), Number) has 2 possible return types Number, Integer
Subtract(One(x), x) with (, Number) has 4 possible return types Number, Integer, (Arithmetic), (ScalarArithmetic)
Negative(One(x)) with () has 3 possible return types Number, Integer, (Arithmetic)
Divide(Pi, 180) with ($357, Integer) has 2 possible return types Number, Integer
Not(Equals(x, y)) with (Boolean) has 2 possible return types Boolean, (BooleanOperations)
Add(easeOut(Multiply(p, Subtract(2, 1))), 0.5) with ($375, Number) has 2 possible return types Number, Integer
Multiply(Turns(Quarter(p)), Sin(Radians(Pow(2, Multiply(10, MinusOne(p)))))) with (Angle, Number) has 2 possible return types Number, Integer

[0:00.725] Outputting errors and warnings
