using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Collections.Generic;
using System.Linq;
namespace Plato {
public static partial class Intrinsics {
public static float Add(this float a, float b) => a + b;
public static IArray<float> Add(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a + b);
public static float Subtract(this float a, float b) => a - b;
public static IArray<float> Subtract(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a - b);
public static float Sum(this IArray<float> self) => self.Aggregate((a, b) => a + b);
public static float Multiply(this float a, float b) => a * b;
public static IArray<float> Multiply(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a * b);
public static float Divide(this float a, float b) => a / b;
public static IArray<float> Divide(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a / b);
public static float Modulo(this float a, float b) => a % b;
public static IArray<float> Modulo(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a % b);
public static float Product(this IArray<float> self) => self.Aggregate((a, b) => a * b);
public static float Negate(this float a) => - a;
public static IArray<float> Negate(this IArray<float> self) => self.Select(a => - a);
public static bool Equals(this float a, float b) => a == b;
public static bool NotEquals(this float a, float b) => a != b;
public static int CompareTo(this float self, float other) => self < other ? -1 : self > other ? 1 : 0;
public static IArray<int> CompareTo(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a.CompareTo(b));
public static bool LessThan(this float a, float b) => a < b;
public static IArray<bool> LessThan(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a < b);
public static bool LessThanOrEquals(this float a, float b) => a <= b;
public static IArray<bool> LessThanOrEquals(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a <= b);
public static bool GreaterThan(this float a, float b) => a > b;
public static IArray<bool> GreaterThan(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a > b);
public static bool GreaterThanOrEquals(this float a, float b) => a >= b;
public static IArray<bool> GreaterThanOrEquals(this IArray<float> self, IArray<float> other) => self.Zip(other, (a,b) => a >= b);
public static float Default(this float _) => default(float);
public static float Zero(this float _) => (float)0;
public static float One(this float _) => (float)1;
public static float MinValue(this float _) => float.MinValue;
public static float MaxValue(this float _) => float.MaxValue;
}
public static partial class Intrinsics {
public static double Add(this double a, double b) => a + b;
public static IArray<double> Add(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a + b);
public static double Subtract(this double a, double b) => a - b;
public static IArray<double> Subtract(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a - b);
public static double Sum(this IArray<double> self) => self.Aggregate((a, b) => a + b);
public static double Multiply(this double a, double b) => a * b;
public static IArray<double> Multiply(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a * b);
public static double Divide(this double a, double b) => a / b;
public static IArray<double> Divide(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a / b);
public static double Modulo(this double a, double b) => a % b;
public static IArray<double> Modulo(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a % b);
public static double Product(this IArray<double> self) => self.Aggregate((a, b) => a * b);
public static double Negate(this double a) => - a;
public static IArray<double> Negate(this IArray<double> self) => self.Select(a => - a);
public static bool Equals(this double a, double b) => a == b;
public static bool NotEquals(this double a, double b) => a != b;
public static int CompareTo(this double self, double other) => self < other ? -1 : self > other ? 1 : 0;
public static IArray<int> CompareTo(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a.CompareTo(b));
public static bool LessThan(this double a, double b) => a < b;
public static IArray<bool> LessThan(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a < b);
public static bool LessThanOrEquals(this double a, double b) => a <= b;
public static IArray<bool> LessThanOrEquals(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a <= b);
public static bool GreaterThan(this double a, double b) => a > b;
public static IArray<bool> GreaterThan(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a > b);
public static bool GreaterThanOrEquals(this double a, double b) => a >= b;
public static IArray<bool> GreaterThanOrEquals(this IArray<double> self, IArray<double> other) => self.Zip(other, (a,b) => a >= b);
public static double Default(this double _) => default(double);
public static double Zero(this double _) => (double)0;
public static double One(this double _) => (double)1;
public static double MinValue(this double _) => double.MinValue;
public static double MaxValue(this double _) => double.MaxValue;
}
public static partial class Intrinsics {
public static int Add(this int a, int b) => a + b;
public static IArray<int> Add(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a + b);
public static int Subtract(this int a, int b) => a - b;
public static IArray<int> Subtract(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a - b);
public static int Sum(this IArray<int> self) => self.Aggregate((a, b) => a + b);
public static int Multiply(this int a, int b) => a * b;
public static IArray<int> Multiply(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a * b);
public static int Divide(this int a, int b) => a / b;
public static IArray<int> Divide(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a / b);
public static int Modulo(this int a, int b) => a % b;
public static IArray<int> Modulo(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a % b);
public static int Product(this IArray<int> self) => self.Aggregate((a, b) => a * b);
public static int Negate(this int a) => - a;
public static IArray<int> Negate(this IArray<int> self) => self.Select(a => - a);
public static bool Equals(this int a, int b) => a == b;
public static bool NotEquals(this int a, int b) => a != b;
public static int CompareTo(this int self, int other) => self < other ? -1 : self > other ? 1 : 0;
public static IArray<int> CompareTo(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a.CompareTo(b));
public static bool LessThan(this int a, int b) => a < b;
public static IArray<bool> LessThan(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a < b);
public static bool LessThanOrEquals(this int a, int b) => a <= b;
public static IArray<bool> LessThanOrEquals(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a <= b);
public static bool GreaterThan(this int a, int b) => a > b;
public static IArray<bool> GreaterThan(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a > b);
public static bool GreaterThanOrEquals(this int a, int b) => a >= b;
public static IArray<bool> GreaterThanOrEquals(this IArray<int> self, IArray<int> other) => self.Zip(other, (a,b) => a >= b);
public static int Default(this int _) => default(int);
public static int Zero(this int _) => (int)0;
public static int One(this int _) => (int)1;
public static int MinValue(this int _) => int.MinValue;
public static int MaxValue(this int _) => int.MaxValue;
}
public static partial class Intrinsics {
public static long Add(this long a, long b) => a + b;
public static IArray<long> Add(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a + b);
public static long Subtract(this long a, long b) => a - b;
public static IArray<long> Subtract(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a - b);
public static long Sum(this IArray<long> self) => self.Aggregate((a, b) => a + b);
public static long Multiply(this long a, long b) => a * b;
public static IArray<long> Multiply(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a * b);
public static long Divide(this long a, long b) => a / b;
public static IArray<long> Divide(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a / b);
public static long Modulo(this long a, long b) => a % b;
public static IArray<long> Modulo(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a % b);
public static long Product(this IArray<long> self) => self.Aggregate((a, b) => a * b);
public static long Negate(this long a) => - a;
public static IArray<long> Negate(this IArray<long> self) => self.Select(a => - a);
public static bool Equals(this long a, long b) => a == b;
public static bool NotEquals(this long a, long b) => a != b;
public static int CompareTo(this long self, long other) => self < other ? -1 : self > other ? 1 : 0;
public static IArray<int> CompareTo(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a.CompareTo(b));
public static bool LessThan(this long a, long b) => a < b;
public static IArray<bool> LessThan(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a < b);
public static bool LessThanOrEquals(this long a, long b) => a <= b;
public static IArray<bool> LessThanOrEquals(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a <= b);
public static bool GreaterThan(this long a, long b) => a > b;
public static IArray<bool> GreaterThan(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a > b);
public static bool GreaterThanOrEquals(this long a, long b) => a >= b;
public static IArray<bool> GreaterThanOrEquals(this IArray<long> self, IArray<long> other) => self.Zip(other, (a,b) => a >= b);
public static long Default(this long _) => default(long);
public static long Zero(this long _) => (long)0;
public static long One(this long _) => (long)1;
public static long MinValue(this long _) => long.MinValue;
public static long MaxValue(this long _) => long.MaxValue;
}
public static partial class Intrinsics {
public static decimal Add(this decimal a, decimal b) => a + b;
public static IArray<decimal> Add(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a + b);
public static decimal Subtract(this decimal a, decimal b) => a - b;
public static IArray<decimal> Subtract(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a - b);
public static decimal Sum(this IArray<decimal> self) => self.Aggregate((a, b) => a + b);
public static decimal Multiply(this decimal a, decimal b) => a * b;
public static IArray<decimal> Multiply(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a * b);
public static decimal Divide(this decimal a, decimal b) => a / b;
public static IArray<decimal> Divide(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a / b);
public static decimal Modulo(this decimal a, decimal b) => a % b;
public static IArray<decimal> Modulo(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a % b);
public static decimal Product(this IArray<decimal> self) => self.Aggregate((a, b) => a * b);
public static decimal Negate(this decimal a) => - a;
public static IArray<decimal> Negate(this IArray<decimal> self) => self.Select(a => - a);
public static bool Equals(this decimal a, decimal b) => a == b;
public static bool NotEquals(this decimal a, decimal b) => a != b;
public static int CompareTo(this decimal self, decimal other) => self < other ? -1 : self > other ? 1 : 0;
public static IArray<int> CompareTo(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a.CompareTo(b));
public static bool LessThan(this decimal a, decimal b) => a < b;
public static IArray<bool> LessThan(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a < b);
public static bool LessThanOrEquals(this decimal a, decimal b) => a <= b;
public static IArray<bool> LessThanOrEquals(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a <= b);
public static bool GreaterThan(this decimal a, decimal b) => a > b;
public static IArray<bool> GreaterThan(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a > b);
public static bool GreaterThanOrEquals(this decimal a, decimal b) => a >= b;
public static IArray<bool> GreaterThanOrEquals(this IArray<decimal> self, IArray<decimal> other) => self.Zip(other, (a,b) => a >= b);
public static decimal Default(this decimal _) => default(decimal);
public static decimal Zero(this decimal _) => (decimal)0;
public static decimal One(this decimal _) => (decimal)1;
public static decimal MinValue(this decimal _) => decimal.MinValue;
public static decimal MaxValue(this decimal _) => decimal.MaxValue;
}
public static partial class Intrinsics {
public static byte Default(this byte _) => default(byte);
public static byte Zero(this byte _) => (byte)0;
public static byte One(this byte _) => (byte)1;
public static byte MinValue(this byte _) => byte.MinValue;
public static byte MaxValue(this byte _) => byte.MaxValue;
}
} // End namespace
