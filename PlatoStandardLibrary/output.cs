class Intrinsics
{
    public static Float_11 Cos(Float_11 x)
    // ParameterSymbol=x$2183:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Sin(Float_11 x)
    // ParameterSymbol=x$2186:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Tan(Float_11 x)
    // ParameterSymbol=x$2189:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Acos(Float_11 x)
    // ParameterSymbol=x$2192:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Asin(Float_11 x)
    // ParameterSymbol=x$2195:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Atan(Float_11 x)
    // ParameterSymbol=x$2198:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Cosh(Float_11 x)
    // ParameterSymbol=x$2201:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Sinh(Float_11 x)
    // ParameterSymbol=x$2204:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Tanh(Float_11 x)
    // ParameterSymbol=x$2207:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Acosh(Float_11 x)
    // ParameterSymbol=x$2210:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Asinh(Float_11 x)
    // ParameterSymbol=x$2213:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Atanh(Float_11 x)
    // ParameterSymbol=x$2216:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Pow(Float_11 x, Float_11 y)
    // ParameterSymbol=x$2219:Primitive:Float_11 
    // Candidates = Float
    // ParameterSymbol=y$2221:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Log(Float_11 x, Float_11 y)
    // ParameterSymbol=x$2224:Primitive:Float_11 
    // Candidates = Float
    // ParameterSymbol=y$2226:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 NaturalLog(Float_11 x)
    // ParameterSymbol=x$2229:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 NaturalPower(Float_11 x)
    // ParameterSymbol=x$2232:Primitive:Float_11 
    // Candidates = Float
    null
    public static String_8 Interpolate(Array_25 xs)
    // ParameterSymbol=xs$2236:Concept:Array_25<Primitive:String_8> 
    // Candidates = Array
    null
    public static Any_5 Throw(Any_5 x)
    // ParameterSymbol=x$2239:Primitive:Any_5 
    // Candidates = Any
    null
    public static Type_12 TypeOf(Any_5 x)
    // ParameterSymbol=x$2242:Primitive:Any_5 
    // Candidates = Any
    null
    public static Float_11 Add(Float_11 x, Float_11 y)
    // ParameterSymbol=x$2245:Primitive:Float_11 
    // Candidates = Float
    // ParameterSymbol=y$2247:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Subtract(Float_11 x, Float_11 y)
    // ParameterSymbol=x$2250:Primitive:Float_11 
    // Candidates = Float
    // ParameterSymbol=y$2252:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Divide(Float_11 x, Float_11 y)
    // ParameterSymbol=x$2255:Primitive:Float_11 
    // Candidates = Float
    // ParameterSymbol=y$2257:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Multiply(Float_11 x, Float_11 y)
    // ParameterSymbol=x$2260:Primitive:Float_11 
    // Candidates = Float
    // ParameterSymbol=y$2262:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Modulo(Float_11 x, Float_11 y)
    // ParameterSymbol=x$2265:Primitive:Float_11 
    // Candidates = Float
    // ParameterSymbol=y$2267:Primitive:Float_11 
    // Candidates = Float
    null
    public static Float_11 Negative(Float_11 x)
    // ParameterSymbol=x$2270:Primitive:Float_11 
    // Candidates = Float
    null
    public static Int_10 Add(Int_10 x, Int_10 y)
    // ParameterSymbol=x$2273:Primitive:Int_10 
    // Candidates = Int
    // ParameterSymbol=y$2275:Primitive:Int_10 
    // Candidates = Int
    null
    public static Int_10 Subtract(Int_10 x, Int_10 y)
    // ParameterSymbol=x$2278:Primitive:Int_10 
    // Candidates = Int
    // ParameterSymbol=y$2280:Primitive:Int_10 
    // Candidates = Int
    null
    public static Int_10 Divide(Int_10 x, Int_10 y)
    // ParameterSymbol=x$2283:Primitive:Int_10 
    // Candidates = Int
    // ParameterSymbol=y$2285:Primitive:Int_10 
    // Candidates = Int
    null
    public static Int_10 Multiply(Int_10 x, Int_10 y)
    // ParameterSymbol=x$2288:Primitive:Int_10 
    // Candidates = Int
    // ParameterSymbol=y$2290:Primitive:Int_10 
    // Candidates = Int
    null
    public static Int_10 Modulo(Int_10 x, Int_10 y)
    // ParameterSymbol=x$2293:Primitive:Int_10 
    // Candidates = Int
    // ParameterSymbol=y$2295:Primitive:Int_10 
    // Candidates = Int
    null
    public static Int_10 Negative(Int_10 x)
    // ParameterSymbol=x$2298:Primitive:Int_10 
    // Candidates = Int
    null
    public static Bool_9 And(Bool_9 x, Bool_9 y)
    // ParameterSymbol=x$2301:Primitive:Bool_9 
    // Candidates = Bool
    // ParameterSymbol=y$2303:Primitive:Bool_9 
    // Candidates = Bool
    null
    public static Bool_9 Or(Bool_9 x, Bool_9 y)
    // ParameterSymbol=x$2306:Primitive:Bool_9 
    // Candidates = Bool
    // ParameterSymbol=y$2308:Primitive:Bool_9 
    // Candidates = Bool
    null
    public static Bool_9 Not(Bool_9 x)
    // ParameterSymbol=x$2311:Primitive:Bool_9 
    // Candidates = Bool
    null
}
interface Vector<Self> where Self : Vector<Self>
{
    public static Count_27 Count(Vector_14 v)
    // ParameterSymbol=v$2315:Concept:Vector_14 
    // Candidates = Vector
    Count(FieldTypes(Self))
    public static T_244 At(Vector_14 v, Index_28 n)
    // ParameterSymbol=v$2325:Concept:Vector_14 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Vector
    // ParameterSymbol=n$2327:Type:Index_28 Argument:Ref=>FunctionGroupSymbol=At$352:(2/2)
    // Candidates = Index
    At(FieldValues(v), n)
}
interface Measure<Self> where Self : Measure<Self>
{
    public static Number_29 Value(Self_6 x)
    // ParameterSymbol=x$2339:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    At(FieldValues(x), 0)
}
interface Numerical<Self> where Self : Numerical<Self>
{
}
interface Magnitude<Self> where Self : Magnitude<Self>
{
    public static Number_29 Magnitude(Self_6 x)
    // ParameterSymbol=x$2351:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    SquareRoot(Sum(Square(FieldValues(x))))
}
interface Comparable<Self> where Self : Comparable<Self>
{
    public static Integer_26 Compare(Self_6 a, Self_6 b)
    // ParameterSymbol=a$2367:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=Magnitude$256:(1/1), Argument:Ref=>FunctionGroupSymbol=Magnitude$256:(1/1)
    // Candidates = Self
    // ParameterSymbol=b$2369:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=Magnitude$256:(1/1), Argument:Ref=>FunctionGroupSymbol=Magnitude$256:(1/1)
    // Candidates = Self
    LessThan(Magnitude(a), Magnitude(b)
        ? Negative(1)
        : GreaterThan(Magnitude(a), Magnitude(b)
            ? 1
            : 0
        )
    )
}
interface Equatable<Self> where Self : Equatable<Self>
{
    public static Boolean_22 Equals(Self_6 a, Self_6 b)
    // ParameterSymbol=a$2404:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=b$2406:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    All(Equals(FieldValues(a), FieldValues(b)))
}
interface Arithmetic<Self> where Self : Arithmetic<Self>
{
    public static Self_6 Add(Self_6 self, Self_6 other)
    // ParameterSymbol=self$2424:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=other$2426:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    Add(FieldValues(self), FieldValues(other))
    public static Self_6 Negative(Self_6 self)
    // ParameterSymbol=self$2441:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    Negative(FieldValues(self))
    public static Self_6 Reciprocal(Self_6 self)
    // ParameterSymbol=self$2451:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    Reciprocal(FieldValues(self))
    public static Self_6 Multiply(Self_6 self, Self_6 other)
    // ParameterSymbol=self$2461:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=other$2463:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    Add(FieldValues(self), FieldValues(other))
    public static Self_6 Divide(Self_6 self, Self_6 other)
    // ParameterSymbol=self$2478:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=other$2480:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    Divide(FieldValues(self), FieldValues(other))
    public static Self_6 Modulo(Self_6 self, Self_6 other)
    // ParameterSymbol=self$2495:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=other$2497:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    Modulo(FieldValues(self), FieldValues(other))
}
interface ScalarArithmetic<Self> where Self : ScalarArithmetic<Self>
{
    public static Self_6 Add(Self_6 self, T_2511 scalar)
    // ParameterSymbol=self$2513:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=scalar$2515:Variable:T_2511 Argument:Ref=>FunctionGroupSymbol=Add$284:(2/2)
    // Candidates = T
    Add(FieldValues(self), scalar)
    public static Self_6 Subtract(Self_6 self, T_2511 scalar)
    // ParameterSymbol=self$2527:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=Add$284:(1/2)
    // Candidates = Self
    // ParameterSymbol=scalar$2529:Variable:T_2511 Argument:Ref=>FunctionGroupSymbol=Negative$268:(1/1)
    // Candidates = T
    Add(self, Negative(scalar))
    public static Self_6 Multiply(Self_6 self, T_2511 scalar)
    // ParameterSymbol=self$2541:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=scalar$2543:Variable:T_2511 Argument:Ref=>FunctionGroupSymbol=Multiply$290:(2/2)
    // Candidates = T
    Multiply(FieldValues(self), scalar)
    public static Self_6 Divide(Self_6 self, T_2511 scalar)
    // ParameterSymbol=self$2555:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Self
    // ParameterSymbol=scalar$2557:Variable:T_2511 Argument:Ref=>FunctionGroupSymbol=Reciprocal$271:(1/1)
    // Candidates = T
    Multiply(self, Reciprocal(scalar))
    public static Self_6 Modulo(Self_6 self, T_2511 scalar)
    // ParameterSymbol=self$2569:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=scalar$2571:Variable:T_2511 Argument:Ref=>FunctionGroupSymbol=Modulo$296:(2/2)
    // Candidates = T
    Modulo(FieldValues(self), scalar)
}
interface Boolean<Self> where Self : Boolean<Self>
{
    public static Self_6 And(Self_6 a, Self_6 b)
    // ParameterSymbol=a$2583:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=b$2585:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    And(FieldValues(a), FieldValues(b))
    public static Self_6 Or(Self_6 a, Self_6 b)
    // ParameterSymbol=a$2600:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    // ParameterSymbol=b$2602:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    Or(FieldValues(a), FieldValues(b))
    public static Self_6 Not(Self_6 a)
    // ParameterSymbol=a$2617:Primitive:Self_6 Argument:Ref=>FunctionGroupSymbol=FieldValues$320:(1/1)
    // Candidates = Self
    Not(FieldValues(a))
}
interface Value<Self> where Self : Value<Self>
{
    public static Type_12 Type()
    intrinsic
    public static Array_25 FieldTypes()
    intrinsic
    public static Array_25 FieldNames()
    intrinsic
    public static Array_25 FieldValues(Self_6 self)
    // ParameterSymbol=self$2633:Primitive:Self_6 
    // Candidates = Self
    intrinsic
    public static Self_6 Zero()
    Zero(FieldTypes)
    public static Self_6 One()
    One(FieldTypes)
    public static Self_6 Default()
    Default(FieldTypes)
    public static Self_6 MinValue()
    MinValue(FieldTypes)
    public static Self_6 MaxValue()
    MaxValue(FieldTypes)
    public static String_8 ToString(Self_6 x)
    // ParameterSymbol=x$2662:Primitive:Self_6 
    // Candidates = Self
    JoinStrings(FieldValues, ,)
}
interface Interval<Self> where Self : Interval<Self>
{
    public static T_339 Min(Self_6 x)
    // ParameterSymbol=x$2672:Primitive:Self_6 
    // Candidates = Self
    null
    public static T_339 Max(Self_6 x)
    // ParameterSymbol=x$2675:Primitive:Self_6 
    // Candidates = Self
    null
}
interface Array<Self> where Self : Array<Self>
{
    public static Count_27 Count(Self_6 xs)
    // ParameterSymbol=xs$2679:Primitive:Self_6 
    // Candidates = Self
    null
    public static T_346 At(Self_6 xs, Index_28 n)
    // ParameterSymbol=xs$2682:Primitive:Self_6 
    // Candidates = Self
    // ParameterSymbol=n$2684:Type:Index_28 
    // Candidates = Index
    null
}
class Integer
{
    Integer_26 Value;
}
class Count
{
    Integer_26 Value;
}
class Index
{
    Integer_26 Value;
}
class Number
{
    Float_11 Value;
}
class Unit
{
    Number_29 Value;
}
class Percent
{
    Number_29 Value;
}
class Quaternion
{
    Number_29 X;
    Number_29 Y;
    Number_29 Z;
    Number_29 W;
}
class Unit2D
{
    Unit_30 X;
    Unit_30 Y;
}
class Unit3D
{
    Unit_30 X;
    Unit_30 Y;
    Unit_30 Z;
}
class Direction3D
{
    Unit3D_34 Value;
}
class AxisAngle
{
    Unit3D_34 Axis;
    Angle_83 Angle;
}
class EulerAngles
{
    Angle_83 Yaw;
    Angle_83 Pitch;
    Angle_83 Roll;
}
class Rotation3D
{
    Quaternion_32 Quaternion;
}
class Vector2D
{
    Number_29 X;
    Number_29 Y;
}
class Vector3D
{
    Number_29 X;
    Number_29 Y;
    Number_29 Z;
}
class Vector4D
{
    Number_29 X;
    Number_29 Y;
    Number_29 Z;
    Number_29 W;
}
class Orientation3D
{
    Rotation3D_38 Value;
}
class Pose2D
{
    Vector3D_40 Position;
    Orientation3D_42 Orientation;
}
class Pose3D
{
    Vector3D_40 Position;
    Orientation3D_42 Orientation;
}
class Transform3D
{
    Vector3D_40 Translation;
    Rotation3D_38 Rotation;
    Vector3D_40 Scale;
}
class Transform2D
{
    Vector2D_39 Translation;
    Angle_83 Rotation;
    Vector2D_39 Scale;
}
class AlignedBox2D
{
    Vector2D_39 A;
    Vector2D_39 B;
}
class AlignedBox3D
{
    Vector3D_40 A;
    Vector3D_40 B;
}
class Complex
{
    Number_29 Real;
    Number_29 Imaginary;
}
class Ray3D
{
    Vector3D_40 Direction;
    Point3D_58 Position;
}
class Ray2D
{
    Vector2D_39 Direction;
    Point2D_59 Position;
}
class Sphere
{
    Point3D_58 Center;
    Number_29 Radius;
}
class Plane
{
    Unit3D_34 Normal;
    Number_29 D;
}
class Triangle3D
{
    Point3D_58 A;
    Point3D_58 B;
    Point3D_58 C;
}
class Triangle2D
{
    Point2D_59 A;
    Point2D_59 B;
    Point2D_59 C;
}
class Quad3D
{
    Point3D_58 A;
    Point3D_58 B;
    Point3D_58 C;
    Point3D_58 D;
}
class Quad2D
{
    Point2D_59 A;
    Point2D_59 B;
    Point2D_59 C;
    Point2D_59 D;
}
class Point3D
{
    Vector3D_40 Value;
}
class Point2D
{
    Vector2D_39 Value;
}
class Line3D
{
    Point3D_58 A;
    Point3D_58 B;
}
class Line2D
{
    Point2D_59 A;
    Point2D_59 B;
}
class Color
{
    Unit_30 R;
    Unit_30 G;
    Unit_30 B;
    Unit_30 A;
}
class ColorLUV
{
    Percent_31 Lightness;
    Unit_30 U;
    Unit_30 V;
}
class ColorLAB
{
    Percent_31 Lightness;
    Integer_26 A;
    Integer_26 B;
}
class ColorLCh
{
    Percent_31 Lightness;
    PolarCoordinate_70 ChromaHue;
}
class ColorHSV
{
    Angle_83 Hue;
    Unit_30 S;
    Unit_30 V;
}
class ColorHSL
{
    Angle_83 Hue;
    Unit_30 Saturation;
    Unit_30 Luminance;
}
class ColorYCbCr
{
    Unit_30 Y;
    Unit_30 Cb;
    Unit_30 Cr;
}
class SphericalCoordinate
{
    Number_29 Radius;
    Angle_83 Azimuth;
    Angle_83 Polar;
}
class PolarCoordinate
{
    Number_29 Radius;
    Angle_83 Angle;
}
class LogPolarCoordinate
{
    Number_29 Rho;
    Angle_83 Azimuth;
}
class CylindricalCoordinate
{
    Number_29 RadialDistance;
    Angle_83 Azimuth;
    Number_29 Height;
}
class HorizontalCoordinate
{
    Number_29 Radius;
    Angle_83 Azimuth;
    Number_29 Height;
}
class GeoCoordinate
{
    Angle_83 Latitude;
    Angle_83 Longitude;
}
class GeoCoordinateWithAltitude
{
    GeoCoordinate_74 Coordinate;
    Number_29 Altitude;
}
class Circle
{
    Point2D_59 Center;
    Number_29 Radius;
}
class Chord
{
    Circle_76 Circle;
    Arc_92 Arc;
}
class Size2D
{
    Number_29 Width;
    Number_29 Height;
}
class Size3D
{
    Number_29 Width;
    Number_29 Height;
    Number_29 Depth;
}
class Rectangle2D
{
    Point2D_59 Center;
    Size2D_78 Size;
}
class Proportion
{
    Number_29 Value;
}
class Fraction
{
    Number_29 Numerator;
    Number_29 Denominator;
}
class Angle
{
    Number_29 Radians;
}
class Length
{
    Number_29 Meters;
}
class Mass
{
    Number_29 Kilograms;
}
class Temperature
{
    Number_29 Celsius;
}
class TimeSpan
{
    Number_29 Seconds;
}
class TimeRange
{
    DateTime_89 Min;
    DateTime_89 Max;
}
class DateTime
{
}
class AnglePair
{
    Angle_83 Start;
    Angle_83 End;
}
class Ring
{
    Circle_76 Circle;
    Number_29 InnerRadius;
}
class Arc
{
    AnglePair_90 Angles;
    Circle_76 Cirlce;
}
class TimeInterval
{
    TimeSpan_87 Start;
    TimeSpan_87 End;
}
class RealInterval
{
    Number_29 A;
    Number_29 B;
}
class Interval2D
{
    Vector2D_39 A;
    Vector2D_39 B;
}
class Interval3D
{
    Vector3D_40 A;
    Vector3D_40 B;
}
class Capsule
{
    Line3D_60 Line;
    Number_29 Radius;
}
class Matrix3D
{
    Vector4D_41 Column1;
    Vector4D_41 Column2;
    Vector4D_41 Column3;
    Vector4D_41 Column4;
}
class Cylinder
{
    Line3D_60 Line;
    Number_29 Radius;
}
class Cone
{
    Line3D_60 Line;
    Number_29 Radius;
}
class Tube
{
    Line3D_60 Line;
    Number_29 InnerRadius;
    Number_29 OuterRadius;
}
class ConeSegment
{
    Line3D_60 Line;
    Number_29 Radius1;
    Number_29 Radius2;
}
class Box2D
{
    Point2D_59 Center;
    Angle_83 Rotation;
    Size2D_78 Extent;
}
class Box3D
{
    Point3D_58 Center;
    Rotation3D_38 Rotation;
    Size3D_79 Extent;
}
class CubicBezierTriangle3D
{
    Point3D_58 A;
    Point3D_58 B;
    Point3D_58 C;
    Point3D_58 A2B;
    Point3D_58 AB2;
    Point3D_58 B2C;
    Point3D_58 BC2;
    Point3D_58 AC2;
    Point3D_58 A2C;
    Point3D_58 ABC;
}
class CubicBezier2D
{
    Point2D_59 A;
    Point2D_59 B;
    Point2D_59 C;
    Point2D_59 D;
}
class UV
{
    Unit_30 U;
    Unit_30 V;
}
class UVW
{
    Unit_30 U;
    Unit_30 V;
    Unit_30 W;
}
class CubicBezier3D
{
    Point3D_58 A;
    Point3D_58 B;
    Point3D_58 C;
    Point3D_58 D;
}
class QuadraticBezier2D
{
    Point2D_59 A;
    Point2D_59 B;
    Point2D_59 C;
}
class QuadraticBezier3D
{
    Point3D_58 A;
    Point3D_58 B;
    Point3D_58 C;
}
class Area
{
    Number_29 MetersSquared;
}
class Volume
{
    Number_29 MetersCubed;
}
class Velocity
{
    Number_29 MetersPerSecond;
}
class Acceleration
{
    Number_29 MetersPerSecondSquared;
}
class Force
{
    Number_29 Newtons;
}
class Pressure
{
    Number_29 Pascals;
}
class Energy
{
    Number_29 Joules;
}
class Memory
{
    Count_27 Bytes;
}
class Frequency
{
    Number_29 Hertz;
}
class Loudness
{
    Number_29 Decibels;
}
class LuminousIntensity
{
    Number_29 Candelas;
}
class ElectricPotential
{
    Number_29 Volts;
}
class ElectricCharge
{
    Number_29 Columbs;
}
class ElectricCurrent
{
    Number_29 Amperes;
}
class ElectricResistance
{
    Number_29 Ohms;
}
class Power
{
    Number_29 Watts;
}
class Density
{
    Number_29 KilogramsPerMeterCubed;
}
class NormalDistribution
{
    Number_29 Mean;
    Number_29 StandardDeviation;
}
class PoissonDistribution
{
    Number_29 Expected;
    Count_27 Occurrences;
}
class BernoulliDistribution
{
    Probability_132 P;
}
class Probability
{
    Number_29 Value;
}
class BinomialDistribution
{
    Count_27 Trials;
    Probability_132 P;
}
class Interval
{
    public static void Size(var x)
    // ParameterSymbol=x$2686: Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1), Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1)
    // Candidates = Interval
    Subtract(Max(x), Min(x))
    public static void IsEmpty(var x)
    // ParameterSymbol=x$2700: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1)
    // Candidates = Interval
    GreaterThanOrEquals(Min(x), Max(x))
    public static void Lerp(var x, var amount)
    // ParameterSymbol=x$2714: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1)
    // Candidates = Interval
    // ParameterSymbol=amount$2715: Argument:Ref=>FunctionGroupSymbol=Subtract$287:(2/2), Argument:Ref=>FunctionGroupSymbol=Multiply$290:(2/2)
    // Candidates = Intrinsics,ScalarArithmetic,Arithmetic
    Multiply(Min(x), Add(Subtract(1, amount), Multiply(Max(x), amount)))
    public static void InverseLerp(var x, var value)
    // ParameterSymbol=x$2744: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Size$1929:(1/1)
    // Candidates = Interval
    // ParameterSymbol=value$2745: Argument:Ref=>FunctionGroupSymbol=Subtract$287:(1/2)
    // Candidates = Intrinsics,ScalarArithmetic
    Divide(Subtract(value, Min(x)), Size(x))
    public static void Negate(var x)
    // ParameterSymbol=x$2764: Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1), Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1)
    // Candidates = Interval
    Tuple(Negative(Max(x)), Negative(Min(x)))
    public static void Reverse(var x)
    // ParameterSymbol=x$2784: Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1), Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1)
    // Candidates = Interval
    Tuple(Max(x), Min(x))
    public static void Resize(var x, var size)
    // ParameterSymbol=x$2798: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1)
    // Candidates = Interval
    // ParameterSymbol=size$2799: Argument:Ref=>FunctionGroupSymbol=Add$284:(2/2)
    // Candidates = Intrinsics,Arithmetic,ScalarArithmetic
    Tuple(Min(x), Add(Min(x), size))
    public static void Center(var x)
    // ParameterSymbol=x$2818: Argument:Ref=>FunctionGroupSymbol=Lerp$1933:(1/2)
    // Candidates = Interval
    Lerp(x, 0.5)
    public static void Contains(var x, var value)
    // ParameterSymbol=x$2826: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1)
    // Candidates = Interval
    // ParameterSymbol=value$2827: Argument:Ref=>FunctionGroupSymbol=And$299:(1/2), Argument:Ref=>FunctionGroupSymbol=LessThanOrEquals$2069:(1/2)
    // Candidates = Intrinsics,Boolean,Comparable
    LessThanOrEquals(Min(x), And(value, LessThanOrEquals(value, Max(x))))
    public static void Contains(var x, var other)
    // ParameterSymbol=x$2851: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1)
    // Candidates = Interval
    // ParameterSymbol=other$2852: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1)
    // Candidates = Interval,Comparable
    LessThanOrEquals(Min(x), And(Min(other), GreaterThanOrEquals(Max, Max(other))))
    public static void Overlaps(var x, var y)
    // ParameterSymbol=x$2879: Argument:Ref=>FunctionGroupSymbol=Clamp$1995:(1/2)
    // Candidates = Interval
    // ParameterSymbol=y$2880: Argument:Ref=>FunctionGroupSymbol=Clamp$1995:(2/2)
    // Candidates = Interval,Numerical
    Not(IsEmpty(Clamp(x, y)))
    public static void Split(var x, var t)
    // ParameterSymbol=x$2894: Argument:Ref=>FunctionGroupSymbol=Left$1955:(1/2), Argument:Ref=>FunctionGroupSymbol=Right$1957:(1/2)
    // Candidates = Interval
    // ParameterSymbol=t$2895: Argument:Ref=>FunctionGroupSymbol=Left$1955:(2/2), Argument:Ref=>FunctionGroupSymbol=Right$1957:(2/2)
    // Candidates = Interval
    Tuple(Left(x, t), Right(x, t))
    public static void Split(var x)
    // ParameterSymbol=x$2913: Argument:Ref=>FunctionGroupSymbol=Split$1953:(1/2)
    // Candidates = Interval
    Split(x, 0.5)
    public static void Left(var x, var t)
    // ParameterSymbol=x$2921: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Lerp$1933:(1/2)
    // Candidates = Interval
    // ParameterSymbol=t$2922: Argument:Ref=>FunctionGroupSymbol=Lerp$1933:(2/2)
    // Candidates = Interval
    Tuple(Min(x), Lerp(x, t))
    public static void Right(var x, var t)
    // ParameterSymbol=x$2938: Argument:Ref=>FunctionGroupSymbol=Lerp$1933:(1/2), Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1)
    // Candidates = Interval
    // ParameterSymbol=t$2939: Argument:Ref=>FunctionGroupSymbol=Lerp$1933:(2/2)
    // Candidates = Interval
    Tuple(Lerp(x, t), Max(x))
    public static void MoveTo(var x, var t)
    // ParameterSymbol=x$2955: Argument:Ref=>FunctionGroupSymbol=Size$1929:(1/1)
    // Candidates = Interval
    // ParameterSymbol=t$2956: Argument:Ref=>PredefinedSymbol=Tuple$1:(1/2), Argument:Ref=>FunctionGroupSymbol=Add$284:(1/2)
    // Candidates = Intrinsics,Arithmetic,ScalarArithmetic
    Tuple(t, Add(t, Size(x)))
    public static void LeftHalf(var x)
    // ParameterSymbol=x$2972: Argument:Ref=>FunctionGroupSymbol=Left$1955:(1/2)
    // Candidates = Interval
    Left(x, 0.5)
    public static void RightHalf(var x)
    // ParameterSymbol=x$2980: Argument:Ref=>FunctionGroupSymbol=Right$1957:(1/2)
    // Candidates = Interval
    Right(x, 0.5)
    public static void HalfSize(var x)
    // ParameterSymbol=x$2988: Argument:Ref=>FunctionGroupSymbol=Size$1929:(1/1)
    // Candidates = Interval
    Half(Size(x))
    public static void Recenter(var x, var c)
    // ParameterSymbol=x$2997: Argument:Ref=>FunctionGroupSymbol=HalfSize$1965:(1/1), Argument:Ref=>FunctionGroupSymbol=HalfSize$1965:(1/1)
    // Candidates = Interval
    // ParameterSymbol=c$2998: Argument:Ref=>FunctionGroupSymbol=Subtract$287:(1/2), Argument:Ref=>FunctionGroupSymbol=Add$284:(1/2)
    // Candidates = Intrinsics,ScalarArithmetic,Arithmetic
    Tuple(Subtract(c, HalfSize(x)), Add(c, HalfSize(x)))
    public static void Clamp(var x, var y)
    // ParameterSymbol=x$3022: Argument:Ref=>FunctionGroupSymbol=Clamp$1995:(1/2), Argument:Ref=>FunctionGroupSymbol=Clamp$1995:(1/2)
    // Candidates = Interval
    // ParameterSymbol=y$3023: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1)
    // Candidates = Interval,Comparable
    Tuple(Clamp(x, Min(y)), Clamp(x, Max(y)))
    public static void Clamp(var x, var value)
    // ParameterSymbol=x$3047: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1), Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1)
    // Candidates = Interval
    // ParameterSymbol=value$3048: Argument:Ref=>FunctionGroupSymbol=LessThan$2063:(1/2), Argument:Ref=>FunctionGroupSymbol=GreaterThan$2071:(1/2)
    // Candidates = Comparable
    LessThan(value, Min(x)
        ? Min(x)
        : GreaterThan(value, Max(x)
            ? Max(x)
            : value
        )
    )
    public static void Between(var x, var value)
    // ParameterSymbol=x$3079: Argument:Ref=>FunctionGroupSymbol=Min$2075:(1/1), Argument:Ref=>FunctionGroupSymbol=Max$2077:(1/1)
    // Candidates = Interval
    // ParameterSymbol=value$3080: Argument:Ref=>FunctionGroupSymbol=GreaterThanOrEquals$2073:(1/2), Argument:Ref=>FunctionGroupSymbol=LessThanOrEquals$2069:(1/2)
    // Candidates = Comparable
    GreaterThanOrEquals(value, And(Min(x), LessThanOrEquals(value, Max(x))))
    public static void Unit()
    Tuple(0, 1)
}
class Vector
{
    public static void Sum(var v)
    // ParameterSymbol=v$3111: Argument:Ref=>FunctionGroupSymbol=Aggregate$2099:(1/3)
    // Candidates = Vector
    Aggregate(v, 0, Add)
    public static void SumSquares(var v)
    // ParameterSymbol=v$3121: Argument:Ref=>FunctionGroupSymbol=Square$1989:(1/1)
    // Candidates = Vector
    Aggregate(Square(v), 0, Add)
    public static void LengthSquared(var v)
    // ParameterSymbol=v$3134: Argument:Ref=>FunctionGroupSymbol=SumSquares$1979:(1/1)
    // Candidates = Vector
    SumSquares(v)
    public static void Length(var v)
    // ParameterSymbol=v$3140: Argument:Ref=>FunctionGroupSymbol=LengthSquared$1981:(1/1)
    // Candidates = Vector
    SquareRoot(LengthSquared(v))
    public static void Dot(var v1, var v2)
    // ParameterSymbol=v1$3149: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Vector
    // ParameterSymbol=v2$3150: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(2/2)
    // Candidates = Intrinsics,Arithmetic,ScalarArithmetic
    Sum(Multiply(v1, v2))
}
class Numerical
{
    public static void SquareRoot(var x)
    // ParameterSymbol=x$3161: Argument:Ref=>FunctionGroupSymbol=Pow$180:(1/2)
    // Candidates = Numerical
    Pow(x, 0.5)
    public static void Square(var x)
    // ParameterSymbol=x$3169: 
    // Candidates = Numerical
    Multiply(Value, Value)
    public static void Clamp(var x, var min, var max)
    // ParameterSymbol=x$3177: Argument:Ref=>FunctionGroupSymbol=Clamp$1995:(1/2)
    // Candidates = Numerical
    // ParameterSymbol=min$3178: Argument:Ref=>PredefinedSymbol=Tuple$1:(1/2)
    // Candidates = Any
    // ParameterSymbol=max$3179: Argument:Ref=>PredefinedSymbol=Tuple$1:(2/2)
    // Candidates = Any
    Clamp(x, Tuple(min, max))
    public static void Clamp(var x, var i)
    // ParameterSymbol=x$3192: Argument:Ref=>FunctionGroupSymbol=Clamp$1995:(2/2)
    // Candidates = Numerical
    // ParameterSymbol=i$3193: Argument:Ref=>FunctionGroupSymbol=Clamp$1995:(1/2)
    // Candidates = Interval,Numerical
    Clamp(i, x)
    public static void Clamp(var x)
    // ParameterSymbol=x$3201: Argument:Ref=>FunctionGroupSymbol=Clamp$1995:(1/3)
    // Candidates = Numerical
    Clamp(x, 0, 1)
    public static void PlusOne(var x)
    // ParameterSymbol=x$3211: Argument:Ref=>FunctionGroupSymbol=Add$284:(1/2)
    // Candidates = Numerical
    Add(x, 1)
    public static void MinusOne(var x)
    // ParameterSymbol=x$3219: Argument:Ref=>FunctionGroupSymbol=Subtract$287:(1/2)
    // Candidates = Numerical
    Subtract(x, 1)
    public static void FromOne(var x)
    // ParameterSymbol=x$3227: Argument:Ref=>FunctionGroupSymbol=Subtract$287:(2/2)
    // Candidates = Numerical
    Subtract(1, x)
    public static void Sign(var x)
    // ParameterSymbol=x$3235: Argument:Ref=>FunctionGroupSymbol=LessThan$2063:(1/2), Argument:Ref=>FunctionGroupSymbol=GreaterThan$2071:(1/2)
    // Candidates = Numerical
    LessThan(x, 0
        ? Negative(1)
        : GreaterThan(x, 0
            ? 1
            : 0
        )
    )
    public static void Abs(var x)
    // ParameterSymbol=x$3257: 
    // Candidates = Numerical
    LessThan(Value, 0
        ? Negative(Value)
        : Value
    )
    public static void Half(var x)
    // ParameterSymbol=x$3271: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 2)
    public static void Third(var x)
    // ParameterSymbol=x$3279: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 3)
    public static void Quarter(var x)
    // ParameterSymbol=x$3287: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 4)
    public static void Fifth(var x)
    // ParameterSymbol=x$3295: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 5)
    public static void Sixth(var x)
    // ParameterSymbol=x$3303: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 6)
    public static void Seventh(var x)
    // ParameterSymbol=x$3311: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 7)
    public static void Eighth(var x)
    // ParameterSymbol=x$3319: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 8)
    public static void Ninth(var x)
    // ParameterSymbol=x$3327: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 9)
    public static void Tenth(var x)
    // ParameterSymbol=x$3335: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 10)
    public static void Sixteenth(var x)
    // ParameterSymbol=x$3343: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 16)
    public static void Hundredth(var x)
    // ParameterSymbol=x$3351: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 100)
    public static void Thousandth(var x)
    // ParameterSymbol=x$3359: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, 1000)
    public static void Millionth(var x)
    // ParameterSymbol=x$3367: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, Divide(1000, 1000))
    public static void Billionth(var x)
    // ParameterSymbol=x$3380: Argument:Ref=>FunctionGroupSymbol=Divide$293:(1/2)
    // Candidates = Numerical
    Divide(x, Divide(1000, Divide(1000, 1000)))
    public static void Hundred(var x)
    // ParameterSymbol=x$3398: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Numerical
    Multiply(x, 100)
    public static void Thousand(var x)
    // ParameterSymbol=x$3406: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Numerical
    Multiply(x, 1000)
    public static void Million(var x)
    // ParameterSymbol=x$3414: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Numerical
    Multiply(x, Multiply(1000, 1000))
    public static void Billion(var x)
    // ParameterSymbol=x$3427: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Numerical
    Multiply(x, Multiply(1000, Multiply(1000, 1000)))
    public static void Twice(var x)
    // ParameterSymbol=x$3445: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Numerical
    Multiply(x, 2)
    public static void Thrice(var x)
    // ParameterSymbol=x$3453: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Numerical
    Multiply(x, 3)
    public static void SmoothStep(var x)
    // ParameterSymbol=x$3461: Argument:Ref=>FunctionGroupSymbol=Square$1989:(1/1), Argument:Ref=>FunctionGroupSymbol=Twice$2043:(1/1)
    // Candidates = Numerical
    Multiply(Square(x), Subtract(3, Twice(x)))
    public static void Pow2(var x)
    // ParameterSymbol=x$3480: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2), Argument:Ref=>FunctionGroupSymbol=Multiply$290:(2/2)
    // Candidates = Numerical
    Multiply(x, x)
    public static void Pow3(var x)
    // ParameterSymbol=x$3488: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(2/2), Argument:Ref=>FunctionGroupSymbol=Pow2$2049:(1/1)
    // Candidates = Numerical
    Multiply(Pow2(x), x)
    public static void Pow4(var x)
    // ParameterSymbol=x$3499: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(2/2), Argument:Ref=>FunctionGroupSymbol=Pow3$2051:(1/1)
    // Candidates = Numerical
    Multiply(Pow3(x), x)
    public static void Pow5(var x)
    // ParameterSymbol=x$3510: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(2/2), Argument:Ref=>FunctionGroupSymbol=Pow4$2053:(1/1)
    // Candidates = Numerical
    Multiply(Pow4(x), x)
    public static void Turns(var x)
    // ParameterSymbol=x$3521: Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Numerical
    Multiply(x, Multiply(3.1415926535897, 2))
    public static void AlmostZero(var x)
    // ParameterSymbol=x$3534: Argument:Ref=>FunctionGroupSymbol=Abs$2005:(1/1)
    // Candidates = Numerical
    LessThan(Abs(x), 1E-08)
}
class Comparable
{
    public static void Equals(var a, var b)
    // ParameterSymbol=a$3545: Argument:Ref=>FunctionGroupSymbol=Compare$259:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=b$3546: Argument:Ref=>FunctionGroupSymbol=Compare$259:(2/2)
    // Candidates = Comparable
    Equals(Compare(a, b), 0)
    public static void LessThan(var a, var b)
    // ParameterSymbol=a$3559: Argument:Ref=>FunctionGroupSymbol=Compare$259:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=b$3560: Argument:Ref=>FunctionGroupSymbol=Compare$259:(2/2)
    // Candidates = Comparable
    LessThan(Compare(a, b), 0)
    public static void Lesser(var a, var b)
    // ParameterSymbol=a$3573: Argument:Ref=>FunctionGroupSymbol=LessThanOrEquals$2069:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=b$3574: Argument:Ref=>FunctionGroupSymbol=LessThanOrEquals$2069:(2/2)
    // Candidates = Comparable
    LessThanOrEquals(a, b)
        ? a
        : b

    public static void Greater(var a, var b)
    // ParameterSymbol=a$3585: Argument:Ref=>FunctionGroupSymbol=GreaterThanOrEquals$2073:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=b$3586: Argument:Ref=>FunctionGroupSymbol=GreaterThanOrEquals$2073:(2/2)
    // Candidates = Comparable
    GreaterThanOrEquals(a, b)
        ? a
        : b

    public static void LessThanOrEquals(var a, var b)
    // ParameterSymbol=a$3597: Argument:Ref=>FunctionGroupSymbol=Compare$259:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=b$3598: Argument:Ref=>FunctionGroupSymbol=Compare$259:(2/2)
    // Candidates = Comparable
    LessThanOrEquals(Compare(a, b), 0)
    public static void GreaterThan(var a, var b)
    // ParameterSymbol=a$3611: Argument:Ref=>FunctionGroupSymbol=Compare$259:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=b$3612: Argument:Ref=>FunctionGroupSymbol=Compare$259:(2/2)
    // Candidates = Comparable
    GreaterThan(Compare(a, b), 0)
    public static void GreaterThanOrEquals(var a, var b)
    // ParameterSymbol=a$3625: Argument:Ref=>FunctionGroupSymbol=Compare$259:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=b$3626: Argument:Ref=>FunctionGroupSymbol=Compare$259:(2/2)
    // Candidates = Comparable
    GreaterThanOrEquals(Compare(a, b), 0)
    public static void Min(var a, var b)
    // ParameterSymbol=a$3639: Argument:Ref=>FunctionGroupSymbol=LessThan$2063:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=b$3640: Argument:Ref=>FunctionGroupSymbol=LessThan$2063:(2/2)
    // Candidates = Comparable
    LessThan(a, b)
        ? a
        : b

    public static void Max(var a, var b)
    // ParameterSymbol=a$3651: Argument:Ref=>FunctionGroupSymbol=GreaterThan$2071:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=b$3652: Argument:Ref=>FunctionGroupSymbol=GreaterThan$2071:(2/2)
    // Candidates = Comparable
    GreaterThan(a, b)
        ? a
        : b

    public static void Between(var v, var a, var b)
    // ParameterSymbol=v$3663: Argument:Ref=>FunctionGroupSymbol=Between$2081:(1/2)
    // Candidates = Comparable
    // ParameterSymbol=a$3664: Argument:Ref=>TypeDefSymbol=Interval$134:(1/2)
    // Candidates = Any
    // ParameterSymbol=b$3665: Argument:Ref=>TypeDefSymbol=Interval$134:(2/2)
    // Candidates = Any
    Between(v, Interval(a, b))
    public static void Between(var v, var i)
    // ParameterSymbol=v$3678: Argument:Ref=>FunctionGroupSymbol=Contains$1947:(2/2)
    // Candidates = Comparable
    // ParameterSymbol=i$3679: Argument:Ref=>FunctionGroupSymbol=Contains$1947:(1/2)
    // Candidates = Interval
    Contains(i, v)
}
class Boolean
{
    public static void XOr(var a, var b)
    // ParameterSymbol=a$3687: 
    // Candidates = Boolean
    // ParameterSymbol=b$3688: Argument:Ref=>FunctionGroupSymbol=Not$305:(1/1)
    // Candidates = Intrinsics,Boolean
    a
        ? Not(b)
        : b

    public static void NAnd(var a, var b)
    // ParameterSymbol=a$3697: Argument:Ref=>FunctionGroupSymbol=And$299:(1/2)
    // Candidates = Boolean
    // ParameterSymbol=b$3698: Argument:Ref=>FunctionGroupSymbol=And$299:(2/2)
    // Candidates = Intrinsics,Boolean
    Not(And(a, b))
    public static void NOr(var a, var b)
    // ParameterSymbol=a$3709: Argument:Ref=>FunctionGroupSymbol=Or$302:(1/2)
    // Candidates = Boolean
    // ParameterSymbol=b$3710: Argument:Ref=>FunctionGroupSymbol=Or$302:(2/2)
    // Candidates = Intrinsics,Boolean
    Not(Or(a, b))
}
class Equatable
{
    public static void NotEquals(var x)
    // ParameterSymbol=x$3721: Argument:Ref=>FunctionGroupSymbol=Equals$2061:(1/1)
    // Candidates = Equatable
    Not(Equals(x))
}
class Array
{
    public static void Map(var xs, var f)
    // ParameterSymbol=xs$3730: Argument:Ref=>TypeDefSymbol=Count$27:(1/1), Argument:Ref=>FunctionGroupSymbol=At$352:(1/2)
    // Candidates = Array
    // ParameterSymbol=f$3731: Invoked:(ArgumentSymbol)
    // Candidates = Function
    Map(Count(xs), (i) => 
    f(At(xs, i)))
    public static void Zip(var xs, var ys, var f)
    // ParameterSymbol=xs$3753: Argument:Ref=>TypeDefSymbol=Count$27:(1/1)
    // Candidates = Array
    // ParameterSymbol=ys$3754: Argument:Ref=>FunctionGroupSymbol=At$352:(1/2)
    // Candidates = Vector,Array
    // ParameterSymbol=f$3755: Invoked:(ArgumentSymbol,ArgumentSymbol)
    // Candidates = Function
    Array(Count(xs), (i) => 
    f(At(i), At(ys, i)))
    public static void Skip(var xs, var n)
    // ParameterSymbol=xs$3782: 
    // Candidates = Array
    // ParameterSymbol=n$3783: Argument:Ref=>FunctionGroupSymbol=Subtract$287:(2/2), Argument:Ref=>FunctionGroupSymbol=Subtract$287:(2/2)
    // Candidates = Intrinsics,ScalarArithmetic
    Array(Subtract(Count, n), (i) => 
    At(Subtract(i, n)))
    public static void Take(var xs, var n)
    // ParameterSymbol=xs$3807: 
    // Candidates = Array
    // ParameterSymbol=n$3808: Argument:Ref=>TypeDefSymbol=Array$140:(1/2)
    // Candidates = Any
    Array(n, (i) => 
    At)
    public static void Aggregate(var xs, var init, var f)
    // ParameterSymbol=xs$3819: Argument:Ref=>FunctionGroupSymbol=IsEmpty$2103:(1/1), Argument:Ref=>FunctionGroupSymbol=Rest$2101:(1/1)
    // Candidates = Array
    // ParameterSymbol=init$3820: Argument:Ref=>ParameterSymbol=f$3821:(1/2)
    // Candidates = Any
    // ParameterSymbol=f$3821: Invoked:(ArgumentSymbol,ArgumentSymbol), Invoked:(ArgumentSymbol)
    // Candidates = Function
    IsEmpty(xs)
        ? init
        : f(init, f(Rest(xs)))

    public static void Rest(var xs)
    // ParameterSymbol=xs$3841: Argument:Ref=>FunctionGroupSymbol=Skip$2095:(1/2)
    // Candidates = Array
    Skip(xs, 1)
    public static void IsEmpty(var xs)
    // ParameterSymbol=xs$3849: Argument:Ref=>TypeDefSymbol=Count$27:(1/1)
    // Candidates = Array
    Equals(Count(xs), 0)
    public static void First(var xs)
    // ParameterSymbol=xs$3860: Argument:Ref=>FunctionGroupSymbol=At$352:(1/2)
    // Candidates = Array
    At(xs, 0)
    public static void Last(var xs)
    // ParameterSymbol=xs$3868: Argument:Ref=>FunctionGroupSymbol=At$352:(1/2), Argument:Ref=>TypeDefSymbol=Count$27:(1/1)
    // Candidates = Array
    At(xs, Subtract(Count(xs), 1))
    public static void Slice(var xs, var from, var count)
    // ParameterSymbol=xs$3884: Argument:Ref=>FunctionGroupSymbol=Skip$2095:(1/2)
    // Candidates = Array
    // ParameterSymbol=from$3885: Argument:Ref=>FunctionGroupSymbol=Skip$2095:(2/2)
    // Candidates = Array
    // ParameterSymbol=count$3886: Argument:Ref=>FunctionGroupSymbol=Take$2097:(2/2)
    // Candidates = Array
    Take(Skip(xs, from), count)
    public static void Join(var xs, var sep)
    // ParameterSymbol=xs$3899: Argument:Ref=>FunctionGroupSymbol=IsEmpty$2103:(1/1), Argument:Ref=>FunctionGroupSymbol=First$2105:(1/1), Argument:Ref=>FunctionGroupSymbol=Skip$2095:(1/2)
    // Candidates = Array
    // ParameterSymbol=sep$3900: Argument:Ref=>FunctionGroupSymbol=Interpolate$192:(2/3)
    // Candidates = Intrinsics
    IsEmpty(xs)
        ? 
        : Add(ToString(First(xs)), Aggregate(Skip(xs, 1), , (acc, cur) => 
        Interpolate(acc, sep, cur)))

    public static void All(var xs, var f)
    // ParameterSymbol=xs$3943: Argument:Ref=>FunctionGroupSymbol=IsEmpty$2103:(1/1), Argument:Ref=>FunctionGroupSymbol=First$2105:(1/1), Argument:Ref=>FunctionGroupSymbol=Rest$2101:(1/1)
    // Candidates = Array
    // ParameterSymbol=f$3944: Invoked:(ArgumentSymbol), Invoked:(ArgumentSymbol)
    // Candidates = Function
    IsEmpty(xs)
        ? True
        : And(f(First(xs)), f(Rest(xs)))

    public static void JoinStrings(var xs, var sep)
    // ParameterSymbol=xs$3970: Argument:Ref=>FunctionGroupSymbol=IsEmpty$2103:(1/1), Argument:Ref=>FunctionGroupSymbol=First$2105:(1/1), Argument:Ref=>FunctionGroupSymbol=Rest$2101:(1/1)
    // Candidates = Array
    // ParameterSymbol=sep$3971: 
    // Candidates = Any
    IsEmpty(xs)
        ? 
        : Add(First(xs), Aggregate(Rest(xs), , (x, acc) => 
        Add(acc, Add(, , ToString(x)))))

}
class Easings
{
    public static void BlendEaseFunc(var p, var easeIn, var easeOut)
    // ParameterSymbol=p$4015: Argument:Ref=>FunctionGroupSymbol=LessThan$2063:(1/2), Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2), Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2)
    // Candidates = Comparable,Intrinsics,Arithmetic,ScalarArithmetic
    // ParameterSymbol=easeIn$4016: Invoked:(ArgumentSymbol)
    // Candidates = Function
    // ParameterSymbol=easeOut$4017: Invoked:(ArgumentSymbol)
    // Candidates = Function
    LessThan(p, 0.5
        ? Multiply(0.5, easeIn(Multiply(p, 2)))
        : Multiply(0.5, Add(easeOut(Multiply(p, Subtract(2, 1))), 0.5))
    )
    public static void InvertEaseFunc(var p, var easeIn)
    // ParameterSymbol=p$4064: Argument:Ref=>FunctionGroupSymbol=Subtract$287:(2/2)
    // Candidates = Intrinsics,ScalarArithmetic
    // ParameterSymbol=easeIn$4065: Invoked:(ArgumentSymbol)
    // Candidates = Function
    Subtract(1, easeIn(Subtract(1, p)))
    public static void Linear(var p)
    // ParameterSymbol=p$4081: 
    // Candidates = Any
    p
    public static void QuadraticEaseIn(var p)
    // ParameterSymbol=p$4084: Argument:Ref=>FunctionGroupSymbol=Pow2$2049:(1/1)
    // Candidates = Numerical
    Pow2(p)
    public static void QuadraticEaseOut(var p)
    // ParameterSymbol=p$4090: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, QuadraticEaseIn)
    public static void QuadraticEaseInOut(var p)
    // ParameterSymbol=p$4098: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, QuadraticEaseIn, QuadraticEaseOut)
    public static void CubicEaseIn(var p)
    // ParameterSymbol=p$4108: Argument:Ref=>FunctionGroupSymbol=Pow3$2051:(1/1)
    // Candidates = Numerical
    Pow3(p)
    public static void CubicEaseOut(var p)
    // ParameterSymbol=p$4114: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, CubicEaseIn)
    public static void CubicEaseInOut(var p)
    // ParameterSymbol=p$4122: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, CubicEaseIn, CubicEaseOut)
    public static void QuarticEaseIn(var p)
    // ParameterSymbol=p$4132: Argument:Ref=>FunctionGroupSymbol=Pow4$2053:(1/1)
    // Candidates = Numerical
    Pow4(p)
    public static void QuarticEaseOut(var p)
    // ParameterSymbol=p$4138: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, QuarticEaseIn)
    public static void QuarticEaseInOut(var p)
    // ParameterSymbol=p$4146: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, QuarticEaseIn, QuarticEaseOut)
    public static void QuinticEaseIn(var p)
    // ParameterSymbol=p$4156: Argument:Ref=>FunctionGroupSymbol=Pow5$2055:(1/1)
    // Candidates = Numerical
    Pow5(p)
    public static void QuinticEaseOut(var p)
    // ParameterSymbol=p$4162: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, QuinticEaseIn)
    public static void QuinticEaseInOut(var p)
    // ParameterSymbol=p$4170: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, QuinticEaseIn, QuinticEaseOut)
    public static void SineEaseIn(var p)
    // ParameterSymbol=p$4180: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, SineEaseOut)
    public static void SineEaseOut(var p)
    // ParameterSymbol=p$4188: Argument:Ref=>FunctionGroupSymbol=Quarter$2011:(1/1)
    // Candidates = Numerical
    Sin(Turns(Quarter(p)))
    public static void SineEaseInOut(var p)
    // ParameterSymbol=p$4200: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, SineEaseIn, SineEaseOut)
    public static void CircularEaseIn(var p)
    // ParameterSymbol=p$4210: Argument:Ref=>FunctionGroupSymbol=Pow2$2049:(1/1)
    // Candidates = Numerical
    FromOne(SquareRoot(FromOne(Pow2(p))))
    public static void CircularEaseOut(var p)
    // ParameterSymbol=p$4225: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, CircularEaseIn)
    public static void CircularEaseInOut(var p)
    // ParameterSymbol=p$4233: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, CircularEaseIn, CircularEaseOut)
    public static void ExponentialEaseIn(var p)
    // ParameterSymbol=p$4243: Argument:Ref=>FunctionGroupSymbol=AlmostZero$2059:(1/1), Argument:Ref=>FunctionGroupSymbol=MinusOne$1999:(1/1)
    // Candidates = Numerical
    AlmostZero(p)
        ? p
        : Pow(2, Multiply(10, MinusOne(p)))

    public static void ExponentialEaseOut(var p)
    // ParameterSymbol=p$4265: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, ExponentialEaseIn)
    public static void ExponentialEaseInOut(var p)
    // ParameterSymbol=p$4273: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, ExponentialEaseIn, ExponentialEaseOut)
    public static void ElasticEaseIn(var p)
    // ParameterSymbol=p$4283: Argument:Ref=>FunctionGroupSymbol=Quarter$2011:(1/1), Argument:Ref=>FunctionGroupSymbol=MinusOne$1999:(1/1)
    // Candidates = Numerical
    Multiply(13, Multiply(Turns(Quarter(p)), Sin(Radians(Pow(2, Multiply(10, MinusOne(p)))))))
    public static void ElasticEaseOut(var p)
    // ParameterSymbol=p$4321: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, ElasticEaseIn)
    public static void ElasticEaseInOut(var p)
    // ParameterSymbol=p$4329: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, ElasticEaseIn, ElasticEaseOut)
    public static void BackEaseIn(var p)
    // ParameterSymbol=p$4339: Argument:Ref=>FunctionGroupSymbol=Pow3$2051:(1/1), Argument:Ref=>FunctionGroupSymbol=Multiply$290:(1/2), Argument:Ref=>FunctionGroupSymbol=Half$2007:(1/1)
    // Candidates = Numerical,Intrinsics,Arithmetic,ScalarArithmetic
    Subtract(Pow3(p), Multiply(p, Sin(Turns(Half(p)))))
    public static void BackEaseOut(var p)
    // ParameterSymbol=p$4364: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, BackEaseIn)
    public static void BackEaseInOut(var p)
    // ParameterSymbol=p$4372: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, BackEaseIn, BackEaseOut)
    public static void BounceEaseIn(var p)
    // ParameterSymbol=p$4382: Argument:Ref=>FunctionGroupSymbol=InvertEaseFunc$2119:(1/2)
    // Candidates = Easings
    InvertEaseFunc(p, BounceEaseOut)
    public static void BounceEaseOut(var p)
    // ParameterSymbol=p$4390: Argument:Ref=>FunctionGroupSymbol=LessThan$2063:(1/2), Argument:Ref=>FunctionGroupSymbol=Pow2$2049:(1/1), Argument:Ref=>FunctionGroupSymbol=LessThan$2063:(1/2), Argument:Ref=>FunctionGroupSymbol=Pow2$2049:(1/1), Argument:Ref=>FunctionGroupSymbol=Add$284:(1/2), Argument:Ref=>FunctionGroupSymbol=LessThan$2063:(1/2), Argument:Ref=>FunctionGroupSymbol=Pow2$2049:(1/1), Argument:Ref=>FunctionGroupSymbol=Add$284:(1/2), Argument:Ref=>FunctionGroupSymbol=Pow2$2049:(1/1), Argument:Ref=>FunctionGroupSymbol=Add$284:(1/2)
    // Candidates = Comparable,Numerical,Intrinsics,Arithmetic,ScalarArithmetic
    LessThan(p, Divide(4, 11))
        ? Multiply(121, Divide(Pow2(p), 16))
        : LessThan(p, Divide(8, 11))
            ? Divide(363, Multiply(40, Subtract(Pow2(p), Divide(99, Multiply(10, Add(p, Divide(17, 5)))))))
            : LessThan(p, Divide(9, 10))
                ? Divide(4356, Multiply(361, Subtract(Pow2(p), Divide(35442, Multiply(1805, Add(p, Divide(16061, 1805)))))))
                : Divide(54, Multiply(5, Subtract(Pow2(p), Divide(513, Multiply(25, Add(p, Divide(268, 25)))))))



    public static void BounceEaseInOut(var p)
    // ParameterSymbol=p$4559: Argument:Ref=>FunctionGroupSymbol=BlendEaseFunc$2117:(1/3)
    // Candidates = Easings
    BlendEaseFunc(p, BounceEaseIn, BounceEaseOut)
}
