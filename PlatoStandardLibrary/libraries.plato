library Interval
{
    Size(x: Interval<$Value, $Size>): $Size
        => x.Max - x.Min;
 
    Lerp(x: Interval<$Value, $Size>, amount: Number): $Value
        => x.Min.Lerp(x.Max, amount);
    
    Reverse(x: Interval<$Value, $Size>): Interval<$Value, $Size> 
        => (x.Max, x.Min);
        
    Center(x: Interval<$Value, $Size>): $Value
        => x.Lerp(0.5);    
    
    Contains(x: Interval<$Value, $Size>, value: $Value): Boolean 
        => value.Between(x.Min, x.Max);
    
    Contains(x: Interval<$Value, $Size>, y: Interval<$Value, $Size>): Boolean 
        => x.Contains(y.Min) && x.Contains(y.Max);
    
    Overlaps(x: Interval<$Value, $Size>, y: Interval<$Value, $Size>): Boolean 
        => x.Contains(y.Min) || x.Contains(y.Max) || y.Contains(x.Min) || y.Contains(x.Max);
    
    SplitAt(x: Interval<$Value, $Size>, t: Number): Tuple2<Interval<$Value, $Size>, Interval<$Value, $Size>> 
        => (x.Left(t), x.Right(t));
    
    Split(x: Interval<$Value, $Size>): Tuple2<Interval<$Value, $Size>, Interval<$Value, $Size>>
        => x.SplitAt(0.5);

    Left(x: Interval<$Value, $Size>, t: Number): Interval<$Value, $Size>
        => (x.Min, x.Lerp(t));
    
    Right(x: Interval<$Value, $Size>, t: Number): Interval<$Value, $Size>
        => (x.Lerp(t), x.Max);

    MoveTo(x: Interval<$Value, $Size>, v: $Value): Interval<$Value, $Size>
        => (v, v + x.Size);
    
    LeftHalf(x: Interval<$Value, $Size>): Interval<$Value, $Size> 
        => x.Left(0.5);
    
    RightHalf(x: Interval<$Value, $Size>): Interval<$Value, $Size> 
        => x.Right(0.5);
    
    Recenter(x: Interval<$Value, $Size>, c: $Value): Interval<$Value, $Size> 
        => (c - x.Size.Half, c + x.Size.Half);
    
    Clamp(x: Interval<$Value, $Size>, y: Interval<$Value, $Size>): Interval<$Value, $Size>
        => (x.Clamp(y.Min), x.Clamp(y.Max));
    
    Clamp(x: Interval<$Value, $Size>, value: $Value): $Value
        => value.Clamp(x.Min, x.Max);
}

library Vector
{
    Sum(v: Vector): Number 
    {
        var r = 0.0;
        for (var i = 0; i < v.Count; i = i + 1)
            r = r + v[i];
        return r;
    }    

    Count(v: UV): Integer
        => 2;
   
    Count(v: UVW): Integer
        => 3;
   
    Count(c: Complex): Integer
        => 2;
   
    Count(v: Vector2D): Integer
        => 2;

    Count(v: Vector3D): Integer
        => 3;
    
    Count(v: Vector4D): Integer
        => 4;

    At(v: UV, n: Integer): Unit
        => n == 0 ? v.U : v.V;
   
    At(v: UVW, n: Integer): Unit
        => n == 0 ? v.U : n == 1 ? v.V : v.W;   
   
    At(c: Complex, n: Integer): Number
        => n == 0 ? c.Real : c.Imaginary;

    At(v: Vector2D, n: Integer): Number
        => n == 0 ? v.X : v.Y;

    At(v: Vector3D, n: Integer): Number
        => n == 0 ? v.X : n == 1 ? v.Y : v.Z;

    At(v: Vector4D, n: Integer): Number
        => n == 0 ? v.X : n == 1 ? v.Y : n == 2 ? v.Z : v.W;

    SumSquares(v: Vector): Number
        => v.Square.Sum; 
    
    MagnitudeSquared(v: Vector): Number
        => v.SumSquares;
    
    Magnitude(v: Vector): Number
        => v.MagnitudeSquared.SquareRoot;
    
    Dot(v1: Vector, v2: Vector): Number
        => (v1 * v2).Sum;

    Normal(v: Vector): Vector
        => v / v.Magnitude;

    Average(v: Vector): Number
        => v.Sum / v.Count;

    // TODO: the following seems like boilerplate that should be generated by the compiler.

    Subtract(a: Point2D, b: Point2D): Vector2D
        => (a.X - b.X, a.Y - b.Y);

    Subtract(a: Point3D, b: Point3D): Vector3D
        => (a.X - b.X, a.Y - b.Y, a.Z - b.Z);

    Subtract(a: Point4D, b: Point4D): Vector4D
        => (a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);

    Subtract(a: Point2D, b: Vector2D): Point2D
        => (a.X - b.X, a.Y - b.Y);

    Subtract(a: Point3D, b: Vector3D): Point3D
        => (a.X - b.X, a.Y - b.Y, a.Z - b.Z);

    Subtract(a: Point4D, b: Vector4D): Point4D
        => (a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);

    Add(a: Point2D, b: Vector2D): Point2D
        => (a.X + b.X, a.Y + b.Y);

    Add(a: Point3D, b: Vector3D): Point3D
        => (a.X + b.X, a.Y + b.Y, a.Z + b.Z);

    Add(a: Point4D, b: Vector4D): Point4D
        => (a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);
}

library Numerical
{
    Magnitude(x: Real): Number
        => x.Value;

    SquareRoot(x: Number): Number 
        => x.Pow(0.5);

    SmoothStep(x: Number): Number
        => x.Square * (3.0 - x.Twice);    

    Square(x: Arithmetic): Arithmetic 
        => x * x;

    ClampOne(x: Number): Number 
        => x.Clamp(0.0, 1.0);

    PlusOne(x: Numerical): Numerical 
        => x + x.One;

    MinusOne(x: Numerical): Numerical
        => x - x.One;
    
    FromOne(x: Numerical): Numerical 
        => x.One - x;

    GtZ(x : Comparable): Boolean
        => x > x.Zero;

    LtZ(x : Comparable): Boolean
        => x < x.Zero;

    GtEqZ(x : Comparable): Boolean
        => x >= x.Zero;

    LtEqZ(x : Comparable): Boolean
        => x <= x.Zero;

    IsPositive(x: Comparable): Boolean
        => x.GtEqZ;

    IsNegative(x: Comparable): Boolean
        => x.LtZ;

    Sign(x: Number): Number 
        => x.LtZ ? -x.One : x.GtZ ? x.One : x.Zero;

    Abs(x: Number): Number 
        => x.LtZ ? -x: x;
    
    Half(x: ScalarArithmetic): ScalarArithmetic
        => x / 2.0;
        
    Quarter(x:ScalarArithmetic): ScalarArithmetic
        => x / 4.0;
    
    Eighth(x:ScalarArithmetic): ScalarArithmetic
        => x / 8.0;
        
    Tenth(x:ScalarArithmetic): ScalarArithmetic 
        => x / 10.0;
    
    Twice(x:ScalarArithmetic): ScalarArithmetic 
        => x * 2.0;
    
    TwoPi(): Number 
        => Pi.Twice;
    
    Pi(): Number 
        => 3.1415926535897;

    Epsilon(): Number
        => 1E-15;

    MultiplyEpsilon(x: Number, y: Number): Number
        => x.Abs.Greater(y.Abs) * Epsilon;

    // https://stackoverflow.com/a/2411661
    AlmostEqual(x: Number, y: Number): Boolean
        => (x-y).Abs <= x.MultiplyEpsilon(y);

    AlmostZero(x: Number): Boolean
        => x.Abs < Epsilon; 

    Lerp(a: ScalarArithmetic, b: ScalarArithmetic, t: Number): ScalarArithmetic
        => a * t.FromOne + b * t;

    Nearest(a: Number, b: Number, t: Number): Number
        => t <= 0.5 ? a : b;
        
    Between(self: Comparable, min: Comparable, max: Comparable): Boolean
        => self >= min && self <= max;

    Percent(self: Number): Unit
        => self / 100.0;

    Percent(self: Unit): Number
        => self.Value * 100.0;

    InverseLerp(a: Number, b: Number, v: Number): Number
        => (v - a) / (b - a);

    Remap(aIn: Number, bIn: Number, aOut: Number, bOut: Number, v: Number): Number
        => aOut.Lerp(bOut, aIn.InverseLerp(aOut, v));
}

library Angles 
{
    Radians(x : Number): Angle
        => x;

    Degrees(x: Number): Angle
        => (x / 360).Turns; 
        
    Turns(x: Number): Angle 
        => x * TwoPi;    

    Degrees(x: Angle): Number
        => x.Turns * 360;

    Turns(x: Angle): Number
        => x / TwoPi;    
}

library Comparable
{
    Clamp(v: Comparable, a: Comparable, b: Comparable): Comparable
        => v.Greater(a).Lesser(b);

    Equals(a: Comparable, b: Comparable): Boolean 
        => a.Compare(b) == 0;
    
    NotEquals(a: Comparable, b: Comparable): Boolean 
        => a.Compare(b) != 0;
    
    LessThan(a: Comparable, b: Comparable): Boolean 
        => a.Compare(b) < 0;
    
    LessThanOrEquals(a: Comparable, b: Comparable): Boolean
        => a.Compare(b) <= 0;
    
    GreaterThan(a: Comparable, b: Comparable): Boolean 
        => a.Compare(b) > 0;
    
    GreaterThanOrEquals(a: Comparable, b: Comparable): Boolean 
        => a.Compare(b) >= 0;
       
    Lesser(a: Comparable, b: Comparable): Comparable 
        => a <= b ? a : b;
    
    Greater(a: Comparable, b: Comparable): Comparable 
        => a >= b ? a : b;
}
    
library Measures
{
    Value(x: Measure): Number
        => x.FieldValues[0];

    Add(x: Measure, y: Number): Measure
        => x.Value + y;

    Subtract(x: Measure, y: Number): Measure
        => x.Value - y;

    Multiply(x: Measure, y: Number): Measure
        => x.Value * y;

    Divide(x: Measure, y: Number): Measure
        => x.Value / y;

    Modulo(x: Measure, y: Number): Measure
        => x.Value % y;

    Negative(x: Measure): Measure
        => -x.Value;

    Fahrenheit(x: Temperature): Number
        => (x.Celsius * 9.0 / 5.0) + 32.0;

    Fahrenheit(x: Number): Temperature
        => (x - 32.0) * 5.0 / 9.0;

    Kelvin(x: Temperature): Number
        => x.Celsius + 273.15;

    Kelvin(x: Number): Temperature
        => x - 273.15;

    Multiply(x: Length, y: Length): Area
        => x.Value * y.Value;

    Divide(x: Area, y: Length): Length
        => x.Value / y.Value;

    Multiply(x: Area, y: Length): Volume
        => x.Value * y.Value;

    Multiply(x: Length, y: Area): Volume
        => x.Value * y.Value;

    Divide(x: Volume, y: Length): Area
        => x.Value / y.Value;

    Divide(x: Volume, y: Area): Length
        => x.Value / y.Value;

    Multiply(x: Length, y: Time): Velocity
        => x.Value * y.Value;

    Multiply(x: Time, y: Length): Velocity
        => x.Value * y.Value;

    Divide(x: Velocity, y: Time): Length
        => x.Value / y.Value;

    Divide(x: Velocity, y: Length): Time
        => x.Value / y.Value;

    Multiply(x: Velocity, y: Time): Acceleration
        => x.Value * y.Value;

    Divide(x: Acceleration, y: Time): Velocity
        => x.Value / y.Value;

    Divide(x: Acceleration, y: Velocity): Time
        => x.Value / y.Value;

    Multiply(x: Mass, y: Acceleration): Force
        => x.Value * y.Value;

    Days(x: Number): Time
        => x * 86400.0;

    Milliseconds(x: Number): Time
        => (x / 1000.0).Seconds;

    Seconds(x: Number): Time
        => x;

    Minutes(x: Number): Time
        => (x * 60.0).Seconds;

    Hours(x: Number): Time
        => (x * 60).Minutes;

    Days(x: Time): Number
        => (x * 24.0).Hours;

    Milliseconds(x: Time): Number
        => x.Seconds * 1000.0;

    Minutes(x: Time): Number
        => x.Seconds / 60.0;

    Hours(x: Time): Number
        => x.Minutes / 60.0;

    Days(x: Time): Number
        => x.Hours / 24.0;

    Subtract(a: DateTime, b: DateTime): Time
        => a.Value - b.Value;
}

library Signal 
{    
    // https://en.wikipedia.org/wiki/Sinc_function
    Sinc(x: Angle): Number
        => x.Radians.AlmostZero ? 1.0 : x.Sin / x;

    // https://en.wikipedia.org/wiki/Heaviside_step_function
    HeavisideStep(t: Number): Number
        => t.LtZ ? 0.0 : 1.0;

    // https://en.wikipedia.org/wiki/Rectangular_function
    Rectangular(t: Number, width: Number): Number
        => t.Abs >= width.Half ? 0.0 : 1.0; 
}
