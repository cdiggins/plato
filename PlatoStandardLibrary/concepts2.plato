
concept Interval<T : Numerical>
{
    field Min : T;
    field Max : T;  
}

operations Interval
{
    function Size(x) => x.Max - x.Min;
    function IsEmpty(x) => x.Min >= x.Max;
    function Lerp(x, amount) => x.Min * (1.0 - amount) + x.Max * amount;
    function InverseLerp(x, value) => (value - x.Min) / x.Size;
    function Multiply(x, y) => Interval(x.Min * y, x.Max * y);
    function Add(x) => Interval(Min + x, Max + x);
    function Negate(x) => Interval(-Max, -Min);
    function Reverse(x) => Interval(Max, Min);
    function Resize(x, size) => Interval(x.Min, x.Min + size);
    function Center(x) => x.Lerp(0.5);    
    function Contains(x, value) => x.Min <= value && value <= x.Max;
    function Contains(x, other) => x.Min <= other.Min && Max >= other.Max;
    function Overlaps(x, y) => y.Contains(x) || x.Contains(y.Min);
    function Split(x, t) => Interval(x.Left(t), x.Right(t));
    function Split(x) => x.Split(0.5);
    function Left(x, t) => Interval(Min, x.Lerp(t));
    function Right(x, t) => Interval(x.Lerp(t), x.Max);
    function MoveTo(x, t) => Interval(t, t + x.Size);
    function HalfSize() => Size() / 2;
    function Recenter(x, c) => Interval(c - x.HalfSize, c + x.HalfSize);
    function Clamp(x, value) => value < x.Min ? x.Min : value > x.Max ? x.Max : value;
    function Between(x, value) => value >= x.Min && value <= x.Max;
    function Unit() => Interval(0, 1);
}

concept Vector<T : Numerical> 
    inherits Array, Value, Numerical
{
}

extension Vector
{
    function Sum() => Aggregate(0, Add); 
    function SumSquares() => Map(Square).Aggregate(0, Add); 
    function LengthSquared() => SumSquares;
    function Length() => LengthSquared.SquareRoot;
    function Add(other) => Zip(other, Add);
    function Multiply(value) => Zip(other, Multiply);
    function Multiply(scalar) => Map(x, Multiply);
}

concept Numerical 
    inherits Equatable, Comparable, Arithmetic<Self>
{
    field Value: Numerical;
    function ToDouble(): Double;
    function FromDouble(x: Double): Self;

    // fields? 
}

extension Numerical 
{
    function MinValue() => _double.MinValue;
    function SquareRoot() => intrinsic;
    function MaxValue() => _double.MaxValue;
    function Square() => Value * Value;
    function Clamp(min, max) => Interval(min, max).Clamp(this);
    function Clamp() => Clamp(0, 1);
    function PlusOne() => Value + 1;
    function MinusOne() => Value - 1;
    function Sign() => CompareTo(0) < 0 ? -1 : CompareTo(1) > 0 ? 1 : 0;
    function Abs() => Value < 0 ? -Value : Value;
    function Half() => this * 0.5;
    function Quarter() => this * 0.25;
    function Tenth() => this * 0.1;
    function Hundredth() => this / 100;
    function Thousandth() => this / 1000;
    function Millionth() => this / 1000 / 1000;
    function Billionth() => this / 1000 / 1000 / 1000;
    function Hundred() => this * 100;
    function Thousand() => this * 1000;
    function Million() => this * 1000 * 1000;
    function Billion() => this * 1000 * 1000 * 1000;
    function Twice() => this * 2;
    function Thrice() => this * 3;
    function SmoothStep() => Square * (3 - 2 * this);
    function Pow2() => this.Multiply(this);
    function Pow3() => Pow2.Multiply(this);
    function Pow4() => Pow3.Multiply(this);
    function Pow5() => Pow4.Multiply(this);
}

concept Integer
{
    field Value: Any;
    function Negative(): Integer;
    function Add(x: Integer): Integer;
    function Subtract(x: Integer): Integer;
}

concept Comparable
{
    function Compare(other: Self): Integer;
}

extension Comparable
{
    function LessThan(x) => Compare(x) < 0;
    function LessThanOrEqual(x) => Compare(x) <= 0;
    function GreaterThan(x) => Compare(x) > 0;
    function GreaterThanOrEqual(x) => Compare(x) >= 0;
    function Min(x) => LessThan(x) ? this : x;
    function Max(x) => GreaterThan(x) ? this : x;
    function Between(x, y) => Interval(x, y).Between(this);
}

concept Equatable
{
    function Equals(x: Self): Boolean
}

extension Equatable
{
    function NotEquals(x) => !Equals(x);
}

// https://en.wikipedia.org/wiki/Group_(mathematics)
concept Additive<T>
{
    function Add(x: T): Self;
    function AdditiveInverse(): Self; 
    function Negative(): Self;
    function Subtract(x: T): Self;
}

// https://en.wikipedia.org/wiki/Group_(mathematics)
concept Multiplicative<T>
{
    function Multiply(x: T): Self;
    function Reciprocal(): Self;
    function MultiplicativeIdentity(): Self;
    function Divide(x: T): Self;
    function Modulo(x: T): Self;
}

concept Arithemtic<T>
    inherits Multiplicative<T>, Additive<T>
{ 
}

concept ScalarArithemtic
    inherits Arithmetic<Number>
{
}

concept Measure
    inherits Value, Additive<Self>, ScalarArithemtic, Equatable, Comparable
{ 
}

concept Array<T>
{
    field Count: Count;    
    function At(n: Index): T;
}

extension Array
{
    function Map(f) => Array(Count, i => f(At(i)));
    function Zip(other, f) => Array(Count, i => f(At(i), other.At(i));
    function Skip(n) => Array(Count - n, i => At(i - n));
    function Take(n) => Array(n, i => );
    function Accumulate(init, f) => IsEmpty ? init : f(init, f(Rest));
    function Rest() => Skip(1);
    function IsEmpty() => Count == 0;
    function First() => At(1);
    function Last() => At(Count - 1);
    function Slice(from, count) => Skip(from).Take(count);
    function Join(sep) => IsEmpty ? "" : First.ToString + Skip(1).Accumulate("", (acc, cur) => $"{acc}{sep}{cur}")
}

concept Value : Array<Object>
{
    field Names: Array<string>;
}

extension Value
{
    function One() => (Count, i => At(i).One);
    function Zero() => (Count, i => At(i).Zero);
    function Default() => (Count, i => At(i).One);
    function ToString() => Zip(Names, (val, name) => $"{name} = {val}").Join(", ");
}
