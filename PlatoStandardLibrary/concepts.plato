// https://en.wikipedia.org/wiki/Top_type
// This is the Top Type in Plato. All types provide this. 
concept Any
{ 
    FieldNames(x: Self): Array<String>;     
    FieldValues(x: Self): Array<Dynamic>;
    TypeName(x: Self): String;
}

// Values is a read-only type which has any only Values as members
concept Value 
    inherits Any, Equatable
{ 
    Zero(x: Self): Self;
    One(x: Self): Self;
    MinValue(x: Self): Self;
    MaxValue(x: Self): Self;
}

// A numerical type represents things like floats, vectors, complex numbers
concept Numerical 
    inherits Value, Arithmetic, Magnitudinal, Betweenable, Equatable
{
}

// Represents a continuous one dimensional value.
// https://en.wikipedia.org/wiki/Real_number
// Most things that are Real, are also Numerical except for Measures.
// You can't do basic arithmetic on measures. 
concept Real
    inherits Magnitudinal, Interpolatable, Betweenable, Equatable, Comparable, ScalarArithmetic
{
    Value(x: Self): Number;
}

// Arrays are immutable types which can be indexed. 
// The "At" function maps to the indexing operator in C#. 
concept Array<T>
{
    Count(xs: Self): Integer;
    At(xs: Self, n: Integer): T;
}

// Extends the Array concept with rows and columns. 
concept Array2D<T>
    inherits Array<T>
{ 
    RowCount(xs: Self): Integer;
    ColumnCount(xs: Self): Integer;
    At(xs: Self, column: Integer, row: Integer): T;
}


// Vectors are arrays of numerical types. 
concept Vector
    inherits Array<Number>, Numerical, ScalarArithmetic, Interpolatable 
{ }

// A coordinate is a point in some cartesian space. This also includes 
// a time line, so a DateTime is considered a Coordinate. 
concept Coordinate
    inherits Value, Interpolatable, Betweenable
{ }

// A measure is a numeric value with an intrinisic unit of measure 
// which is implied by the implementing type. 
// It resembles a numerical type except you cannot multiply or divide two measures without 
// getting a new type. It does however support ScalarArithmetic 
concept Measure
    inherits Real
{ }

// Used for integer and cardinal types.
concept WholeNumber 
    inherits Numerical, Comparable
{ }

// Any type which has a numerical magnitude (like numbers, vectors, and measurements)
concept Magnitudinal
{
    Magnitude(x: Self): Number;
}

// The compare function return a negative integer if x < y, a positive integer if x > y, or zero otherwise. 
concept Comparable
    inherits Value, Equatable
{
    Compare(x: Self, y: Self): Integer;
}

// Supported for when two values are equal 
concept Equatable
{
    Equals(a: Self, b: Self): Boolean;
    NotEquals(a: Self, b: Self): Boolean;
}

concept Arithmetic 
    inherits AdditiveArithmetic<Self>, MultiplicativeArithmetic<Self>, 
        AdditiveInverse, MultiplicativeInverse
{ }

concept AdditiveInverse
{
    Negative(self: Self): Self;
}

concept MultiplicativeInverse
{
    Reciprocal(self: Self): Self;
}

concept AdditiveArithmetic<T>
{
    Add(self: Self, other: T): Self;    
    Subtract(self: Self, other: T): Self;
}

concept MultiplicativeArithmetic<T>
{
    Multiply(self: Self, other: T): Self;
    Divide(self: Self, other: T): Self;    
    Modulo(self: Self, other: T): Self;
}

concept ScalarArithmetic
    inherits AdditiveArithmetic<Number>, MultiplicativeArithmetic<Number>
{ }

concept BooleanOperations
{
    And(a: Self, b: Self): Self;
    Or(a: Self, b: Self): Self;    
    Not(a: Self): Self;
}

concept Interval<TValue, TSize>    
    where TValue: Interpolatable, 
        TValue: Betweenable, 
        TValue: AdditiveArithmetic<TSize>, 
        TSize: ScalarArithmetic 
    inherits Equatable, Value
{
    Min(x: Self): TValue;
    Max(x: Self): TValue;
    Size(x: Self): TSize;
}
    
concept Interpolatable
{
    Lerp(a: Self, b: Self, amount: Number): Self;
}

concept Betweenable
{
    Between(x: Self, a: Self, b: Self): Boolean;
    Clamp(x: Self, a: Self, b: Self): Self;
}

concept Transformable2D 
{
    Transform(x: Self, Matrix2D matrix): Self;
}

concept Transformable3D 
{
    Transform(x: Self, Matrix3D matrix): Self;
}

concept Deformable2D 
{
    Deform(x: Self, Function1<Vector2D, Vector2D> f): Self;
}

concept Deformable3D 
    inherits Transformable3D
{
    Deform(x: Self, Function1<Vector3D, Vector3D> f): Self;
}

concept Geometry 
    inherits Interpolatable 
{ }

concept Geometry2D
    inherits Deformable2D
{ }

concept Geometry3D
    inherits Deformable3D
{ }

concept Procedural<TDomain, TRange>
{
    Eval(x: Self, amount: TDomain): TRange;
}

concept PointGeometry3D
    inherits Geometry3D
{
    Points(x: Self): Array<Point3D>;
}

concept Curve<TRange> 
    inherits Procedural<Unit, TRange>
{ 
    Periodic(x: Self): Boolean;
}

concept Curve1D 
    inherits Curve<Number>
{ }

concept Curve2D
    inherits Geometry2D, Curve<Point2D>
{ }

concept Curve3D
    inherits Geometry, Curve<Point3D>
{ }

concept Surface<TRange>
    inherits Procedural<UV, TRange> 
{
    PeriodicU(x: Self): Boolean;
    PeriodicV(x: Self): Boolean;
}

concept ExplicitSurface 
    inherits Surface<Number>
{ }

concept Surface2D 
    inherits Geometry2D, Surface<Point2D>
{ }

concept Surface3D 
    inherits Geometry3D, Surface<Point3D>
{ }

concept DistanceField<TDomain>
    inherits Procedural<TDomain, Number>
{ }

// A Vector or Scalar field in 2-Dimensions
// https://en.wikipedia.org/wiki/Vector_field
concept Field2D<T>
    inherits Geometry2D, Procedural<Point2D, T>
{ }

// A Vector or Scalar field in 3-Dimensions
// https://en.wikipedia.org/wiki/Vector_field
concept Field3D<T>
    inherits Geometry3D, Procedural<Point3D, T>
{ }

concept ScalarField2D    
    inherits Field2D<Number> 
{ }

concept ScalarField3D
    inherits Field3D<Number>
{ }

concept DistanceField2D 
    inherits ScalarField2D
{ }

concept DistanceField3D
    inherits ScalarField3D
{ }

concept Vector3Field2D 
    inherits Field2D<Vector3D> 
{ }

concept Vector4Field2D 
    inherits Field2D<Vector4D> 
{ }

// A 3D field of 2D Vectors 
concept Vector2Field3D 
    inherits Field3D<Vector2D> 
{ }
    
// A 3D field of 3D Vectors (e.g., colors without alpha, or force vectors)
concept Vector3Field3D 
    inherits Field3D<Vector3D> 
{ }

// A 3D field of 4D Vectors (e.g., colors with alpha, or rotations)
concept Vector4Field3D 
    inherits Field3D<Vector4D> 
{ }

// An implicit procedural requires an epsilon to be provided for comparison 
// purposes. This provide the 'width' of an implicit curve, or depth of a surface. 
concept ImplicitProcedural<TDomain>  
{
    Eval(x: Self, amount: TDomain, epsilon: TDomain): Boolean;
}

// An implicit surface, where we are either on the surface or not. 
concept ImplicitSurface
    inherits Geometry3D, ImplicitProcedural<Point3D>
{ }

// An implicitly defined curve
concept ImplicitCurve2D
    inherits Geometry2D, ImplicitProcedural<Point2D>
{ }

// An implicit solid/volume, where we are either inside (true) or outside (false).
concept ImplicitVolume
    inherits Geometry3D, ImplicitProcedural<Point3D>
{ }

// Discretized geometrical concepts that are defined by a finite number of points 
concept Points3D
    inherits Geometry3D
{ 
    Points(x: Self): Array<Point3D>;
}

// https://en.wikipedia.org/wiki/B%C3%A9zier_surface
concept BezierPatch
    inherits Points3D, Surface3D, Array2D<Point3D>    
{ 
}

// A net of bezier patches  
// https://en.wikipedia.org/wiki/B%C3%A9zier_surface
concept BezierSurface
    inherits Points3D, Surface3D, Array2D<BicubicBezierPatch>    
{
}

// A 3 dimensional triangle mesh
concept TriMesh
    inherits Points3D
{
    Indices(x: Self): Array<Int3>;
}

// A 3 dimensional shape consisting of quadrilateral faces. 
// Quad meshes are easier to generate from UV functions.  
concept QuadMesh
    inherits Points3D
{
    Indices(x: Self): Array<Int4>;
}

// "Polygonal" meshes can be hard to work with because faces are not necessarily polygons
concept PolyMesh
    inherits Points3D
{
    Indices(x: Self): Array<Array<Integer>>
}

