concept Vector<T: Numerical> 
    inherits Array<T>, Value, Numerical, Arithmetic<T>
{
    Count(v: Vector): Count
        => Self.FieldTypes.Count;
        
    At(v: Vector, n: Index): T
        => v.FieldValues[n];
}

concept Measure
    inherits Value, ScalarArithmetic<Number>, Equatable, Comparable, Magnitude
{ 
    Value(x: Self): Number
        => x.FieldValues[0];
}

concept Numerical 
    inherits Value, Arithmetic, Equatable, Comparable, Magnitude
{
}

concept Magnitude
    inherits Value
{
    Magnitude(x: Self): Number
        => x.FieldValues.Square.Sum.SquareRoot;
}

concept Comparable
    inherits Value
{
    Compare(a: Self, b: Self): Integer
        => a.Magnitude < b.Magnitude ? -1 : a.Magnitude > b.Magnitude ? 1 : 0;
}

concept Equatable
    inherits Value
{
    Equals(a: Self, b: Self): Boolean
        => a.FieldValues.Equals(b.FieldValues).All;
}

concept Arithmetic
    inherits Value
{ 
    Add(self: Self, other: Self): Self
        => self.FieldValues.Add(other.FieldValues);

    Negative(self: Self): Self
        => self.FieldValues.Negative;

    Reciprocal(self: Self): Self
        => self.FieldValues.Reciprocal;
    
    Multiply(self: Self, other: Self): Self
        => self.FieldValues.Add(other.FieldValues);

    Divide(self: Self, other: Self): Self
        => self.FieldValues.Divide(other.FieldValues);

    Modulo(self: Self, other: Self): Self
        => self.FieldValues.Modulo(other.FieldValues);
}

concept ScalarArithmetic<T>
    inherits Value
{
    Add(self: Self, scalar: T): Self
        => self.FieldValues.Add(scalar);
    
    Subtract(self: Self, scalar: T): Self
        => self.Add(scalar.Negative);

    Multiply(self: Self, scalar: T): Self
        => self.FieldValues.Multiply(scalar);
    
    Divide(self: Self, scalar: T): Self
        => self.Multiply(scalar.Reciprocal);

    Modulo(self: Self, scalar: T): Self
        => self.FieldValues.Modulo(scalar);
}

concept Boolean
{
    And(a: Self, b: Self): Self 
        => a.FieldValues.And(b.FieldValues);

    Or(a: Self, b: Self): Self
        => a.FieldValues.Or(b.FieldValues);
    
    Not(a: Self): Self 
        => a.FieldValues.Not;
}

concept Value 
{
    Type(): Type
        => intrinsic;

    FieldTypes(): Array<Type>
        => intrinsic;

    FieldNames(): Array<String>
        => intrinsic;

    FieldValues(self: Self): Array<Value>
        => intrinsic;

    Zero(): Self
        => FieldTypes.Zero;

    One(): Self
        => FieldTypes.One;

    Default(): Self
        => FieldTypes.Default;

    MinValue(): Self
        => FieldTypes.MinValue;

    MaxValue(): Self
        => FieldTypes.MaxValue;

    ToString(x: Self): String
        => FieldValues.JoinStrings(",");
}

concept Interval<T: Numerical>
    inherits Vector<T>
{
    Min(x: Self): T;
    Max(x: Self): T;
}

concept Array<T: Any>
{
    Count(xs: Self): Count;
    At(xs: Self, n: Index): T;
}
