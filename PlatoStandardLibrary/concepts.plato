// https://en.wikipedia.org/wiki/Top_type
// This is the Top Type in Plato. All types provide this. 
concept Any
{ 
    FieldNames(x: Self): Array<String>;     
    FieldValues(x: Self): Array<Dynamic>;
    TypeName(x: Self): String;
}

// Values is a read-only type which has any only Values as members
concept Value 
    inherits Any, Equatable
{ 
    Zero(x: Self): Self;
    One(x: Self): Self;
    MinValue(x: Self): Self;
    MaxValue(x: Self): Self;
}

// Arrays are immutable types which can be indexed. 
// The "At" function maps to the indexing operator in C#. 
concept Array<T>
{
    Count(xs: Self): Integer;
    At(xs: Self, n: Integer): T;
}

// Vectors are numerical types which are arrays of numerical types. 
concept Vector
    inherits Array<Number>, Numerical, Magnitudinal, Equatable, Interpolatable, ScalarArithmetic
{
}

// A coordinate is a point in some cartesian space. This also includes 
// a time line, so a DateTime is considered a Coordinate. 
concept Coordinate
    inherits Interpolatable, Comparable, Value
{
}

// A measure is a numeric value with an intrinisic unit of measure 
// which is implied by the implementing type. 
// It resembles a numerical type except you cannot multiply or divide two measures without 
// getting a new type. It does however support ScalarArithmetic 
concept Measure
    inherits Value, ScalarArithmetic, Comparable, Magnitudinal, Interpolatable
{ 
    Value(x: Self): Number;
}

// Used for integer and cardinal types.
concept WholeNumber 
    inherits Arithmetic, Equatable, Comparable, Magnitudinal
{ }

// A numerical type represents things like floats and complex numbers
concept Numerical 
    inherits Value, Arithmetic, Equatable, Comparable, Magnitudinal, Interpolatable, ScalarArithmetic
{
}

// Any type which has a numerical magnitude (like numbers, vectors, and measurements)
concept Magnitudinal
    inherits Comparable
{
    Magnitude(x: Self): Number;
}

// The compare function return a negative integer if x < y, a positive integer if x > y, or zero otherwise. 
concept Comparable
    inherits Equatable
{
    Compare(x: Self, y: Self): Integer;
}

// Supported for when two values are equal 
concept Equatable
{
    Equals(a: Self, b: Self): Boolean;
    NotEquals(a: Self, b: Self): Boolean;
}

concept Arithmetic 
    inherits AdditiveArithmetic<Self>, MultiplicativeArithmetic<Self>, 
        AdditiveInverse, MultiplicativeInverse
{ 
}

concept AdditiveInverse
{
    Negative(self: Self): Self;
}

concept MultiplicativeInverse
{
    Reciprocal(self: Self): Self;
}

concept AdditiveArithmetic<T>
{
    Add(self: Self, other: T): Self;    
    Subtract(self: Self, other: T): Self;
}

concept MultiplicativeArithmetic<T>
{
    Multiply(self: Self, other: T): Self;
    Divide(self: Self, other: T): Self;    
    Modulo(self: Self, other: T): Self;
}

concept ScalarArithmetic
    inherits AdditiveArithmetic<Number>, MultiplicativeArithmetic<Number>
{
}

concept BooleanOperations
{
    And(a: Self, b: Self): Self;
    Or(a: Self, b: Self): Self;    
    Not(a: Self): Self;
}

concept Interval<TValue, TSize>    
    where TValue: Interpolatable, TValue: AdditiveArithmetic<TSize>, TSize: ScalarArithmetic 
    inherits Equatable, Value
{
    Min(x: Self): TValue;
    Max(x: Self): TValue;
    Size(x: Self): TSize;
}
    
concept Interpolatable
{
    Lerp(a: Self, b: Self, amount: Number): Self;
    Unlerp(v: Self, a: Self, b: Self): Number;
}